<!doctype html>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

<!-- polyfills -->
<script>var alert_log =	function () {
					var msg = '';
					for (var key in arguments) {
						var value = arguments [key];
						msg = (msg ? msg + '\n\n......\n\n' : '') + value +'\n'+ circular_json (value, 4, 2);
					}
					alert (msg);
				};
					var circular_json =	function (input, maxDepth, indent) {
										    var output;
										        
										    maxDepth = maxDepth || 5;
										        
										    if (typeof input === "object") {
										        output = recursion (maxDepth) (input);
										    }
										    else {
										        output = input;
										    }
										    
										    return JSON .stringify (output, null, indent);
										};
											var recursion =	function (maxDepth) {
																var refs = [];
																var refsPaths = [];
																var self =	function (input, path, depth) {
																		        var output = {},
																		            pPath,
																		            refIdx;
																		        
																		        path  = path  || "";
																		        depth = depth || 0;
																		        depth ++;
																		        
																		        if (maxDepth && depth > maxDepth) {
																		            return "{depth over " + maxDepth + "}";
																		        }
																		        
																		        for (var p in input) {
																		            pPath = (path ? (path + ".") : "") + p;
																		            if (typeof input [p] === "function") {
																		                output [p] = "{function}";
																		            }
																		            else if (typeof input [p] === "object") {
																		                refIdx = refs .indexOf (input [p]);
																		                
																		                if (-1 !== refIdx) {
																		                    output [p] = "{reference to " + refsPaths [refIdx]  + "}";
																		                }
																		                else {
																		                    refs .push (input [p]);
																		                    refsPaths .push (pPath);
																		                    output [p] = self (input [p], pPath, depth);
																		                }
																		            }
																		            else {
																		                output [p] = input [p];
																		            }
																		        }
																		        
																		        return output;
																		    };
																return self;
														    };
			
			
//log = alert_log;
log =	function () {
			console .log .apply (console, arguments);	
		};

log .error =	function () {
					(log === alert_log) || log .apply (this, arguments);
					alert_log .apply (this, arguments);
				};

logged =	function (/* args */) {
				log .apply (this, arguments);
				return arguments [arguments .length - 1];
			};
logged_with =	function (/* args */) {
					var args = [] .slice .call (arguments);
					return	function (item) {
								log .apply (null, args .concat (item));
								return item;
							};
				};
			</script>
<script>!function(t){function e(){}function n(t,e){return function(){t.apply(e,arguments)}}function o(t){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],s(t,this)}function r(t,e){for(;3===t._state;)t=t._value;return 0===t._state?void t._deferreds.push(e):(t._handled=!0,void a(function(){var n=1===t._state?e.onFulfilled:e.onRejected;if(null===n)return void(1===t._state?i:f)(e.promise,t._value);var o;try{o=n(t._value)}catch(r){return void f(e.promise,r)}i(e.promise,o)}))}function i(t,e){try{if(e===t)throw new TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var r=e.then;if(e instanceof o)return t._state=3,t._value=e,void u(t);if("function"==typeof r)return void s(n(r,e),t)}t._state=1,t._value=e,u(t)}catch(i){f(t,i)}}function f(t,e){t._state=2,t._value=e,u(t)}function u(t){2===t._state&&0===t._deferreds.length&&a(function(){t._handled||d(t._value)});for(var e=0,n=t._deferreds.length;n>e;e++)r(t,t._deferreds[e]);t._deferreds=null}function c(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n}function s(t,e){var n=!1;try{t(function(t){n||(n=!0,i(e,t))},function(t){n||(n=!0,f(e,t))})}catch(o){if(n)return;n=!0,f(e,o)}}var l=setTimeout,a="function"==typeof setImmediate&&setImmediate||function(t){l(t,0)},d=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t)};o.prototype["catch"]=function(t){return this.then(null,t)},o.prototype.then=function(t,n){var o=new this.constructor(e);return r(this,new c(t,n,o)),o},o.all=function(t){var e=Array.prototype.slice.call(t);return new o(function(t,n){function o(i,f){try{if(f&&("object"==typeof f||"function"==typeof f)){var u=f.then;if("function"==typeof u)return void u.call(f,function(t){o(i,t)},n)}e[i]=f,0===--r&&t(e)}catch(c){n(c)}}if(0===e.length)return t([]);for(var r=e.length,i=0;i<e.length;i++)o(i,e[i])})},o.resolve=function(t){return t&&"object"==typeof t&&t.constructor===o?t:new o(function(e){e(t)})},o.reject=function(t){return new o(function(e,n){n(t)})},o.race=function(t){return new o(function(e,n){for(var o=0,r=t.length;r>o;o++)t[o].then(e,n)})},o._setImmediateFn=function(t){a=t},o._setUnhandledRejectionFn=function(t){d=t},"undefined"!=typeof module&&module.exports?module.exports=o:t.Promise||(t.Promise=o)}(this);</script>
<script></script>
<script>/* Riot v3.0.1, @license MIT */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.riot = global.riot || {})));
}(this, (function (exports) { 'use strict';

var __TAGS_CACHE = [];
var __TAG_IMPL = {};
var GLOBAL_MIXIN = '__global_mixin';
var RIOT_PREFIX = 'riot-';
var RIOT_TAG_IS = 'data-is';
var T_STRING = 'string';
var T_OBJECT = 'object';
var T_UNDEF  = 'undefined';
var T_FUNCTION = 'function';
var XLINK_NS = 'http://www.w3.org/1999/xlink';
var XLINK_REGEX = /^xlink:(\w+)/;
var WIN = typeof window === T_UNDEF ? undefined : window;
var RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;
var RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;
var RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;
var RE_SVG_TAGS = /^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/;
var RE_HTML_ATTRS = /([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g;
var RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;
var IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;

/**
 * Check whether a DOM node must be considered a part of an svg document
 * @param   { String } name -
 * @returns { Boolean } -
 */
function isSVGTag(name) {
  return RE_SVG_TAGS.test(name)
}

/**
 * Check Check if the passed argument is undefined
 * @param   { String } value -
 * @returns { Boolean } -
 */
function isBoolAttr(value) {
  return RE_BOOL_ATTRS.test(value)
}

/**
 * Check if passed argument is a function
 * @param   { * } value -
 * @returns { Boolean } -
 */
function isFunction(value) {
  return typeof value === T_FUNCTION || false // avoid IE problems
}

/**
 * Check if passed argument is an object, exclude null
 * NOTE: use isObject(x) && !isArray(x) to excludes arrays.
 * @param   { * } value -
 * @returns { Boolean } -
 */
function isObject(value) {
  return value && typeof value === T_OBJECT // typeof null is 'object'
}

/**
 * Check if passed argument is undefined
 * @param   { * } value -
 * @returns { Boolean } -
 */
function isUndefined(value) {
  return typeof value === T_UNDEF
}

/**
 * Check if passed argument is a string
 * @param   { * } value -
 * @returns { Boolean } -
 */
function isString(value) {
  return typeof value === T_STRING
}

/**
 * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank
 * @param { * } value -
 * @returns { Boolean } -
 */
function isBlank(value) {
  return isUndefined(value) || value === null || value === ''
}

/**
 * Check if passed argument is a kind of array
 * @param   { * } value -
 * @returns { Boolean } -
 */
function isArray(value) {
  return Array.isArray(value) || value instanceof Array
}

/**
 * Check whether object's property could be overridden
 * @param   { Object }  obj - source object
 * @param   { String }  key - object property
 * @returns { Boolean } -
 */
function isWritable(obj, key) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, key);
  return isUndefined(obj[key]) || descriptor && descriptor.writable
}

/**
 * Check if passed argument is a reserved name
 * @param   { String } value -
 * @returns { Boolean } -
 */
function isReservedName(value) {
  return RE_RESERVED_NAMES.test(value)
}

var check = Object.freeze({
	isSVGTag: isSVGTag,
	isBoolAttr: isBoolAttr,
	isFunction: isFunction,
	isObject: isObject,
	isUndefined: isUndefined,
	isString: isString,
	isBlank: isBlank,
	isArray: isArray,
	isWritable: isWritable,
	isReservedName: isReservedName
});

/**
 * Shorter and fast way to select multiple nodes in the DOM
 * @param   { String } selector - DOM selector
 * @param   { Object } ctx - DOM node where the targets of our search will is located
 * @returns { Object } dom nodes found
 */
function $$(selector, ctx) {
  return (ctx || document).querySelectorAll(selector)
}

/**
 * Shorter and fast way to select a single node in the DOM
 * @param   { String } selector - unique dom selector
 * @param   { Object } ctx - DOM node where the target of our search will is located
 * @returns { Object } dom node found
 */
function $(selector, ctx) {
  return (ctx || document).querySelector(selector)
}

/**
 * Create a document fragment
 * @returns { Object } document fragment
 */
function createFrag() {
  return document.createDocumentFragment()
}

/**
 * Create a document text node
 * @returns { Object } create a text node to use as placeholder
 */
function createDOMPlaceholder() {
  return document.createTextNode('')
}

/**
 * Create a generic DOM node
 * @param   { String } name - name of the DOM node we want to create
 * @param   { Boolean } isSvg - should we use a SVG as parent node?
 * @returns { Object } DOM node just created
 */
function mkEl(name, isSvg) {
  return isSvg ?
    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :
    document.createElement(name)
}

/**
 * Get the outer html of any DOM node SVGs included
 * @param   { Object } el - DOM node to parse
 * @returns { String } el.outerHTML
 */
function getOuterHTML(el) {
  if (el.outerHTML)
    { return el.outerHTML }
  // some browsers do not support outerHTML on the SVGs tags
  else {
    var container = mkEl('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

/**
 * Set the inner html of any DOM node SVGs included
 * @param { Object } container - DOM node where we'll inject new html
 * @param { String } html - html to inject
 */
function setInnerHTML(container, html) {
  if (!isUndefined(container.innerHTML))
    { container.innerHTML = html; }
    // some browsers do not support innerHTML on the SVGs tags
  else {
    var doc = new DOMParser().parseFromString(html, 'application/xml');
    var node = container.ownerDocument.importNode(doc.documentElement, true);
    container.appendChild(node);
  }
}

/**
 * Remove any DOM attribute from a node
 * @param   { Object } dom - DOM node we want to update
 * @param   { String } name - name of the property we want to remove
 */
function remAttr(dom, name) {
  dom.removeAttribute(name);
}

/**
 * Get the value of any DOM attribute on a node
 * @param   { Object } dom - DOM node we want to parse
 * @param   { String } name - name of the attribute we want to get
 * @returns { String | undefined } name of the node attribute whether it exists
 */
function getAttr(dom, name) {
  return dom.getAttribute(name)
}

/**
 * Set any DOM attribute
 * @param { Object } dom - DOM node we want to update
 * @param { String } name - name of the property we want to set
 * @param { String } val - value of the property we want to set
 */
function setAttr(dom, name, val) {
  var xlink = XLINK_REGEX.exec(name);
  if (xlink && xlink[1])
    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }
  else
    { dom.setAttribute(name, val); }
}

/**
 * Insert safely a tag to fix #1962 #1649
 * @param   { HTMLElement } root - children container
 * @param   { HTMLElement } curr - node to insert
 * @param   { HTMLElement } next - node that should preceed the current node inserted
 */
function safeInsert(root, curr, next) {
  root.insertBefore(curr, next.parentNode && next);
}

/**
 * Minimize risk: only zero or one _space_ between attr & value
 * @param   { String }   html - html string we want to parse
 * @param   { Function } fn - callback function to apply on any attribute found
 */
function walkAttrs(html, fn) {
  if (!html)
    { return }
  var m;
  while (m = RE_HTML_ATTRS.exec(html))
    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }
}

/**
 * Walk down recursively all the children tags starting dom node
 * @param   { Object }   dom - starting node where we will start the recursion
 * @param   { Function } fn - callback to transform the child node just found
 * @param   { Object }   context - fn can optionally return an object, which is passed to children
 */
function walkNodes(dom, fn, context) {
  if (dom) {
    var res = fn(dom, context);
    var next;
    // stop the recursion
    if (res === false) { return }

    dom = dom.firstChild;

    while (dom) {
      next = dom.nextSibling;
      walkNodes(dom, fn, res);
      dom = next;
    }
  }
}

var dom = Object.freeze({
	$$: $$,
	$: $,
	createFrag: createFrag,
	createDOMPlaceholder: createDOMPlaceholder,
	mkEl: mkEl,
	getOuterHTML: getOuterHTML,
	setInnerHTML: setInnerHTML,
	remAttr: remAttr,
	getAttr: getAttr,
	setAttr: setAttr,
	safeInsert: safeInsert,
	walkAttrs: walkAttrs,
	walkNodes: walkNodes
});

var styleNode;
var cssTextProp;
var byName = {};
var remainder = [];

// skip the following code on the server
if (WIN) {
  styleNode = (function () {
    // create a new style element with the correct type
    var newNode = mkEl('style');
    setAttr(newNode, 'type', 'text/css');

    // replace any user node or insert the new one into the head
    var userNode = $('style[type=riot]');
    if (userNode) {
      if (userNode.id) { newNode.id = userNode.id; }
      userNode.parentNode.replaceChild(newNode, userNode);
    }
    else { document.getElementsByTagName('head')[0].appendChild(newNode); }

    return newNode
  })();
  cssTextProp = styleNode.styleSheet;
}

/**
 * Object that will be used to inject and manage the css of every tag instance
 */
var styleManager = {
  styleNode: styleNode,
  /**
   * Save a tag style to be later injected into DOM
   * @param { String } css - css string
   * @param { String } name - if it's passed we will map the css to a tagname
   */
  add: function add(css, name) {
    if (name) { byName[name] = css; }
    else { remainder.push(css); }
  },
  /**
   * Inject all previously saved tag styles into DOM
   * innerHTML seems slow: http://jsperf.com/riot-insert-style
   */
  inject: function inject() {
    if (!WIN) { return }
    var style = Object.keys(byName)
      .map(function(k) { return byName[k] })
      .concat(remainder).join('\n');
    if (cssTextProp) { cssTextProp.cssText = style; }
    else { styleNode.innerHTML = style; }
  }
};

/**
 * The riot template engine
 * @version v3.0.0
 */
/**
 * riot.util.brackets
 *
 * - `brackets    ` - Returns a string or regex based on its parameter
 * - `brackets.set` - Change the current riot brackets
 *
 * @module
 */

/* global riot */

var brackets = (function (UNDEF) {

  var
    REGLOB = 'g',

    R_MLCOMMS = /\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g,

    R_STRINGS = /"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'/g,

    S_QBLOCKS = R_STRINGS.source + '|' +
      /(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source + '|' +
      /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?(\/)[gim]*/.source,

    UNSUPPORTED = RegExp('[\\' + 'x00-\\x1F<>a-zA-Z0-9\'",;\\\\]'),

    NEED_ESCAPE = /(?=[[\]()*+?.^$|])/g,

    FINDBRACES = {
      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),
      '[': RegExp('([[\\]])|' + S_QBLOCKS, REGLOB),
      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)
    },

    DEFAULT = '{ }';

  var _pairs = [
    '{', '}',
    '{', '}',
    /{[^}]*}/,
    /\\([{}])/g,
    /\\({)|{/g,
    RegExp('\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),
    DEFAULT,
    /^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/,
    /(^|[^\\]){=[\S\s]*?}/
  ];

  var
    cachedBrackets = UNDEF,
    _regex,
    _cache = [],
    _settings;

  function _loopback (re) { return re }

  function _rewrite (re, bp) {
    if (!bp) { bp = _cache; }
    return new RegExp(
      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''
    )
  }

  function _create (pair) {
    if (pair === DEFAULT) { return _pairs }

    var arr = pair.split(' ');

    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {
      throw new Error('Unsupported brackets "' + pair + '"')
    }
    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\').split(' '));

    arr[4] = _rewrite(arr[1].length > 1 ? /{[\S\s]*?}/ : _pairs[4], arr);
    arr[5] = _rewrite(pair.length > 3 ? /\\({|})/g : _pairs[5], arr);
    arr[6] = _rewrite(_pairs[6], arr);
    arr[7] = RegExp('\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);
    arr[8] = pair;
    return arr
  }

  function _brackets (reOrIdx) {
    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]
  }

  _brackets.split = function split (str, tmpl, _bp) {
    // istanbul ignore next: _bp is for the compiler
    if (!_bp) { _bp = _cache; }

    var
      parts = [],
      match,
      isexpr,
      start,
      pos,
      re = _bp[6];

    isexpr = start = re.lastIndex = 0;

    while ((match = re.exec(str))) {

      pos = match.index;

      if (isexpr) {

        if (match[2]) {
          re.lastIndex = skipBraces(str, match[2], re.lastIndex);
          continue
        }
        if (!match[3]) {
          continue
        }
      }

      if (!match[1]) {
        unescapeStr(str.slice(start, pos));
        start = re.lastIndex;
        re = _bp[6 + (isexpr ^= 1)];
        re.lastIndex = start;
      }
    }

    if (str && start < str.length) {
      unescapeStr(str.slice(start));
    }

    return parts

    function unescapeStr (s) {
      if (tmpl || isexpr) {
        parts.push(s && s.replace(_bp[5], '$1'));
      } else {
        parts.push(s);
      }
    }

    function skipBraces (s, ch, ix) {
      var
        match,
        recch = FINDBRACES[ch];

      recch.lastIndex = ix;
      ix = 1;
      while ((match = recch.exec(s))) {
        if (match[1] &&
          !(match[1] === ch ? ++ix : --ix)) { break }
      }
      return ix ? s.length : recch.lastIndex
    }
  };

  _brackets.hasExpr = function hasExpr (str) {
    return _cache[4].test(str)
  };

  _brackets.loopKeys = function loopKeys (expr) {
    var m = expr.match(_cache[9]);

    return m
      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }
      : { val: expr.trim() }
  };

  _brackets.array = function array (pair) {
    return pair ? _create(pair) : _cache
  };

  function _reset (pair) {
    if ((pair || (pair = DEFAULT)) !== _cache[8]) {
      _cache = _create(pair);
      _regex = pair === DEFAULT ? _loopback : _rewrite;
      _cache[9] = _regex(_pairs[9]);
    }
    cachedBrackets = pair;
  }

  function _setSettings (o) {
    var b;

    o = o || {};
    b = o.brackets;
    Object.defineProperty(o, 'brackets', {
      set: _reset,
      get: function () { return cachedBrackets },
      enumerable: true
    });
    _settings = o;
    _reset(b);
  }

  Object.defineProperty(_brackets, 'settings', {
    set: _setSettings,
    get: function () { return _settings }
  });

  /* istanbul ignore next: in the browser riot is always in the scope */
  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};
  _brackets.set = _reset;

  _brackets.R_STRINGS = R_STRINGS;
  _brackets.R_MLCOMMS = R_MLCOMMS;
  _brackets.S_QBLOCKS = S_QBLOCKS;

  return _brackets

})();

/**
 * @module tmpl
 *
 * tmpl          - Root function, returns the template value, render with data
 * tmpl.hasExpr  - Test the existence of a expression inside a string
 * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)
 */

var tmpl = (function () {

  var _cache = {};

  function _tmpl (str, data) {
    if (!str) { return str }

    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)
  }

  _tmpl.hasExpr = brackets.hasExpr;

  _tmpl.loopKeys = brackets.loopKeys;

  // istanbul ignore next
  _tmpl.clearCache = function () { _cache = {}; };

  _tmpl.errorHandler = null;

  function _logErr (err, ctx) {

    err.riotData = {
      tagName: ctx && ctx.root && ctx.root.tagName,
      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase
    };

    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }

    if (
      typeof console !== 'undefined' &&
      typeof console.error === 'function'
    ) {
      if (err.riotData.tagName) {
        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);
      }
      console.error(err);
    }
  }

  function _create (str) {
    var expr = _getTmpl(str);

    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }

    return new Function('E', expr + ';')    // eslint-disable-line no-new-func
  }

  var
    CH_IDEXPR = String.fromCharCode(0x2057),
    RE_CSNAME = /^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\u2057(\d+)~):/,
    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),
    RE_DQUOTE = /\u2057/g,
    RE_QBMARK = /\u2057(\d+)~/g;

  function _getTmpl (str) {
    var
      qstr = [],
      expr,
      parts = brackets.split(str.replace(RE_DQUOTE, '"'), 1);

    if (parts.length > 2 || parts[0]) {
      var i, j, list = [];

      for (i = j = 0; i < parts.length; ++i) {

        expr = parts[i];

        if (expr && (expr = i & 1

            ? _parseExpr(expr, 1, qstr)

            : '"' + expr
                .replace(/\\/g, '\\\\')
                .replace(/\r\n?|\n/g, '\\n')
                .replace(/"/g, '\\"') +
              '"'

          )) { list[j++] = expr; }

      }

      expr = j < 2 ? list[0]
           : '[' + list.join(',') + '].join("")';

    } else {

      expr = _parseExpr(parts[1], 0, qstr);
    }

    if (qstr[0]) {
      expr = expr.replace(RE_QBMARK, function (_, pos) {
        return qstr[pos]
          .replace(/\r/g, '\\r')
          .replace(/\n/g, '\\n')
      });
    }
    return expr
  }

  var
    RE_BREND = {
      '(': /[()]/g,
      '[': /[[\]]/g,
      '{': /[{}]/g
    };

  function _parseExpr (expr, asText, qstr) {

    expr = expr
          .replace(RE_QBLOCK, function (s, div) {
            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s
          })
          .replace(/\s+/g, ' ').trim()
          .replace(/\ ?([[\({},?\.:])\ ?/g, '$1');

    if (expr) {
      var
        list = [],
        cnt = 0,
        match;

      while (expr &&
            (match = expr.match(RE_CSNAME)) &&
            !match.index
        ) {
        var
          key,
          jsb,
          re = /,|([[{(])|$/g;

        expr = RegExp.rightContext;
        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\s+/g, ' ') : match[1];

        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }

        jsb  = expr.slice(0, match.index);
        expr = RegExp.rightContext;

        list[cnt++] = _wrapExpr(jsb, 1, key);
      }

      expr = !cnt ? _wrapExpr(expr, asText)
           : cnt > 1 ? '[' + list.join(',') + '].join(" ").trim()' : list[0];
    }
    return expr

    function skipBraces (ch, re) {
      var
        mm,
        lv = 1,
        ir = RE_BREND[ch];

      ir.lastIndex = re.lastIndex;
      while (mm = ir.exec(expr)) {
        if (mm[0] === ch) { ++lv; }
        else if (!--lv) { break }
      }
      re.lastIndex = lv ? expr.length : ir.lastIndex;
    }
  }

  // istanbul ignore next: not both
  var // eslint-disable-next-line max-len
    JS_CONTEXT = '"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',
    JS_VARNAME = /[,{][\$\w]+(?=:)|(^ *|[^$\w\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g,
    JS_NOPROPS = /^(?=(\.[$\w]+))\1(?:[^.[(]|$)/;

  function _wrapExpr (expr, asText, key) {
    var tb;

    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {
      if (mvar) {
        pos = tb ? 0 : pos + match.length;

        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {
          match = p + '("' + mvar + JS_CONTEXT + mvar;
          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }
        } else if (pos) {
          tb = !JS_NOPROPS.test(s.slice(pos));
        }
      }
      return match
    });

    if (tb) {
      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';
    }

    if (key) {

      expr = (tb
          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'
        ) + '?"' + key + '":""';

    } else if (asText) {

      expr = 'function(v){' + (tb
          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'
        ) + ';return v||v===0?v:""}.call(this)';
    }

    return expr
  }

  _tmpl.version = brackets.version = 'v3.0.0';

  return _tmpl

})();

/**
 * Specialized function for looping an array-like collection with `each={}`
 * @param   { Array } list - collection of items
 * @param   {Function} fn - callback function
 * @returns { Array } the array looped
 */
function each(list, fn) {
  var len = list ? list.length : 0;

  for (var i = 0, el; i < len; ++i) {
    el = list[i];
    // return false -> current item was removed by fn during the loop
    if (fn(el, i) === false)
      { i--; }
  }
  return list
}

/**
 * Check whether an array contains an item
 * @param   { Array } array - target array
 * @param   { * } item - item to test
 * @returns { Boolean } -
 */
function contains(array, item) {
  return ~array.indexOf(item)
}

/**
 * Convert a string containing dashes to camel case
 * @param   { String } str - input string
 * @returns { String } my-string -> myString
 */
function toCamel(str) {
  return str.replace(/-(\w)/g, function (_, c) { return c.toUpperCase(); })
}

/**
 * Faster String startsWith alternative
 * @param   { String } str - source string
 * @param   { String } value - test string
 * @returns { Boolean } -
 */
function startsWith(str, value) {
  return str.slice(0, value.length) === value
}

/**
 * Helper function to set an immutable property
 * @param   { Object } el - object where the new property will be set
 * @param   { String } key - object key where the new property will be stored
 * @param   { * } value - value of the new property
 * @param   { Object } options - set the propery overriding the default options
 * @returns { Object } - the initial object
 */
function defineProperty(el, key, value, options) {
  Object.defineProperty(el, key, extend({
    value: value,
    enumerable: false,
    writable: false,
    configurable: true
  }, options));
  return el
}

/**
 * Extend any object with other properties
 * @param   { Object } src - source object
 * @returns { Object } the resulting extended object
 *
 * var obj = { foo: 'baz' }
 * extend(obj, {bar: 'bar', foo: 'bar'})
 * console.log(obj) => {bar: 'bar', foo: 'bar'}
 *
 */
function extend(src) {
  var obj, args = arguments;
  for (var i = 1; i < args.length; ++i) {
    if (obj = args[i]) {
      for (var key in obj) {
        // check if this property of the source object could be overridden
        if (isWritable(src, key))
          { src[key] = obj[key]; }
      }
    }
  }
  return src
}

var misc = Object.freeze({
	each: each,
	contains: contains,
	toCamel: toCamel,
	startsWith: startsWith,
	defineProperty: defineProperty,
	extend: extend
});

var observable = function(el) {

  /**
   * Extend the original object or create a new empty one
   * @type { Object }
   */

  el = el || {};

  /**
   * Private variables
   */
  var callbacks = {},
    slice = Array.prototype.slice;

  /**
   * Public Api
   */

  // extend the el object adding the observable methods
  Object.defineProperties(el, {
    /**
     * Listen to the given `event` ands
     * execute the `callback` each time an event is triggered.
     * @param  { String } event - event id
     * @param  { Function } fn - callback function
     * @returns { Object } el
     */
    on: {
      value: function(event, fn) {
        if (typeof fn == 'function')
          { (callbacks[event] = callbacks[event] || []).push(fn); }
        return el
      },
      enumerable: false,
      writable: false,
      configurable: false
    },

    /**
     * Removes the given `event` listeners
     * @param   { String } event - event id
     * @param   { Function } fn - callback function
     * @returns { Object } el
     */
    off: {
      value: function(event, fn) {
        if (event == '*' && !fn) { callbacks = {}; }
        else {
          if (fn) {
            var arr = callbacks[event];
            for (var i = 0, cb; cb = arr && arr[i]; ++i) {
              if (cb == fn) { arr.splice(i--, 1); }
            }
          } else { delete callbacks[event]; }
        }
        return el
      },
      enumerable: false,
      writable: false,
      configurable: false
    },

    /**
     * Listen to the given `event` and
     * execute the `callback` at most once
     * @param   { String } event - event id
     * @param   { Function } fn - callback function
     * @returns { Object } el
     */
    one: {
      value: function(event, fn) {
        function on() {
          el.off(event, on);
          fn.apply(el, arguments);
        }
        return el.on(event, on)
      },
      enumerable: false,
      writable: false,
      configurable: false
    },

    /**
     * Execute all callback functions that listen to
     * the given `event`
     * @param   { String } event - event id
     * @returns { Object } el
     */
    trigger: {
      value: function(event) {
        var arguments$1 = arguments;


        // getting the arguments
        var arglen = arguments.length - 1,
          args = new Array(arglen),
          fns,
          fn,
          i;

        for (i = 0; i < arglen; i++) {
          args[i] = arguments$1[i + 1]; // skip first argument
        }

        fns = slice.call(callbacks[event] || [], 0);

        for (i = 0; fn = fns[i]; ++i) {
          fn.apply(el, args);
        }

        if (callbacks['*'] && event != '*')
          { el.trigger.apply(el, ['*', event].concat(args)); }

        return el
      },
      enumerable: false,
      writable: false,
      configurable: false
    }
  });

  return el

};

var EVENTS_PREFIX_REGEX = /^on/;

/**
 * Trigger DOM events
 * @param   { HTMLElement } dom - dom element target of the event
 * @param   { Function } handler - user function
 * @param   { Object } e - event object
 */
function handleEvent(dom, handler, e) {
  var ptag = this._parent,
    item = this._item;

  if (!item)
    { while (ptag && !item) {
      item = ptag._item;
      ptag = ptag._parent;
    } }

  // override the event properties
  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }
  if (isWritable(e, 'target')) { e.target = e.srcElement; }
  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }

  e.item = item;

  handler.call(this, e);

  if (!e.preventUpdate) {
    var p = getImmediateCustomParentTag(this);
    // fixes #2083
    if (p.isMounted) { p.update(); }
  }
}

/**
 * Attach an event to a DOM node
 * @param { String } name - event name
 * @param { Function } handler - event callback
 * @param { Object } dom - dom node
 * @param { Tag } tag - tag instance
 */
function setEventHandler(name, handler, dom, tag) {
  var eventName,
    cb = handleEvent.bind(tag, dom, handler);

  if (!dom.addEventListener) {
    dom[name] = cb;
    return
  }

  // avoid to bind twice the same event
  dom[name] = null;

  // normalize event name
  eventName = name.replace(EVENTS_PREFIX_REGEX, '');

  // cache the callback directly on the DOM node
  if (!dom._riotEvents) { dom._riotEvents = {}; }

  if (dom._riotEvents[name])
    { dom.removeEventListener(eventName, dom._riotEvents[name]); }

  dom._riotEvents[name] = cb;
  dom.addEventListener(eventName, cb, false);
}

/**
 * Update dynamically created data-is tags with changing expressions
 * @param { Object } expr - expression tag and expression info
 * @param { Tag } parent - parent for tag creation
 */
function updateDataIs(expr, parent) {
  var tagName = tmpl(expr.value, parent),
    conf;

  if (expr.tag && expr.tagName === tagName) {
    expr.tag.update();
    return
  }

  // sync _parent to accommodate changing tagnames
  if (expr.tag) {
    var delName = expr.value,
      tags = expr.tag._parent.tags;

    setAttr(expr.tag.root, RIOT_TAG_IS, tagName); // update for css
    arrayishRemove(tags, delName, expr.tag);
  }

  expr.impl = __TAG_IMPL[tagName];
  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};
  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);
  expr.tagName = tagName;
  expr.tag.mount();
  expr.tag.update();

  // parent is the placeholder tag, not the dynamic tag so clean up
  parent.on('unmount', function () {
    var delName = expr.tag.opts.dataIs,
      tags = expr.tag.parent.tags,
      _tags = expr.tag._parent.tags;
    arrayishRemove(tags, delName, expr.tag);
    arrayishRemove(_tags, delName, expr.tag);
    expr.tag.unmount();
  });
}

/**
 * Update on single tag expression
 * @this Tag
 * @param { Object } expr - expression logic
 * @returns { undefined }
 */
function updateExpression(expr) {
  var dom = expr.dom,
    attrName = expr.attr,
    value = tmpl(expr.expr, this),
    isValueAttr = attrName === 'riot-value',
    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',
    parent = dom && (expr.parent || dom.parentNode),
    old;

  if (expr.bool)
    { value = value ? attrName : false; }
  else if (isUndefined(value) || value === null)
    { value = ''; }

  if (expr._riot_id) { // if it's a tag
    if (expr.isMounted) {
      expr.update();

    // if it hasn't been mounted yet, do that now.
    } else {
      expr.mount();

      if (isVirtual) {
        var frag = document.createDocumentFragment();
        makeVirtual.call(expr, frag);
        expr.root.parentElement.replaceChild(frag, expr.root);
      }
    }
    return
  }

  old = expr.value;
  expr.value = value;

  if (expr.update) {
    expr.update();
    return
  }

  if (old === value) { return }
  if (expr.isRtag && value) { return updateDataIs(expr, this) }
  // no change, so nothing more to do
  if (isValueAttr && dom.value === value) { return }

  // textarea and text nodes have no attribute name
  if (!attrName) {
    // about #815 w/o replace: the browser converts the value to a string,
    // the comparison by "==" does too, but not in the server
    value += '';
    // test for parent avoids error with invalid assignment to nodeValue
    if (parent) {
      // cache the parent node because somehow it will become null on IE
      // on the next iteration
      expr.parent = parent;
      if (parent.tagName === 'TEXTAREA') {
        parent.value = value;                    // #1113
        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue
      }                                         // will be available on 'updated'
      else { dom.nodeValue = value; }
    }
    return
  }

  // remove original attribute
  if (!expr.isAttrRemoved || !value) {
    remAttr(dom, attrName);
    expr.isAttrRemoved = true;
  }

  // event handler
  if (isFunction(value)) {
    setEventHandler(attrName, value, dom, this);
  // show / hide
  } else if (/^(show|hide)$/.test(attrName)) {
    if (attrName === 'hide') { value = !value; }
    dom.style.display = value ? '' : 'none';
  // field value
  } else if (isValueAttr) {
    dom.value = value;
  // <img src="{ expr }">
  } else if (startsWith(attrName, RIOT_PREFIX) && attrName !== RIOT_TAG_IS) {
    if (value != null)
      { setAttr(dom, attrName.slice(RIOT_PREFIX.length), value); }
  } else {
    // <select> <option selected={true}> </select>
    if (attrName === 'selected' && parent && /^(SELECT|OPTGROUP)$/.test(parent.tagName) && value != null) {
      parent.value = dom.value;
    } if (expr.bool) {
      dom[attrName] = value;
      if (!value) { return }
    } if (value === 0 || value && typeof value !== T_OBJECT) {
      setAttr(dom, attrName, value);
    }
  }
}

/**
 * Update all the expressions in a Tag instance
 * @this Tag
 * @param { Array } expressions - expression that must be re evaluated
 */
function update$1$1(expressions) {
  each(expressions, updateExpression.bind(this));
}

var IfExpr = {
  init: function init(dom, parentTag, expr) {
    remAttr(dom, 'if');
    this.parentTag = parentTag;
    this.expr = expr;
    this.stub = document.createTextNode('');
    this.pristine = dom;

    var p = dom.parentNode;
    p.insertBefore(this.stub, dom);
    p.removeChild(dom);

    return this
  },
  update: function update$1() {
    var newValue = tmpl(this.expr, this.parentTag);

    if (newValue && !this.current) { // insert
      this.current = this.pristine.cloneNode(true);
      this.stub.parentNode.insertBefore(this.current, this.stub);

      this.expressions = [];
      parseExpressions.apply(this.parentTag, [this.current, this.expressions, true]);
    } else if (!newValue && this.current) { // remove
      unmountAll(this.expressions);
      if (this.current._tag) {
        this.current._tag.unmount();
      } else if (this.current.parentNode)
        { this.current.parentNode.removeChild(this.current); }
      this.current = null;
      this.expressions = [];
    }

    if (newValue) { update$1$1.call(this.parentTag, this.expressions); }
  },
  unmount: function unmount() {
    unmountAll(this.expressions || []);
    delete this.pristine;
    delete this.parentNode;
    delete this.stub;
  }
};

var RefExpr = {
  init: function init(dom, attrName, attrValue, parent) {
    this.dom = dom;
    this.attr = attrName;
    this.rawValue = attrValue;
    this.parent = parent;
    this.hasExp = tmpl.hasExpr(attrValue);
    this.firstRun = true;

    return this
  },
  update: function update() {
    var value = this.rawValue;
    if (this.hasExp)
      { value = tmpl(this.rawValue, this.parent); }

    // if nothing changed, we're done
    if (!this.firstRun && value === this.value) { return }

    var customParent = this.parent && getImmediateCustomParentTag(this.parent);

    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM
    var tagOrDom = this.tag || this.dom;

    // the name changed, so we need to remove it from the old key (if present)
    if (!isBlank(this.value) && customParent)
      { arrayishRemove(customParent.refs, this.value, tagOrDom); }

    if (isBlank(value)) {
      // if the value is blank, we remove it
      remAttr(this.dom, this.attr);
    } else {
      // add it to the refs of parent tag (this behavior was changed >=3.0)
      if (customParent) { arrayishAdd(customParent.refs, value, tagOrDom); }
      // set the actual DOM attr
      setAttr(this.dom, this.attr, value);
    }
    this.value = value;
    this.firstRun = false;
  },
  unmount: function unmount() {
    var tagOrDom = this.tag || this.dom;
    var customParent = this.parent && getImmediateCustomParentTag(this.parent);
    if (!isBlank(this.value) && customParent)
      { arrayishRemove(customParent.refs, this.value, tagOrDom); }
    delete this.dom;
    delete this.parent;
  }
};

/**
 * Convert the item looped into an object used to extend the child tag properties
 * @param   { Object } expr - object containing the keys used to extend the children tags
 * @param   { * } key - value to assign to the new object returned
 * @param   { * } val - value containing the position of the item in the array
 * @param   { Object } base - prototype object for the new item
 * @returns { Object } - new object containing the values of the original item
 *
 * The variables 'key' and 'val' are arbitrary.
 * They depend on the collection type looped (Array, Object)
 * and on the expression used on the each tag
 *
 */
function mkitem(expr, key, val, base) {
  var item = base ? Object.create(base) : {};
  item[expr.key] = key;
  if (expr.pos) { item[expr.pos] = val; }
  return item
}

/**
 * Unmount the redundant tags
 * @param   { Array } items - array containing the current items to loop
 * @param   { Array } tags - array containing all the children tags
 * @param   { String } tagName - key used to identify the type of tag
 * @param   { Object } parent - parent tag to remove the child from
 */
function unmountRedundant(items, tags, tagName, parent) {

  var i = tags.length,
    j = items.length,
    t;

  while (i > j) {
    t = tags[--i];
    tags.splice(i, 1);
    t.unmount();
    arrayishRemove(parent.tags, tagName, t, true);
  }
}

/**
 * Move the nested custom tags in non custom loop tags
 * @this Tag
 * @param   { Number } i - current position of the loop tag
 */
function moveNestedTags(i) {
  var this$1 = this;

  each(Object.keys(this.tags), function (tagName) {
    var tag = this$1.tags[tagName];
    if (isArray(tag))
      { each(tag, function (t) {
        moveChildTag.apply(t, [tagName, i]);
      }); }
    else
      { moveChildTag.apply(tag, [tagName, i]); }
  });
}

/**
 * Move a child tag
 * @this Tag
 * @param   { HTMLElement } root - dom node containing all the loop children
 * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move
 * @param   { Boolean } isVirtual - is it a virtual tag?
 */
function move(root, nextTag, isVirtual) {
  if (isVirtual)
    { moveVirtual.apply(this, [root, nextTag]); }
  else
    { safeInsert(root, this.root, nextTag.root); }
}

/**
 * Insert and mount a child tag
 * @this Tag
 * @param   { HTMLElement } root - dom node containing all the loop children
 * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert
 * @param   { Boolean } isVirtual - is it a virtual tag?
 */
function insert(root, nextTag, isVirtual) {
  if (isVirtual)
    { makeVirtual.apply(this, [root, nextTag]); }
  else
    { safeInsert(root, this.root, nextTag.root); }
}

/**
 * Append a new tag into the DOM
 * @this Tag
 * @param   { HTMLElement } root - dom node containing all the loop children
 * @param   { Boolean } isVirtual - is it a virtual tag?
 */
function append(root, isVirtual) {
  if (isVirtual)
    { makeVirtual.call(this, root); }
  else
    { root.appendChild(this.root); }
}

/**
 * Manage tags having the 'each'
 * @param   { HTMLElement } dom - DOM node we need to loop
 * @param   { Tag } parent - parent tag instance where the dom node is contained
 * @param   { String } expr - string contained in the 'each' attribute
 * @returns { Object } expression object for this each loop
 */
function _each(dom, parent, expr) {

  // remove the each property from the original tag
  remAttr(dom, 'each');

  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),
    tagName = getTagName(dom),
    impl = __TAG_IMPL[tagName] || { tmpl: getOuterHTML(dom) },
    useRoot = RE_SPECIAL_TAGS.test(tagName),
    root = dom.parentNode,
    ref = createDOMPlaceholder(),
    child = getTag(dom),
    ifExpr = getAttr(dom, 'if'),
    tags = [],
    oldItems = [],
    hasKeys,
    isLoop = true,
    isAnonymous = !__TAG_IMPL[tagName],
    isVirtual = dom.tagName === 'VIRTUAL';

  // parse the each expression
  expr = tmpl.loopKeys(expr);
  expr.isLoop = true;

  if (ifExpr) { remAttr(dom, 'if'); }

  // insert a marked where the loop tags will be injected
  root.insertBefore(ref, dom);
  root.removeChild(dom);

  expr.update = function updateEach() {

    // get the new items collection
    var items = tmpl(expr.val, parent),
      parentNode,
      frag,
      placeholder;


    root = ref.parentNode;

    if (parentNode) {
      placeholder = createDOMPlaceholder('');
      parentNode.insertBefore(placeholder, root);
      parentNode.removeChild(root);
    } else {
      frag = createFrag();
    }

    // object loop. any changes cause full redraw
    if (!isArray(items)) {
      hasKeys = items || false;
      items = hasKeys ?
        Object.keys(items).map(function (key) {
          return mkitem(expr, items[key], key)
        }) : [];
    } else {
      hasKeys = false;
    }

    if (ifExpr) {
      items = items.filter(function(item, i) {
        if (expr.key) {
          return !!tmpl(ifExpr, mkitem(expr, item, i, parent))
        }
        // in case it's not a keyed loop
        // we test the validity of the if expression against
        // the item and the parent
        return !!tmpl(ifExpr, parent) || !!tmpl(ifExpr, item)
      });
    }

    // loop all the new items
    each(items, function(item, i) {
      // reorder only if the items are objects
      var
        _mustReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,
        oldPos = oldItems.indexOf(item),
        pos = ~oldPos && _mustReorder ? oldPos : i,
        // does a tag exist in this position?
        tag = tags[pos];

      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;

      // new tag
      if (
        !_mustReorder && !tag // with no-reorder we just update the old tags
        ||
        _mustReorder && !~oldPos // by default we always try to reorder the DOM elements
      ) {

        var mustAppend = i === tags.length;

        tag = new Tag$$1(impl, {
          parent: parent,
          isLoop: isLoop,
          isAnonymous: isAnonymous,
          root: useRoot ? root : dom.cloneNode(),
          item: item
        }, dom.innerHTML);

        // mount the tag
        tag.mount();

        if (mustAppend)
          { append.apply(tag, [frag || root, isVirtual]); }
        else
          { insert.apply(tag, [root, tags[i], isVirtual]); }

        if (!mustAppend) { oldItems.splice(i, 0, item); }
        tags.splice(i, 0, tag);
        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }
        pos = i; // handled here so no move
      } else { tag.update(item); }

      // reorder the tag if it's not located in its previous position
      if (pos !== i && _mustReorder) {
        // #closes 2040
        if (contains(items, oldItems[i])) {
          move.apply(tag, [root, tags[i], isVirtual]);
        }
        // update the position attribute if it exists
        if (expr.pos) { tag[expr.pos] = i; }
        // move the old tag instance
        tags.splice(i, 0, tags.splice(pos, 1)[0]);
        // move the old item
        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);
        // if the loop tags are not custom
        // we need to move all their custom tags into the right position
        if (!child && tag.tags) { moveNestedTags.call(tag, i); }
      }

      // cache the original item to use it in the events bound to this node
      // and its children
      tag._item = item;
      // cache the real parent tag internally
      defineProperty(tag, '_parent', parent);
    });

    // remove the redundant tags
    unmountRedundant(items, tags, tagName, parent);

    // clone the items array
    oldItems = items.slice();

    if (frag) {
      root.insertBefore(frag, ref);
    } else {
      parentNode.insertBefore(root, placeholder);
      parentNode.removeChild(placeholder);
    }

  };

  expr.unmount = function() {
    each(tags, function(t) { t.unmount(); });
  };

  return expr
}

/**
 * Walk the tag DOM to detect the expressions to evaluate
 * @this Tag
 * @param   { HTMLElement } root - root tag where we will start digging the expressions
 * @param   { Array } expressions - empty array where the expressions will be added
 * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well
 * @returns { Object } an object containing the root noode and the dom tree
 */
function parseExpressions(root, expressions, mustIncludeRoot) {
  var this$1 = this;

  var tree = {parent: {children: expressions}};

  walkNodes(root, function (dom, ctx) {
    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;
    if (!mustIncludeRoot && dom === root) { return {parent: parent} }

    // text node
    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))
      { parent.children.push({dom: dom, expr: dom.nodeValue}); }

    if (type !== 1) { return ctx } // not an element

    // loop. each does it's own thing (for now)
    if (attr = getAttr(dom, 'each')) {
      parent.children.push(_each(dom, this$1, attr));
      return false
    }

    // if-attrs become the new parent. Any following expressions (either on the current
    // element, or below it) become children of this expression.
    if (attr = getAttr(dom, 'if')) {
      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));
      return false
    }

    if (expr = getAttr(dom, RIOT_TAG_IS)) {
      if (tmpl.hasExpr(expr)) {
        parent.children.push({isRtag: true, expr: expr, dom: dom});
        return false
      }
    }

    // if this is a tag, stop traversing here.
    // we ignore the root, since parseExpressions is called while we're mounting that root
    tagImpl = getTag(dom);
    if (tagImpl && (dom !== root || mustIncludeRoot)) {
      var conf = {root: dom, parent: this$1, hasImpl: true};
      parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));
      return false
    }

    // attribute expressions
    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {
      if (!expr) { return }
      parent.children.push(expr);
    }]);

    // whatever the parent is, all child elements get the same parent.
    // If this element had an if-attr, that's the parent for all child elements
    return {parent: parent}
  }, tree);

  return { tree: tree, root: root }
}

/**
 * Calls `fn` for every attribute on an element. If that attr has an expression,
 * it is also passed to fn.
 * @this Tag
 * @param   { HTMLElement } dom - dom node to parse
 * @param   { Array } attrs - array of attributes
 * @param   { Function } fn - callback to exec on any iteration
 */
function parseAttributes(dom, attrs, fn) {
  var this$1 = this;

  each(attrs, function (attr) {
    var name = attr.name, bool = isBoolAttr(name), expr;

    if (~['ref', 'data-ref'].indexOf(name)) {
      expr =  Object.create(RefExpr).init(dom, name, attr.value, this$1);
    } else if (tmpl.hasExpr(attr.value)) {
      expr = {dom: dom, expr: attr.value, attr: attr.name, bool: bool};
    }

    fn(attr, expr);
  });
}

/*
  Includes hacks needed for the Internet Explorer version 9 and below
  See: http://kangax.github.io/compat-table/es5/#ie8
       http://codeplanet.io/dropping-ie8/
*/

var reHasYield  = /<yield\b/i;
var reYieldAll  = /<yield\s*(?:\/>|>([\S\s]*?)<\/yield\s*>|>)/ig;
var reYieldSrc  = /<yield\s+to=['"]([^'">]*)['"]\s*>([\S\s]*?)<\/yield\s*>/ig;
var reYieldDest = /<yield\s+from=['"]?([-\w]+)['"]?\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/ig;
var rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };
var tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;
var GENERIC = 'div';


/*
  Creates the root element for table or select child elements:
  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup
*/
function specialTags(el, tmpl, tagName) {

  var
    select = tagName[0] === 'o',
    parent = select ? 'select>' : 'table>';

  // trim() is important here, this ensures we don't have artifacts,
  // so we can check if we have only one element inside the parent
  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;
  parent = el.firstChild;

  // returns the immediate parent if tr/th/td/col is the only element, if not
  // returns the whole tree, as this can include additional elements
  if (select) {
    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior
  } else {
    // avoids insertion of cointainer inside container (ex: tbody inside tbody)
    var tname = rootEls[tagName];
    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }
  }
  return parent
}

/*
  Replace the yield tag from any tag template with the innerHTML of the
  original tag in the page
*/
function replaceYield(tmpl, html) {
  // do nothing if no yield
  if (!reHasYield.test(tmpl)) { return tmpl }

  // be careful with #1343 - string on the source having `$1`
  var src = {};

  html = html && html.replace(reYieldSrc, function (_, ref, text) {
    src[ref] = src[ref] || text;   // preserve first definition
    return ''
  }).trim();

  return tmpl
    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs
      return src[ref] || def || ''
    })
    .replace(reYieldAll, function (_, def) {        // yield without any "from"
      return html || def || ''
    })
}

/**
 * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be
 * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.
 *
 * @param   { String } tmpl  - The template coming from the custom tag definition
 * @param   { String } html - HTML content that comes from the DOM element where you
 *           will mount the tag, mostly the original tag in the page
 * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes
 * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.
 */
function mkdom(tmpl, html, checkSvg) {
  var match   = tmpl && tmpl.match(/^\s*<([-\w]+)/),
    tagName = match && match[1].toLowerCase(),
    el = mkEl(GENERIC, checkSvg && isSVGTag(tagName));

  // replace all the yield tags with the tag inner html
  tmpl = replaceYield(tmpl, html);

  /* istanbul ignore next */
  if (tblTags.test(tagName))
    { el = specialTags(el, tmpl, tagName); }
  else
    { setInnerHTML(el, tmpl); }

  el.stub = true;

  return el
}

/**
 * Another way to create a riot tag a bit more es6 friendly
 * @param { HTMLElement } el - tag DOM selector or DOM node/s
 * @param { Object } opts - tag logic
 * @returns { Tag } new riot tag instance
 */
function Tag$1(el, opts) {
  // get the tag properties from the class constructor
  var ref = this;
  var name = ref.name;
  var tmpl = ref.tmpl;
  var css = ref.css;
  var attrs = ref.attrs;
  var onCreate = ref.onCreate;
  // register a new tag and cache the class prototype
  if (!__TAG_IMPL[name]) {
    tag$$1(name, tmpl, css, attrs, onCreate);
    // cache the class constructor
    __TAG_IMPL[name].class = this.constructor;
  }

  // mount the tag using the class instance
  mountTo(el, name, opts, this);
  // inject the component css
  if (css) { styleManager.inject(); }

  return this
}

/**
 * Create a new riot tag implementation
 * @param   { String }   name - name/id of the new riot tag
 * @param   { String }   tmpl - tag template
 * @param   { String }   css - custom tag css
 * @param   { String }   attrs - root tag attributes
 * @param   { Function } fn - user function
 * @returns { String } name/id of the tag just created
 */
function tag$$1(name, tmpl, css, attrs, fn) {
  if (isFunction(attrs)) {
    fn = attrs;

    if (/^[\w\-]+\s?=/.test(css)) {
      attrs = css;
      css = '';
    } else
      { attrs = ''; }
  }

  if (css) {
    if (isFunction(css))
      { fn = css; }
    else
      { styleManager.add(css); }
  }

  name = name.toLowerCase();
  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };

  return name
}

/**
 * Create a new riot tag implementation (for use by the compiler)
 * @param   { String }   name - name/id of the new riot tag
 * @param   { String }   tmpl - tag template
 * @param   { String }   css - custom tag css
 * @param   { String }   attrs - root tag attributes
 * @param   { Function } fn - user function
 * @returns { String } name/id of the tag just created
 */
function tag2$$1(name, tmpl, css, attrs, fn) {
  if (css)
    { styleManager.add(css, name); }

  var exists = !!__TAG_IMPL[name];
  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };

  if (exists && util.hotReloader)
    { util.hotReloader(name); }

  return name
}

/**
 * Mount a tag using a specific tag implementation
 * @param   { * } selector - tag DOM selector or DOM node/s
 * @param   { String } tagName - tag implementation name
 * @param   { Object } opts - tag logic
 * @returns { Array } new tags instances
 */
function mount$$1(selector, tagName, opts) {
  var tags = [];

  function pushTagsTo(root) {
    if (root.tagName) {
      var riotTag = getAttr(root, RIOT_TAG_IS);

      // have tagName? force riot-tag to be the same
      if (tagName && riotTag !== tagName) {
        riotTag = tagName;
        setAttr(root, RIOT_TAG_IS, tagName);
      }

      var tag$$1 = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);

      if (tag$$1)
        { tags.push(tag$$1); }
    } else if (root.length)
      { each(root, pushTagsTo); } // assume nodeList
  }

  // inject styles into DOM
  styleManager.inject();

  if (isObject(tagName)) {
    opts = tagName;
    tagName = 0;
  }

  var elem;
  var allTags;

  // crawl the DOM to find the tag
  if (isString(selector)) {
    selector = selector === '*' ?
      // select all registered tags
      // & tags found with the riot-tag attribute set
      allTags = selectTags() :
      // or just the ones named like the selector
      selector + selectTags(selector.split(/, */));

    // make sure to pass always a selector
    // to the querySelectorAll function
    elem = selector ? $$(selector) : [];
  }
  else
    // probably you have passed already a tag or a NodeList
    { elem = selector; }

  // select all the registered and mount them inside their root elements
  if (tagName === '*') {
    // get all custom tags
    tagName = allTags || selectTags();
    // if the root els it's just a single tag
    if (elem.tagName)
      { elem = $$(tagName, elem); }
    else {
      // select all the children for all the different root elements
      var nodeList = [];

      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });

      elem = nodeList;
    }
    // get rid of the tagName
    tagName = 0;
  }

  pushTagsTo(elem);

  return tags
}

// Create a mixin that could be globally shared across all the tags
var mixins = {};
var globals = mixins[GLOBAL_MIXIN] = {};
var _id = 0;

/**
 * Create/Return a mixin by its name
 * @param   { String }  name - mixin name (global mixin if object)
 * @param   { Object }  mix - mixin logic
 * @param   { Boolean } g - is global?
 * @returns { Object }  the mixin logic
 */
function mixin$$1(name, mix, g) {
  // Unnamed global
  if (isObject(name)) {
    mixin$$1(("__unnamed_" + (_id++)), name, true);
    return
  }

  var store = g ? globals : mixins;

  // Getter
  if (!mix) {
    if (isUndefined(store[name]))
      { throw new Error('Unregistered mixin: ' + name) }

    return store[name]
  }

  // Setter
  store[name] = isFunction(mix) ?
    extend(mix.prototype, store[name] || {}) && mix :
    extend(store[name] || {}, mix);
}

/**
 * Update all the tags instances created
 * @returns { Array } all the tags instances
 */
function update$2() {
  return each(__TAGS_CACHE, function (tag$$1) { return tag$$1.update(); })
}

function unregister$$1(name) {
  delete __TAG_IMPL[name];
}

// counter to give a unique id to all the Tag instances
var __uid = 0;

/**
 * We need to update opts for this tag. That requires updating the expressions
 * in any attributes on the tag, and then copying the result onto opts.
 * @this Tag
 * @param   {Boolean} isLoop - is it a loop tag?
 * @param   { Tag }  parent - parent tag node
 * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)
 * @param   { Object }  opts - tag options
 * @param   { Array }  instAttrs - tag attributes array
 */
function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {
  // isAnonymous `each` tags treat `dom` and `root` differently. In this case
  // (and only this case) we don't need to do updateOpts, because the regular parse
  // will update those attrs. Plus, isAnonymous tags don't need opts anyway
  if (isLoop && isAnonymous) { return }

  var ctx = !isAnonymous && isLoop ? this : parent || this;
  each(instAttrs, function (attr) {
    if (attr.expr) { update$1$1.call(ctx, [attr.expr]); }
    opts[toCamel(attr.name)] = attr.expr ? attr.expr.value : attr.value;
  });
}


/**
 * Tag class
 * @constructor
 * @param { Object } impl - it contains the tag template, and logic
 * @param { Object } conf - tag options
 * @param { String } innerHTML - html that eventually we need to inject in the tag
 */
function Tag$$1(impl, conf, innerHTML) {

  var opts = extend({}, conf.opts),
    parent = conf.parent,
    isLoop = conf.isLoop,
    isAnonymous = conf.isAnonymous,
    item = cleanUpData(conf.item),
    instAttrs = [], // All attributes on the Tag when it's first parsed
    implAttrs = [], // expressions on this type of Tag
    expressions = [],
    root = conf.root,
    tagName = conf.tagName || getTagName(root),
    isVirtual = tagName === 'virtual',
    propsInSyncWithParent = [],
    dom;

  // make this tag observable
  observable(this);
  // only call unmount if we have a valid __TAG_IMPL (has name property)
  if (impl.name && root._tag) { root._tag.unmount(true); }

  // not yet mounted
  this.isMounted = false;
  root.isLoop = isLoop;

  defineProperty(this, '_internal', {
    isAnonymous: isAnonymous,
    instAttrs: instAttrs,
    innerHTML: innerHTML,
    // these vars will be needed only for the virtual tags
    virts: [],
    tail: null,
    head: null
  });

  // create a unique id to this tag
  // it could be handy to use it also to improve the virtual dom rendering speed
  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id

  extend(this, { parent: parent, root: root, opts: opts }, item);
  // protect the "tags" and "refs" property from being overridden
  defineProperty(this, 'tags', {});
  defineProperty(this, 'refs', {});

  dom = mkdom(impl.tmpl, innerHTML, isLoop);

  /**
   * Update the tag expressions and options
   * @param   { * }  data - data we want to use to extend the tag properties
   * @returns { Tag } the current tag instance
   */
  defineProperty(this, 'update', function tagUpdate(data) {
    if (isFunction(this.shouldUpdate) && !this.shouldUpdate(data)) { return this }

    // make sure the data passed will not override
    // the component core methods
    data = cleanUpData(data);

    // inherit properties from the parent, but only for isAnonymous tags
    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }
    extend(this, data);
    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);
    if (this.isMounted) { this.trigger('update', data); }
    update$1$1.call(this, expressions);
    if (this.isMounted) { this.trigger('updated'); }

    return this

  }.bind(this));

  /**
   * Add a mixin to this tag
   * @returns { Tag } the current tag instance
   */
  defineProperty(this, 'mixin', function tagMixin() {
    var this$1 = this;

    each(arguments, function (mix) {
      var instance,
        props = [],
        obj;

      mix = isString(mix) ? mixin$$1(mix) : mix;

      // check if the mixin is a function
      if (isFunction(mix)) {
        // create the new mixin instance
        instance = new mix();
      } else { instance = mix; }

      var proto = Object.getPrototypeOf(instance);

      // build multilevel prototype inheritance chain property list
      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }
      while (obj = Object.getPrototypeOf(obj || instance))

      // loop the keys in the function prototype or the all object keys
      each(props, function (key) {
        // bind methods to this
        // allow mixins to override other properties/parent mixins
        if (key !== 'init') {
          // check for getters/setters
          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);
          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);

          // apply method only if it does not already exist on the instance
          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {
            Object.defineProperty(this$1, key, descriptor);
          } else {
            this$1[key] = isFunction(instance[key]) ?
              instance[key].bind(this$1) :
              instance[key];
          }
        }
      });

      // init method will be called automatically
      if (instance.init)
        { instance.init.bind(this$1)(); }
    });
    return this
  }.bind(this));

  /**
   * Mount the current tag instance
   * @returns { Tag } the current tag instance
   */
  defineProperty(this, 'mount', function tagMount() {
    var this$1 = this;

    root._tag = this; // keep a reference to the tag just created

    // Read all the attrs on this instance. This give us the info we need for updateOpts
    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {
      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }
      attr.expr = expr;
      instAttrs.push(attr);
    }]);

    // update the root adding custom attributes coming from the compiler
    implAttrs = [];
    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });
    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {
      if (expr) { expressions.push(expr); }
      else { setAttr(root, attr.name, attr.value); }
    }]);

    // children in loop should inherit from true parent
    if (this._parent && isAnonymous) { inheritFrom.apply(this, [this._parent, propsInSyncWithParent]); }

    // initialiation
    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);

    // add global mixins
    var globalMixin = mixin$$1(GLOBAL_MIXIN);

    if (globalMixin) {
      for (var i in globalMixin) {
        if (globalMixin.hasOwnProperty(i)) {
          this$1.mixin(globalMixin[i]);
        }
      }
    }

    if (impl.fn) { impl.fn.call(this, opts); }

    this.trigger('before-mount');

    // parse layout after init. fn may calculate args for nested custom tags
    parseExpressions.apply(this, [dom, expressions, false]);

    this.update(item);

    if (isLoop && isAnonymous) {
      // update the root attribute for the looped elements
      this.root = root = dom.firstChild;
    } else {
      while (dom.firstChild) { root.appendChild(dom.firstChild); }
      if (root.stub) { root = parent.root; }
    }

    defineProperty(this, 'root', root);
    this.isMounted = true;

    // if it's not a child tag we can trigger its mount event
    if (!this.parent || this.parent.isMounted) {
      this.trigger('mount');
    }
    // otherwise we need to wait that the parent event gets triggered
    else { this.parent.one('mount', function () {
      this$1.trigger('mount');
    }); }

    return this

  }.bind(this));

  /**
   * Unmount the tag instance
   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed
   * @returns { Tag } the current tag instance
   */
  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {
    var this$1 = this;

    var el = this.root,
      p = el.parentNode,
      ptag,
      tagIndex = __TAGS_CACHE.indexOf(this);

    this.trigger('before-unmount');

    // remove this tag instance from the global virtualDom variable
    if (~tagIndex)
      { __TAGS_CACHE.splice(tagIndex, 1); }

    if (p) {
      if (parent) {
        ptag = getImmediateCustomParentTag(parent);

        if (isVirtual) {
          Object.keys(this.tags).forEach(function (tagName) {
            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);
          });
        } else {
          arrayishRemove(ptag.tags, tagName, this);
        }
      } else {
        while (el.firstChild) { el.removeChild(el.firstChild); }
      }

      if (!mustKeepRoot) {
        p.removeChild(el);
      } else {
        // the riot-tag and the data-is attributes aren't needed anymore, remove them
        remAttr(p, RIOT_TAG_IS);
      }
    }

    if (this._internal.virts) {
      each(this._internal.virts, function (v) {
        if (v.parentNode) { v.parentNode.removeChild(v); }
      });
    }

    // allow expressions to unmount themselves
    unmountAll(expressions);
    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });

    this.trigger('unmount');
    this.off('*');
    this.isMounted = false;

    delete this.root._tag;

    return this

  }.bind(this));
}

/**
 * Detect the tag implementation by a DOM node
 * @param   { Object } dom - DOM node we need to parse to get its tag implementation
 * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)
 */
function getTag(dom) {
  return dom.tagName && __TAG_IMPL[getAttr(dom, RIOT_TAG_IS) ||
    getAttr(dom, RIOT_TAG_IS) || dom.tagName.toLowerCase()]
}

/**
 * Inherit properties from a target tag instance
 * @this Tag
 * @param   { Tag } target - tag where we will inherit properties
 * @param   { Array } propsInSyncWithParent - array of properties to sync with the target
 */
function inheritFrom(target, propsInSyncWithParent) {
  var this$1 = this;

  each(Object.keys(target), function (k) {
    // some properties must be always in sync with the parent tag
    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);

    if (isUndefined(this$1[k]) || mustSync) {
      // track the property to keep in sync
      // so we can keep it updated
      if (!mustSync) { propsInSyncWithParent.push(k); }
      this$1[k] = target[k];
    }
  });
}

/**
 * Move the position of a custom tag in its parent tag
 * @this Tag
 * @param   { String } tagName - key where the tag was stored
 * @param   { Number } newPos - index where the new tag will be stored
 */
function moveChildTag(tagName, newPos) {
  var parent = this.parent,
    tags;
  // no parent no move
  if (!parent) { return }

  tags = parent.tags[tagName];

  if (isArray(tags))
    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }
  else { arrayishAdd(parent.tags, tagName, this); }
}

/**
 * Create a new child tag including it correctly into its parent
 * @param   { Object } child - child tag implementation
 * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted
 * @param   { String } innerHTML - inner html of the child node
 * @param   { Object } parent - instance of the parent tag including the child custom tag
 * @returns { Object } instance of the new child tag just created
 */
function initChildTag(child, opts, innerHTML, parent) {
  var tag = new Tag$$1(child, opts, innerHTML),
    tagName = opts.tagName || getTagName(opts.root, true),
    ptag = getImmediateCustomParentTag(parent);
  // fix for the parent attribute in the looped elements
  tag.parent = ptag;
  // store the real parent tag
  // in some cases this could be different from the custom parent tag
  // for example in nested loops
  tag._parent = parent;

  // add this tag to the custom parent tag
  arrayishAdd(ptag.tags, tagName, tag);

  // and also to the real parent tag
  if (ptag !== parent)
    { arrayishAdd(parent.tags, tagName, tag); }

  // empty the child node once we got its template
  // to avoid that its children get compiled multiple times
  opts.root.innerHTML = '';

  return tag
}

/**
 * Loop backward all the parents tree to detect the first custom parent tag
 * @param   { Object } tag - a Tag instance
 * @returns { Object } the instance of the first custom parent tag found
 */
function getImmediateCustomParentTag(tag) {
  var ptag = tag;
  while (ptag._internal.isAnonymous) {
    if (!ptag.parent) { break }
    ptag = ptag.parent;
  }
  return ptag
}

/**
 * Trigger the unmount method on all the expressions
 * @param   { Array } expressions - DOM expressions
 */
function unmountAll(expressions) {
  each(expressions, function(expr) {
    if (expr instanceof Tag$$1) { expr.unmount(true); }
    else if (expr.unmount) { expr.unmount(); }
  });
}

/**
 * Get the tag name of any DOM node
 * @param   { Object } dom - DOM node we want to parse
 * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent
 * @returns { String } name to identify this dom node in riot
 */
function getTagName(dom, skipDataIs) {
  var child = getTag(dom),
    namedTag = !skipDataIs && getAttr(dom, RIOT_TAG_IS);
  return namedTag && !tmpl.hasExpr(namedTag) ?
                namedTag :
              child ? child.name : dom.tagName.toLowerCase()
}

/**
 * With this function we avoid that the internal Tag methods get overridden
 * @param   { Object } data - options we want to use to extend the tag instance
 * @returns { Object } clean object without containing the riot internal reserved words
 */
function cleanUpData(data) {
  if (!(data instanceof Tag$$1) && !(data && typeof data.trigger === T_FUNCTION))
    { return data }

  var o = {};
  for (var key in data) {
    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }
  }
  return o
}

/**
 * Set the property of an object for a given key. If something already
 * exists there, then it becomes an array containing both the old and new value.
 * @param { Object } obj - object on which to set the property
 * @param { String } key - property name
 * @param { Object } value - the value of the property to be set
 * @param { Boolean } ensureArray - ensure that the property remains an array
 */
function arrayishAdd(obj, key, value, ensureArray) {
  var dest = obj[key];
  var isArr = isArray(dest);

  if (dest && dest === value) { return }

  // if the key was never set, set it once
  if (!dest && ensureArray) { obj[key] = [value]; }
  else if (!dest) { obj[key] = value; }
  // if it was an array and not yet set
  else if (!isArr || isArr && !contains(dest, value)) {
    if (isArr) { dest.push(value); }
    else { obj[key] = [dest, value]; }
  }
}

/**
 * Removes an item from an object at a given key. If the key points to an array,
 * then the item is just removed from the array.
 * @param { Object } obj - object on which to remove the property
 * @param { String } key - property name
 * @param { Object } value - the value of the property to be removed
 * @param { Boolean } ensureArray - ensure that the property remains an array
*/
function arrayishRemove(obj, key, value, ensureArray) {
  if (isArray(obj[key])) {
    each(obj[key], function(item, i) {
      if (item === value) { obj[key].splice(i, 1); }
    });
    if (!obj[key].length) { delete obj[key]; }
    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }
  } else
    { delete obj[key]; } // otherwise just delete the key
}

/**
 * Check whether a DOM node is in stub mode, useful for the riot 'if' directive
 * @param   { Object }  dom - DOM node we want to parse
 * @returns { Boolean } -
 */
function isInStub(dom) {
  while (dom) {
    if (dom.inStub)
      { return true }
    dom = dom.parentNode;
  }
  return false
}

/**
 * Mount a tag creating new Tag instance
 * @param   { Object } root - dom node where the tag will be mounted
 * @param   { String } tagName - name of the riot tag we want to mount
 * @param   { Object } opts - options to pass to the Tag instance
 * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )
 * @returns { Tag } a new Tag instance
 */
function mountTo(root, tagName, opts, ctx) {
  var impl = __TAG_IMPL[tagName],
    implClass = __TAG_IMPL[tagName].class,
    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),
    // cache the inner HTML to fix #855
    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;

  // clear the inner html
  root.innerHTML = '';

  var conf = { root: root, opts: opts };
  if (opts && opts.parent) { conf.parent = opts.parent; }

  if (impl && root) { Tag$$1.apply(tag, [impl, conf, innerHTML]); }

  if (tag && tag.mount) {
    tag.mount(true);
    // add this tag to the virtualDom variable
    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }
  }

  return tag
}


/**
 * Adds the elements for a virtual tag
 * @this Tag
 * @param { Node } src - the node that will do the inserting or appending
 * @param { Tag } target - only if inserting, insert before this tag's first child
 */
function makeVirtual(src, target) {
  var this$1 = this;

  var head = createDOMPlaceholder(),
    tail = createDOMPlaceholder(),
    frag = createFrag(),
    sib, el;

  this._internal.head = this.root.insertBefore(head, this.root.firstChild);
  this._internal.tail = this.root.appendChild(tail);

  el = this._internal.head;

  while (el) {
    sib = el.nextSibling;
    frag.appendChild(el);
    this$1._internal.virts.push(el); // hold for unmounting
    el = sib;
  }

  if (target)
    { src.insertBefore(frag, target._internal.head); }
  else
    { src.appendChild(frag); }
}

/**
 * Move virtual tag and all child nodes
 * @this Tag
 * @param { Node } src  - the node that will do the inserting
 * @param { Tag } target - insert before this tag's first child
 */
function moveVirtual(src, target) {
  var this$1 = this;

  var el = this._internal.head,
    frag = createFrag(),
    sib;

  while (el) {
    sib = el.nextSibling;
    frag.appendChild(el);
    el = sib;
    if (el === this$1._internal.tail) {
      frag.appendChild(el);
      src.insertBefore(frag, target._internal.head);
      break
    }
  }
}

/**
 * Get selectors for tags
 * @param   { Array } tags - tag names to select
 * @returns { String } selector
 */
function selectTags(tags) {
  // select all tags
  if (!tags) {
    var keys = Object.keys(__TAG_IMPL);
    return keys + selectTags(keys)
  }

  return tags
    .filter(function (t) { return !/[^-\w]/.test(t); })
    .reduce(function (list, t) {
      var name = t.trim().toLowerCase();
      return list + ",[" + RIOT_TAG_IS + "=\"" + name + "\"]"
    }, '')
}


var tags = Object.freeze({
	getTag: getTag,
	inheritFrom: inheritFrom,
	moveChildTag: moveChildTag,
	initChildTag: initChildTag,
	getImmediateCustomParentTag: getImmediateCustomParentTag,
	unmountAll: unmountAll,
	getTagName: getTagName,
	cleanUpData: cleanUpData,
	arrayishAdd: arrayishAdd,
	arrayishRemove: arrayishRemove,
	isInStub: isInStub,
	mountTo: mountTo,
	makeVirtual: makeVirtual,
	moveVirtual: moveVirtual,
	selectTags: selectTags
});

/**
 * Riot public api
 */

var settings = Object.create(brackets.settings);
var util = {
  tmpl: tmpl,
  brackets: brackets,
  styleManager: styleManager,
  vdom: __TAGS_CACHE,
  styleNode: styleManager.styleNode,
  // export the riot internal utils as well
  dom: dom,
  check: check,
  misc: misc,
  tags: tags
};

exports.settings = settings;
exports.util = util;
exports.observable = observable;
exports.Tag = Tag$1;
exports.tag = tag$$1;
exports.tag2 = tag2$$1;
exports.mount = mount$$1;
exports.mixin = mixin$$1;
exports.update = update$2;
exports.unregister = unregister$$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));
</script>
<script>(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.most = global.most || {})));
}(this, (function (exports) { 'use strict';

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function Stream (source) {
  this.source = source;
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */

// Non-mutating array operations

// cons :: a -> [a] -> [a]
// a with x prepended
function cons (x, a) {
  var l = a.length;
  var b = new Array(l + 1);
  b[0] = x;
  for (var i = 0; i < l; ++i) {
    b[i + 1] = a[i];
  }
  return b
}

// append :: a -> [a] -> [a]
// a with x appended
function append (x, a) {
  var l = a.length;
  var b = new Array(l + 1);
  for (var i = 0; i < l; ++i) {
    b[i] = a[i];
  }

  b[l] = x;
  return b
}

// drop :: Int -> [a] -> [a]
// drop first n elements
function drop (n, a) { // eslint-disable-line complexity
  if (n < 0) {
    throw new TypeError('n must be >= 0')
  }

  var l = a.length;
  if (n === 0 || l === 0) {
    return a
  }

  if (n >= l) {
    return []
  }

  return unsafeDrop(n, a, l - n)
}

// unsafeDrop :: Int -> [a] -> Int -> [a]
// Internal helper for drop
function unsafeDrop (n, a, l) {
  var b = new Array(l);
  for (var i = 0; i < l; ++i) {
    b[i] = a[n + i];
  }
  return b
}

// tail :: [a] -> [a]
// drop head element
function tail (a) {
  return drop(1, a)
}

// copy :: [a] -> [a]
// duplicate a (shallow duplication)
function copy (a) {
  var l = a.length;
  var b = new Array(l);
  for (var i = 0; i < l; ++i) {
    b[i] = a[i];
  }
  return b
}

// map :: (a -> b) -> [a] -> [b]
// transform each element with f
function map (f, a) {
  var l = a.length;
  var b = new Array(l);
  for (var i = 0; i < l; ++i) {
    b[i] = f(a[i]);
  }
  return b
}

// reduce :: (a -> b -> a) -> a -> [b] -> a
// accumulate via left-fold
function reduce (f, z, a) {
  var r = z;
  for (var i = 0, l = a.length; i < l; ++i) {
    r = f(r, a[i], i);
  }
  return r
}

// replace :: a -> Int -> [a]
// replace element at index
function replace (x, i, a) { // eslint-disable-line complexity
  if (i < 0) {
    throw new TypeError('i must be >= 0')
  }

  var l = a.length;
  var b = new Array(l);
  for (var j = 0; j < l; ++j) {
    b[j] = i === j ? x : a[j];
  }
  return b
}

// remove :: Int -> [a] -> [a]
// remove element at index
function remove (i, a) {  // eslint-disable-line complexity
  if (i < 0) {
    throw new TypeError('i must be >= 0')
  }

  var l = a.length;
  if (l === 0 || i >= l) { // exit early if index beyond end of array
    return a
  }

  if (l === 1) { // exit early if index in bounds and length === 1
    return []
  }

  return unsafeRemove(i, a, l - 1)
}

// unsafeRemove :: Int -> [a] -> Int -> [a]
// Internal helper to remove element at index
function unsafeRemove (i, a, l) {
  var b = new Array(l);
  var j;
  for (j = 0; j < i; ++j) {
    b[j] = a[j];
  }
  for (j = i; j < l; ++j) {
    b[j] = a[j + 1];
  }

  return b
}

// removeAll :: (a -> boolean) -> [a] -> [a]
// remove all elements matching a predicate
function removeAll (f, a) {
  var l = a.length;
  var b = new Array(l);
  var j = 0;
  for (var x, i = 0; i < l; ++i) {
    x = a[i];
    if (!f(x)) {
      b[j] = x;
      ++j;
    }
  }

  b.length = j;
  return b
}

// findIndex :: a -> [a] -> Int
// find index of x in a, from the left
function findIndex (x, a) {
  for (var i = 0, l = a.length; i < l; ++i) {
    if (x === a[i]) {
      return i
    }
  }
  return -1
}

// isArrayLike :: * -> boolean
// Return true iff x is array-like
function isArrayLike (x) {
  return x != null && typeof x.length === 'number' && typeof x !== 'function'
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */

// id :: a -> a
var id = function (x) { return x; };

// compose :: (b -> c) -> (a -> b) -> (a -> c)
var compose = function (f, g) { return function (x) { return f(g(x)); }; };

// apply :: (a -> b) -> a -> b
var apply = function (f, x) { return f(x); };

// curry2 :: ((a, b) -> c) -> (a -> b -> c)
function curry2 (f) {
  function curried (a, b) {
    switch (arguments.length) {
      case 0: return curried
      case 1: return function (b) { return f(a, b); }
      default: return f(a, b)
    }
  }
  return curried
}

// curry3 :: ((a, b, c) -> d) -> (a -> b -> c -> d)

/** @license MIT License (c) copyright 2016 original author or authors */

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Create a new Disposable which will dispose its underlying resource.
 * @param {function} dispose function
 * @param {*?} data any data to be passed to disposer function
 * @constructor
 */
function Disposable (dispose, data) {
  this._dispose = dispose;
  this._data = data;
}

Disposable.prototype.dispose = function () {
  return this._dispose(this._data)
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function SettableDisposable () {
  this.disposable = void 0;
  this.disposed = false;
  this._resolve = void 0;

  var self = this;
  this.result = new Promise(function (resolve) {
    self._resolve = resolve;
  });
}

SettableDisposable.prototype.setDisposable = function (disposable) {
  if (this.disposable !== void 0) {
    throw new Error('setDisposable called more than once')
  }

  this.disposable = disposable;

  if (this.disposed) {
    this._resolve(disposable.dispose());
  }
};

SettableDisposable.prototype.dispose = function () {
  if (this.disposed) {
    return this.result
  }

  this.disposed = true;

  if (this.disposable !== void 0) {
    this.result = this.disposable.dispose();
  }

  return this.result
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function isPromise (p) {
  return p !== null && typeof p === 'object' && typeof p.then === 'function'
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
var map$1 = map;
var identity = id;

/**
 * Call disposable.dispose.  If it returns a promise, catch promise
 * error and forward it through the provided sink.
 * @param {number} t time
 * @param {{dispose: function}} disposable
 * @param {{error: function}} sink
 * @return {*} result of disposable.dispose
 */
function tryDispose (t, disposable, sink) {
  var result = disposeSafely(disposable);
  return isPromise(result)
    ? result.catch(function (e) {
      sink.error(t, e);
    })
    : result
}

/**
 * Create a new Disposable which will dispose its underlying resource
 * at most once.
 * @param {function} dispose function
 * @param {*?} data any data to be passed to disposer function
 * @return {Disposable}
 */
function create (dispose, data) {
  return once(new Disposable(dispose, data))
}

/**
 * Create a noop disposable. Can be used to satisfy a Disposable
 * requirement when no actual resource needs to be disposed.
 * @return {Disposable|exports|module.exports}
 */
function empty$1 () {
  return new Disposable(identity, void 0)
}

/**
 * Create a disposable that will dispose all input disposables in parallel.
 * @param {Array<Disposable>} disposables
 * @return {Disposable}
 */
function all (disposables) {
  return create(disposeAll, disposables)
}

function disposeAll (disposables) {
  return Promise.all(map$1(disposeSafely, disposables))
}

function disposeSafely (disposable) {
  try {
    return disposable.dispose()
  } catch (e) {
    return Promise.reject(e)
  }
}

/**
 * Create a disposable from a promise for another disposable
 * @param {Promise<Disposable>} disposablePromise
 * @return {Disposable}
 */


function disposePromise (disposablePromise) {
  return disposablePromise.then(disposeOne)
}

function disposeOne (disposable) {
  return disposable.dispose()
}

/**
 * Create a disposable proxy that allows its underlying disposable to
 * be set later.
 * @return {SettableDisposable}
 */
function settable () {
  return new SettableDisposable()
}

/**
 * Wrap an existing disposable (which may not already have been once()d)
 * so that it will only dispose its underlying resource at most once.
 * @param {{ dispose: function() }} disposable
 * @return {Disposable} wrapped disposable
 */
function once (disposable) {
  return new Disposable(disposeMemoized, memoized(disposable))
}

function disposeMemoized (memoized) {
  if (!memoized.disposed) {
    memoized.disposed = true;
    memoized.value = disposeSafely(memoized.disposable);
    memoized.disposable = void 0;
  }

  return memoized.value
}

function memoized (disposable) {
  return { disposed: false, disposable: disposable, value: void 0 }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function fatalError (e) {
  setTimeout(function () {
    throw e
  }, 0);
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function PropagateTask (run, value, sink) {
  this._run = run;
  this.value = value;
  this.sink = sink;
  this.active = true;
}

PropagateTask.event = function (value, sink) {
  return new PropagateTask(emit, value, sink)
};

PropagateTask.end = function (value, sink) {
  return new PropagateTask(end$1, value, sink)
};

PropagateTask.error = function (value, sink) {
  return new PropagateTask(error$1, value, sink)
};

PropagateTask.prototype.dispose = function () {
  this.active = false;
};

PropagateTask.prototype.run = function (t) {
  if (!this.active) {
    return
  }
  this._run(t, this.value, this.sink);
};

PropagateTask.prototype.error = function (t, e) {
  if (!this.active) {
    return fatalError(e)
  }
  this.sink.error(t, e);
};

function error$1 (t, e, sink) {
  sink.error(t, e);
}

function emit (t, x, sink) {
  sink.event(t, x);
}

function end$1 (t, x, sink) {
  sink.end(t, x);
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Stream containing only x
 * @param {*} x
 * @returns {Stream}
 */
function of (x) {
  return new Stream(new Just(x))
}

function Just (x) {
  this.value = x;
}

Just.prototype.run = function (sink, scheduler) {
  return scheduler.asap(new PropagateTask(runJust, this.value, sink))
};

function runJust (t, x, sink) {
  sink.event(t, x);
  sink.end(t, void 0);
}

/**
 * Stream containing no events and ends immediately
 * @returns {Stream}
 */
function empty$$1 () {
  return EMPTY
}

function EmptySource () {}

EmptySource.prototype.run = function (sink, scheduler) {
  var task = PropagateTask.end(void 0, sink);
  scheduler.asap(task);

  return create(disposeEmpty, task)
};

function disposeEmpty (task) {
  return task.dispose()
}

var EMPTY = new Stream(new EmptySource());

/**
 * Stream containing no events and never ends
 * @returns {Stream}
 */
function never () {
  return NEVER
}

function NeverSource () {}

NeverSource.prototype.run = function () {
  return empty$1()
};

var NEVER = new Stream(new NeverSource());

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function fromArray (a) {
  return new Stream(new ArraySource(a))
}

function ArraySource (a) {
  this.array = a;
}

ArraySource.prototype.run = function (sink, scheduler) {
  return scheduler.asap(new PropagateTask(runProducer, this.array, sink))
};

function runProducer (t, array, sink) {
  for (var i = 0, l = array.length; i < l && this.active; ++i) {
    sink.event(t, array[i]);
  }

  this.active && end(t);

  function end (t) {
    sink.end(t);
  }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global Set, Symbol*/
var iteratorSymbol;
// Firefox ships a partial implementation using the name @@iterator.
// https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
if (typeof Set === 'function' && typeof new Set()['@@iterator'] === 'function') {
  iteratorSymbol = '@@iterator';
} else {
  iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator ||
  '_es6shim_iterator_';
}

function isIterable (o) {
  return typeof o[iteratorSymbol] === 'function'
}

function getIterator (o) {
  return o[iteratorSymbol]()
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function fromIterable (iterable) {
  return new Stream(new IterableSource(iterable))
}

function IterableSource (iterable) {
  this.iterable = iterable;
}

IterableSource.prototype.run = function (sink, scheduler) {
  return new IteratorProducer(getIterator(this.iterable), sink, scheduler)
};

function IteratorProducer (iterator, sink, scheduler) {
  this.scheduler = scheduler;
  this.iterator = iterator;
  this.task = new PropagateTask(runProducer$1, this, sink);
  scheduler.asap(this.task);
}

IteratorProducer.prototype.dispose = function () {
  return this.task.dispose()
};

function runProducer$1 (t, producer, sink) {
  var x = producer.iterator.next();
  if (x.done) {
    sink.end(t, x.value);
  } else {
    sink.event(t, x.value);
  }

  producer.scheduler.asap(producer.task);
}

function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}

/* global window */
var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = symbolObservablePonyfill(root);

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function getObservable (o) { // eslint-disable-line complexity
  var obs = null;
  if (o) {
  // Access foreign method only once
    var method = o[result];
    if (typeof method === 'function') {
      obs = method.call(o);
      if (!(obs && typeof obs.subscribe === 'function')) {
        throw new TypeError('invalid observable ' + obs)
      }
    }
  }

  return obs
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function fromObservable (observable) {
  return new Stream(new ObservableSource(observable))
}

function ObservableSource (observable) {
  this.observable = observable;
}

ObservableSource.prototype.run = function (sink, scheduler) {
  var sub = this.observable.subscribe(new SubscriberSink(sink, scheduler));
  if (typeof sub === 'function') {
    return create(sub)
  } else if (sub && typeof sub.unsubscribe === 'function') {
    return create(unsubscribe, sub)
  }

  throw new TypeError('Observable returned invalid subscription ' + String(sub))
};

function SubscriberSink (sink, scheduler) {
  this.sink = sink;
  this.scheduler = scheduler;
}

SubscriberSink.prototype.next = function (x) {
  this.sink.event(this.scheduler.now(), x);
};

SubscriberSink.prototype.complete = function (x) {
  this.sink.end(this.scheduler.now(), x);
};

SubscriberSink.prototype.error = function (e) {
  this.sink.error(this.scheduler.now(), e);
};

function unsubscribe (subscription) {
  return subscription.unsubscribe()
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function from (a) { // eslint-disable-line complexity
  if (a instanceof Stream) {
    return a
  }

  var observable = getObservable(a);
  if (observable != null) {
    return fromObservable(observable)
  }

  if (Array.isArray(a) || isArrayLike(a)) {
    return fromArray(a)
  }

  if (isIterable(a)) {
    return fromIterable(a)
  }

  throw new TypeError('from(x) must be observable, iterable, or array-like: ' + a)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Create a stream that emits the current time periodically
 * @param {Number} period periodicity of events in millis
 * @param {*} value value to emit each period
 * @returns {Stream} new stream that emits the current time every period
 */
function periodic (period, value) {
  return new Stream(new Periodic(period, value))
}

function Periodic (period, value) {
  this.period = period;
  this.value = value;
}

Periodic.prototype.run = function (sink, scheduler) {
  return scheduler.periodic(this.period, PropagateTask.event(this.value, sink))
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function ScheduledTask (delay, period, task, scheduler) {
  this.time = delay;
  this.period = period;
  this.task = task;
  this.scheduler = scheduler;
  this.active = true;
}

ScheduledTask.prototype.run = function () {
  return this.task.run(this.time)
};

ScheduledTask.prototype.error = function (e) {
  return this.task.error(this.time, e)
};

ScheduledTask.prototype.dispose = function () {
  this.scheduler.cancel(this);
  return this.task.dispose()
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function defer (task) {
  return Promise.resolve(task).then(runTask)
}

function runTask (task) {
  try {
    return task.run()
  } catch (e) {
    return task.error(e)
  }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function Scheduler (timer, timeline) {
  this.timer = timer;
  this.timeline = timeline;

  this._timer = null;
  this._nextArrival = Infinity;

  var self = this;
  this._runReadyTasksBound = function () {
    self._runReadyTasks(self.now());
  };
}

Scheduler.prototype.now = function () {
  return this.timer.now()
};

Scheduler.prototype.asap = function (task) {
  return this.schedule(0, -1, task)
};

Scheduler.prototype.delay = function (delay, task) {
  return this.schedule(delay, -1, task)
};

Scheduler.prototype.periodic = function (period, task) {
  return this.schedule(0, period, task)
};

Scheduler.prototype.schedule = function (delay, period, task) {
  var now = this.now();
  var st = new ScheduledTask(now + Math.max(0, delay), period, task, this);

  this.timeline.add(st);
  this._scheduleNextRun(now);
  return st
};

Scheduler.prototype.cancel = function (task) {
  task.active = false;
  if (this.timeline.remove(task)) {
    this._reschedule();
  }
};

Scheduler.prototype.cancelAll = function (f) {
  this.timeline.removeAll(f);
  this._reschedule();
};

Scheduler.prototype._reschedule = function () {
  if (this.timeline.isEmpty()) {
    this._unschedule();
  } else {
    this._scheduleNextRun(this.now());
  }
};

Scheduler.prototype._unschedule = function () {
  this.timer.clearTimer(this._timer);
  this._timer = null;
};

Scheduler.prototype._scheduleNextRun = function (now) { // eslint-disable-line complexity
  if (this.timeline.isEmpty()) {
    return
  }

  var nextArrival = this.timeline.nextArrival();

  if (this._timer === null) {
    this._scheduleNextArrival(nextArrival, now);
  } else if (nextArrival < this._nextArrival) {
    this._unschedule();
    this._scheduleNextArrival(nextArrival, now);
  }
};

Scheduler.prototype._scheduleNextArrival = function (nextArrival, now) {
  this._nextArrival = nextArrival;
  var delay = Math.max(0, nextArrival - now);
  this._timer = this.timer.setTimer(this._runReadyTasksBound, delay);
};

Scheduler.prototype._runReadyTasks = function (now) {
  this._timer = null;
  this.timeline.runTasks(now, runTask);
  this._scheduleNextRun(this.now());
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global setTimeout, clearTimeout*/

function ClockTimer () {}

ClockTimer.prototype.now = Date.now;

ClockTimer.prototype.setTimer = function (f, dt) {
  return dt <= 0 ? runAsap(f) : setTimeout(f, dt)
};

ClockTimer.prototype.clearTimer = function (t) {
  return t instanceof Asap ? t.cancel() : clearTimeout(t)
};

function Asap (f) {
  this.f = f;
  this.active = true;
}

Asap.prototype.run = function () {
  return this.active && this.f()
};

Asap.prototype.error = function (e) {
  throw e
};

Asap.prototype.cancel = function () {
  this.active = false;
};

function runAsap (f) {
  var task = new Asap(f);
  defer(task);
  return task
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function Timeline () {
  this.tasks = [];
}

Timeline.prototype.nextArrival = function () {
  return this.isEmpty() ? Infinity : this.tasks[0].time
};

Timeline.prototype.isEmpty = function () {
  return this.tasks.length === 0
};

Timeline.prototype.add = function (st) {
  insertByTime(st, this.tasks);
};

Timeline.prototype.remove = function (st) {
  var i = binarySearch(st.time, this.tasks);

  if (i >= 0 && i < this.tasks.length) {
    var at = findIndex(st, this.tasks[i].events);
    if (at >= 0) {
      this.tasks[i].events.splice(at, 1);
      return true
    }
  }

  return false
};

Timeline.prototype.removeAll = function (f) {
  var this$1 = this;

  for (var i = 0, l = this.tasks.length; i < l; ++i) {
    removeAllFrom(f, this$1.tasks[i]);
  }
};

Timeline.prototype.runTasks = function (t, runTask) {
  var this$1 = this;

  var tasks = this.tasks;
  var l = tasks.length;
  var i = 0;

  while (i < l && tasks[i].time <= t) {
    ++i;
  }

  this.tasks = tasks.slice(i);

  // Run all ready tasks
  for (var j = 0; j < i; ++j) {
    this$1.tasks = runTasks(runTask, tasks[j], this$1.tasks);
  }
};

function runTasks (runTask, timeslot, tasks) { // eslint-disable-line complexity
  var events = timeslot.events;
  for (var i = 0; i < events.length; ++i) {
    var task = events[i];

    if (task.active) {
      runTask(task);

      // Reschedule periodic repeating tasks
      // Check active again, since a task may have canceled itself
      if (task.period >= 0 && task.active) {
        task.time = task.time + task.period;
        insertByTime(task, tasks);
      }
    }
  }

  return tasks
}

function insertByTime (task, timeslots) { // eslint-disable-line complexity
  var l = timeslots.length;

  if (l === 0) {
    timeslots.push(newTimeslot(task.time, [task]));
    return
  }

  var i = binarySearch(task.time, timeslots);

  if (i >= l) {
    timeslots.push(newTimeslot(task.time, [task]));
  } else if (task.time === timeslots[i].time) {
    timeslots[i].events.push(task);
  } else {
    timeslots.splice(i, 0, newTimeslot(task.time, [task]));
  }
}

function removeAllFrom (f, timeslot) {
  timeslot.events = removeAll(f, timeslot.events);
}

function binarySearch (t, sortedArray) { // eslint-disable-line complexity
  var lo = 0;
  var hi = sortedArray.length;
  var mid, y;

  while (lo < hi) {
    mid = Math.floor((lo + hi) / 2);
    y = sortedArray[mid];

    if (t === y.time) {
      return mid
    } else if (t < y.time) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return hi
}

function newTimeslot (t, events) {
  return { time: t, events: events }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var defaultScheduler = new Scheduler(new ClockTimer(), new Timeline());

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function subscribe (subscriber, stream) {
  if (subscriber == null || typeof subscriber !== 'object') {
    throw new TypeError('subscriber must be an object')
  }

  var disposable = settable();
  var observer = new SubscribeObserver(fatalError, subscriber, disposable);

  disposable.setDisposable(stream.source.run(observer, defaultScheduler));

  return new Subscription(disposable)
}

function SubscribeObserver (fatalError$$1, subscriber, disposable) {
  this.fatalError = fatalError$$1;
  this.subscriber = subscriber;
  this.disposable = disposable;
}

SubscribeObserver.prototype.event = function (t, x) {
  if (!this.disposable.disposed && typeof this.subscriber.next === 'function') {
    this.subscriber.next(x);
  }
};

SubscribeObserver.prototype.end = function (t, x) {
  var s = this.subscriber;
  doDispose(this.fatalError, s, s.complete, s.error, this.disposable, x);
};

SubscribeObserver.prototype.error = function (t, e) {
  var s = this.subscriber;
  doDispose(this.fatalError, s, s.error, s.error, this.disposable, e);
};

function Subscription (disposable) {
  this.disposable = disposable;
}

Subscription.prototype.unsubscribe = function () {
  this.disposable.dispose();
};

function doDispose (fatal, subscriber, complete, error, disposable, x) {
  Promise.resolve(disposable.dispose()).then(function () {
    if (typeof complete === 'function') {
      complete.call(subscriber, x);
    }
  }).catch(function (e) {
    if (typeof error === 'function') {
      error.call(subscriber, e);
    }
  }).catch(fatal);
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function thru (f, stream) {
  return f(stream)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function tryEvent (t, x, sink) {
  try {
    sink.event(t, x);
  } catch (e) {
    sink.error(t, e);
  }
}

function tryEnd (t, x, sink) {
  try {
    sink.end(t, x);
  } catch (e) {
    sink.error(t, e);
  }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function EventTargetSource (event, source, capture) {
  this.event = event;
  this.source = source;
  this.capture = capture;
}

EventTargetSource.prototype.run = function (sink, scheduler) {
  function addEvent (e) {
    tryEvent(scheduler.now(), e, sink);
  }

  this.source.addEventListener(this.event, addEvent, this.capture);

  return create(disposeEventTarget,
    { target: this, addEvent: addEvent })
};

function disposeEventTarget (info) {
  var target = info.target;
  target.source.removeEventListener(target.event, info.addEvent, target.capture);
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function DeferredSink (sink) {
  this.sink = sink;
  this.events = [];
  this.active = true;
}

DeferredSink.prototype.event = function (t, x) {
  if (!this.active) {
    return
  }

  if (this.events.length === 0) {
    defer(new PropagateAllTask(this.sink, t, this.events));
  }

  this.events.push({ time: t, value: x });
};

DeferredSink.prototype.end = function (t, x) {
  if (!this.active) {
    return
  }

  this._end(new EndTask(t, x, this.sink));
};

DeferredSink.prototype.error = function (t, e) {
  this._end(new ErrorTask(t, e, this.sink));
};

DeferredSink.prototype._end = function (task) {
  this.active = false;
  defer(task);
};

function PropagateAllTask (sink, time, events) {
  this.sink = sink;
  this.events = events;
  this.time = time;
}

PropagateAllTask.prototype.run = function () {
  var this$1 = this;

  var events = this.events;
  var sink = this.sink;
  var event;

  for (var i = 0, l = events.length; i < l; ++i) {
    event = events[i];
    this$1.time = event.time;
    sink.event(event.time, event.value);
  }

  events.length = 0;
};

PropagateAllTask.prototype.error = function (e) {
  this.sink.error(this.time, e);
};

function EndTask (t, x, sink) {
  this.time = t;
  this.value = x;
  this.sink = sink;
}

EndTask.prototype.run = function () {
  this.sink.end(this.time, this.value);
};

EndTask.prototype.error = function (e) {
  this.sink.error(this.time, e);
};

function ErrorTask (t, e, sink) {
  this.time = t;
  this.value = e;
  this.sink = sink;
}

ErrorTask.prototype.run = function () {
  this.sink.error(this.time, this.value);
};

ErrorTask.prototype.error = function (e) {
  throw e
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function EventEmitterSource (event, source) {
  this.event = event;
  this.source = source;
}

EventEmitterSource.prototype.run = function (sink, scheduler) {
  // NOTE: Because EventEmitter allows events in the same call stack as
  // a listener is added, use a DeferredSink to buffer events
  // until the stack clears, then propagate.  This maintains most.js's
  // invariant that no event will be delivered in the same call stack
  // as an observer begins observing.
  var dsink = new DeferredSink(sink);

  function addEventVariadic (a) {
    var arguments$1 = arguments;

    var l = arguments.length;
    if (l > 1) {
      var arr = new Array(l);
      for (var i = 0; i < l; ++i) {
        arr[i] = arguments$1[i];
      }
      tryEvent(scheduler.now(), arr, dsink);
    } else {
      tryEvent(scheduler.now(), a, dsink);
    }
  }

  this.source.addListener(this.event, addEventVariadic);

  return create(disposeEventEmitter, { target: this, addEvent: addEventVariadic })
};

function disposeEventEmitter (info) {
  var target = info.target;
  target.source.removeListener(target.event, info.addEvent);
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Create a stream from an EventTarget, such as a DOM Node, or EventEmitter.
 * @param {String} event event type name, e.g. 'click'
 * @param {EventTarget|EventEmitter} source EventTarget or EventEmitter
 * @param {*?} capture for DOM events, whether to use
 *  capturing--passed as 3rd parameter to addEventListener.
 * @returns {Stream} stream containing all events of the specified type
 * from the source.
 */
function fromEvent (event, source, capture) { // eslint-disable-line complexity
  var s;

  if (typeof source.addEventListener === 'function' && typeof source.removeEventListener === 'function') {
    if (arguments.length < 3) {
      capture = false;
    }

    s = new EventTargetSource(event, source, capture);
  } else if (typeof source.addListener === 'function' && typeof source.removeListener === 'function') {
    s = new EventEmitterSource(event, source);
  } else {
    throw new Error('source must support addEventListener/removeEventListener or addListener/removeListener')
  }

  return new Stream(s)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function withDefaultScheduler (source) {
  return withScheduler(source, defaultScheduler)
}

function withScheduler (source, scheduler) {
  return new Promise(function (resolve, reject) {
    runSource(source, scheduler, resolve, reject);
  })
}

function runSource (source, scheduler, resolve, reject) {
  var disposable = settable();
  var observer = new Drain(resolve, reject, disposable);

  disposable.setDisposable(source.run(observer, scheduler));
}

function Drain (end, error, disposable) {
  this._end = end;
  this._error = error;
  this._disposable = disposable;
  this.active = true;
}

Drain.prototype.event = function (t, x) {};

Drain.prototype.end = function (t, x) {
  if (!this.active) {
    return
  }
  this.active = false;
  disposeThen(this._end, this._error, this._disposable, x);
};

Drain.prototype.error = function (t, e) {
  this.active = false;
  disposeThen(this._error, this._error, this._disposable, e);
};

function disposeThen (end, error, disposable, x) {
  Promise.resolve(disposable.dispose()).then(function () {
    end(x);
  }, error);
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * A sink mixin that simply forwards event, end, and error to
 * another sink.
 * @param sink
 * @constructor
 */
function Pipe (sink) {
  this.sink = sink;
}

Pipe.prototype.event = function (t, x) {
  return this.sink.event(t, x)
};

Pipe.prototype.end = function (t, x) {
  return this.sink.end(t, x)
};

Pipe.prototype.error = function (t, e) {
  return this.sink.error(t, e)
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function Filter (p, source) {
  this.p = p;
  this.source = source;
}

/**
 * Create a filtered source, fusing adjacent filter.filter if possible
 * @param {function(x:*):boolean} p filtering predicate
 * @param {{run:function}} source source to filter
 * @returns {Filter} filtered source
 */
Filter.create = function createFilter (p, source) {
  if (source instanceof Filter) {
    return new Filter(and(source.p, p), source.source)
  }

  return new Filter(p, source)
};

Filter.prototype.run = function (sink, scheduler) {
  return this.source.run(new FilterSink(this.p, sink), scheduler)
};

function FilterSink (p, sink) {
  this.p = p;
  this.sink = sink;
}

FilterSink.prototype.end = Pipe.prototype.end;
FilterSink.prototype.error = Pipe.prototype.error;

FilterSink.prototype.event = function (t, x) {
  var p = this.p;
  p(x) && this.sink.event(t, x);
};

function and (p, q) {
  return function (x) {
    return p(x) && q(x)
  }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function FilterMap (p, f, source) {
  this.p = p;
  this.f = f;
  this.source = source;
}

FilterMap.prototype.run = function (sink, scheduler) {
  return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler)
};

function FilterMapSink (p, f, sink) {
  this.p = p;
  this.f = f;
  this.sink = sink;
}

FilterMapSink.prototype.event = function (t, x) {
  var f = this.f;
  var p = this.p;
  p(x) && this.sink.event(t, f(x));
};

FilterMapSink.prototype.end = Pipe.prototype.end;
FilterMapSink.prototype.error = Pipe.prototype.error;

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function Map (f, source) {
  this.f = f;
  this.source = source;
}

/**
 * Create a mapped source, fusing adjacent map.map, filter.map,
 * and filter.map.map if possible
 * @param {function(*):*} f mapping function
 * @param {{run:function}} source source to map
 * @returns {Map|FilterMap} mapped source, possibly fused
 */
Map.create = function createMap (f, source) {
  if (source instanceof Map) {
    return new Map(compose(f, source.f), source.source)
  }

  if (source instanceof Filter) {
    return new FilterMap(source.p, f, source.source)
  }

  return new Map(f, source)
};

Map.prototype.run = function (sink, scheduler) { // eslint-disable-line no-extend-native
  return this.source.run(new MapSink(this.f, sink), scheduler)
};

function MapSink (f, sink) {
  this.f = f;
  this.sink = sink;
}

MapSink.prototype.end = Pipe.prototype.end;
MapSink.prototype.error = Pipe.prototype.error;

MapSink.prototype.event = function (t, x) {
  var f = this.f;
  this.sink.event(t, f(x));
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Transform each value in the stream by applying f to each
 * @param {function(*):*} f mapping function
 * @param {Stream} stream stream to map
 * @returns {Stream} stream containing items transformed by f
 */
function map$2 (f, stream) {
  return new Stream(Map.create(f, stream.source))
}

/**
* Replace each value in the stream with x
* @param {*} x
* @param {Stream} stream
* @returns {Stream} stream containing items replaced with x
*/
function constant (x, stream) {
  return map$2(function () {
    return x
  }, stream)
}

/**
* Perform a side effect for each item in the stream
* @param {function(x:*):*} f side effect to execute for each item. The
*  return value will be discarded.
* @param {Stream} stream stream to tap
* @returns {Stream} new stream containing the same items as this stream
*/
function tap (f, stream) {
  return new Stream(new Tap(f, stream.source))
}

function Tap (f, source) {
  this.source = source;
  this.f = f;
}

Tap.prototype.run = function (sink, scheduler) {
  return this.source.run(new TapSink(this.f, sink), scheduler)
};

function TapSink (f, sink) {
  this.sink = sink;
  this.f = f;
}

TapSink.prototype.end = Pipe.prototype.end;
TapSink.prototype.error = Pipe.prototype.error;

TapSink.prototype.event = function (t, x) {
  var f = this.f;
  f(x);
  this.sink.event(t, x);
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Observe all the event values in the stream in time order. The
 * provided function `f` will be called for each event value
 * @param {function(x:T):*} f function to call with each event value
 * @param {Stream<T>} stream stream to observe
 * @return {Promise} promise that fulfills after the stream ends without
 *  an error, or rejects if the stream ends with an error.
 */
function observe (f, stream) {
  return drain(tap(f, stream))
}

/**
 * "Run" a stream by creating demand and consuming all events
 * @param {Stream<T>} stream stream to drain
 * @return {Promise} promise that fulfills after the stream ends without
 *  an error, or rejects if the stream ends with an error.
 */
function drain (stream) {
  return withDefaultScheduler(stream.source)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Generalized feedback loop. Call a stepper function for each event. The stepper
 * will be called with 2 params: the current seed and the an event value.  It must
 * return a new { seed, value } pair. The `seed` will be fed back into the next
 * invocation of stepper, and the `value` will be propagated as the event value.
 * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function
 * @param {*} seed initial seed value passed to first stepper call
 * @param {Stream} stream event stream
 * @returns {Stream} new stream whose values are the `value` field of the objects
 * returned by the stepper
 */
function loop (stepper, seed, stream) {
  return new Stream(new Loop(stepper, seed, stream.source))
}

function Loop (stepper, seed, source) {
  this.step = stepper;
  this.seed = seed;
  this.source = source;
}

Loop.prototype.run = function (sink, scheduler) {
  return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler)
};

function LoopSink (stepper, seed, sink) {
  this.step = stepper;
  this.seed = seed;
  this.sink = sink;
}

LoopSink.prototype.error = Pipe.prototype.error;

LoopSink.prototype.event = function (t, x) {
  var result = this.step(this.seed, x);
  this.seed = result.seed;
  this.sink.event(t, result.value);
};

LoopSink.prototype.end = function (t) {
  this.sink.end(t, this.seed);
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Create a stream containing successive reduce results of applying f to
 * the previous reduce result and the current stream item.
 * @param {function(result:*, x:*):*} f reducer function
 * @param {*} initial initial value
 * @param {Stream} stream stream to scan
 * @returns {Stream} new stream containing successive reduce results
 */
function scan (f, initial, stream) {
  return new Stream(new Scan(f, initial, stream.source))
}

function Scan (f, z, source) {
  this.source = source;
  this.f = f;
  this.value = z;
}

Scan.prototype.run = function (sink, scheduler) {
  var d1 = scheduler.asap(PropagateTask.event(this.value, sink));
  var d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler);
  return all([d1, d2])
};

function ScanSink (f, z, sink) {
  this.f = f;
  this.value = z;
  this.sink = sink;
}

ScanSink.prototype.event = function (t, x) {
  var f = this.f;
  this.value = f(this.value, x);
  this.sink.event(t, this.value);
};

ScanSink.prototype.error = Pipe.prototype.error;
ScanSink.prototype.end = Pipe.prototype.end;

/**
* Reduce a stream to produce a single result.  Note that reducing an infinite
* stream will return a Promise that never fulfills, but that may reject if an error
* occurs.
* @param {function(result:*, x:*):*} f reducer function
* @param {*} initial initial value
* @param {Stream} stream to reduce
* @returns {Promise} promise for the file result of the reduce
*/
function reduce$1 (f, initial, stream) {
  return withDefaultScheduler(new Reduce(f, initial, stream.source))
}

function Reduce (f, z, source) {
  this.source = source;
  this.f = f;
  this.value = z;
}

Reduce.prototype.run = function (sink, scheduler) {
  return this.source.run(new ReduceSink(this.f, this.value, sink), scheduler)
};

function ReduceSink (f, z, sink) {
  this.f = f;
  this.value = z;
  this.sink = sink;
}

ReduceSink.prototype.event = function (t, x) {
  var f = this.f;
  this.value = f(this.value, x);
  this.sink.event(t, this.value);
};

ReduceSink.prototype.error = Pipe.prototype.error;

ReduceSink.prototype.end = function (t) {
  this.sink.end(t, this.value);
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Compute a stream by unfolding tuples of future values from a seed value
 * Event times may be controlled by returning a Promise from f
 * @param {function(seed:*):{value:*, seed:*, done:boolean}|Promise<{value:*, seed:*, done:boolean}>} f unfolding function accepts
 *  a seed and returns a new tuple with a value, new seed, and boolean done flag.
 *  If tuple.done is true, the stream will end.
 * @param {*} seed seed value
 * @returns {Stream} stream containing all value of all tuples produced by the
 *  unfolding function.
 */
function unfold (f, seed) {
  return new Stream(new UnfoldSource(f, seed))
}

function UnfoldSource (f, seed) {
  this.f = f;
  this.value = seed;
}

UnfoldSource.prototype.run = function (sink, scheduler) {
  return new Unfold(this.f, this.value, sink, scheduler)
};

function Unfold (f, x, sink, scheduler) {
  this.f = f;
  this.sink = sink;
  this.scheduler = scheduler;
  this.active = true;

  var self = this;
  function err (e) {
    self.sink.error(self.scheduler.now(), e);
  }

  function start (unfold) {
    return stepUnfold(unfold, x)
  }

  Promise.resolve(this).then(start).catch(err);
}

Unfold.prototype.dispose = function () {
  this.active = false;
};

function stepUnfold (unfold, x) {
  var f = unfold.f;
  return Promise.resolve(f(x)).then(function (tuple) {
    return continueUnfold(unfold, tuple)
  })
}

function continueUnfold (unfold, tuple) {
  if (tuple.done) {
    unfold.sink.end(unfold.scheduler.now(), tuple.value);
    return tuple.value
  }

  unfold.sink.event(unfold.scheduler.now(), tuple.value);

  if (!unfold.active) {
    return tuple.value
  }
  return stepUnfold(unfold, tuple.seed)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Compute a stream by iteratively calling f to produce values
 * Event times may be controlled by returning a Promise from f
 * @param {function(x:*):*|Promise<*>} f
 * @param {*} x initial value
 * @returns {Stream}
 */
function iterate (f, x) {
  return new Stream(new IterateSource(f, x))
}

function IterateSource (f, x) {
  this.f = f;
  this.value = x;
}

IterateSource.prototype.run = function (sink, scheduler) {
  return new Iterate(this.f, this.value, sink, scheduler)
};

function Iterate (f, initial, sink, scheduler) {
  this.f = f;
  this.sink = sink;
  this.scheduler = scheduler;
  this.active = true;

  var x = initial;

  var self = this;
  function err (e) {
    self.sink.error(self.scheduler.now(), e);
  }

  function start (iterate) {
    return stepIterate(iterate, x)
  }

  Promise.resolve(this).then(start).catch(err);
}

Iterate.prototype.dispose = function () {
  this.active = false;
};

function stepIterate (iterate, x) {
  iterate.sink.event(iterate.scheduler.now(), x);

  if (!iterate.active) {
    return x
  }

  var f = iterate.f;
  return Promise.resolve(f(x)).then(function (y) {
    return continueIterate(iterate, y)
  })
}

function continueIterate (iterate, x) {
  return !iterate.active ? iterate.value : stepIterate(iterate, x)
}

/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Compute a stream using an *async* generator, which yields promises
 * to control event times.
 * @param f
 * @returns {Stream}
 */
function generate (f /*, ...args */) {
  return new Stream(new GenerateSource(f, tail(arguments)))
}

function GenerateSource (f, args) {
  this.f = f;
  this.args = args;
}

GenerateSource.prototype.run = function (sink, scheduler) {
  return new Generate(this.f.apply(void 0, this.args), sink, scheduler)
};

function Generate (iterator, sink, scheduler) {
  this.iterator = iterator;
  this.sink = sink;
  this.scheduler = scheduler;
  this.active = true;

  var self = this;
  function err (e) {
    self.sink.error(self.scheduler.now(), e);
  }

  Promise.resolve(this).then(next).catch(err);
}

function next (generate, x) {
  return generate.active ? handle(generate, generate.iterator.next(x)) : x
}

function handle (generate, result) {
  if (result.done) {
    return generate.sink.end(generate.scheduler.now(), result.value)
  }

  return Promise.resolve(result.value).then(function (x) {
    return emit$1(generate, x)
  }, function (e) {
    return error$2(generate, e)
  })
}

function emit$1 (generate, x) {
  generate.sink.event(generate.scheduler.now(), x);
  return next(generate, x)
}

function error$2 (generate, e) {
  return handle(generate, generate.iterator.throw(e))
}

Generate.prototype.dispose = function () {
  this.active = false;
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function continueWith (f, stream) {
  return new Stream(new ContinueWith(f, stream.source))
}

function ContinueWith (f, source) {
  this.f = f;
  this.source = source;
}

ContinueWith.prototype.run = function (sink, scheduler) {
  return new ContinueWithSink(this.f, this.source, sink, scheduler)
};

function ContinueWithSink (f, source, sink, scheduler) {
  this.f = f;
  this.sink = sink;
  this.scheduler = scheduler;
  this.active = true;
  this.disposable = once(source.run(this, scheduler));
}

ContinueWithSink.prototype.error = Pipe.prototype.error;

ContinueWithSink.prototype.event = function (t, x) {
  if (!this.active) {
    return
  }
  this.sink.event(t, x);
};

ContinueWithSink.prototype.end = function (t, x) {
  if (!this.active) {
    return
  }

  tryDispose(t, this.disposable, this.sink);
  this._startNext(t, x, this.sink);
};

ContinueWithSink.prototype._startNext = function (t, x, sink) {
  try {
    this.disposable = this._continue(this.f, x, sink);
  } catch (e) {
    sink.error(t, e);
  }
};

ContinueWithSink.prototype._continue = function (f, x, sink) {
  return f(x).source.run(sink, this.scheduler)
};

ContinueWithSink.prototype.dispose = function () {
  this.active = false;
  return this.disposable.dispose()
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * @param {*} x value to prepend
 * @param {Stream} stream
 * @returns {Stream} new stream with x prepended
 */
function cons$1 (x, stream) {
  return concat(of(x), stream)
}

/**
* @param {Stream} left
* @param {Stream} right
* @returns {Stream} new stream containing all events in left followed by all
*  events in right.  This *timeshifts* right to the end of left.
*/
function concat (left, right) {
  return continueWith(function () {
    return right
  }, left)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function IndexSink (i, sink) {
  this.sink = sink;
  this.index = i;
  this.active = true;
  this.value = void 0;
}

IndexSink.prototype.event = function (t, x) {
  if (!this.active) {
    return
  }
  this.value = x;
  this.sink.event(t, this);
};

IndexSink.prototype.end = function (t, x) {
  if (!this.active) {
    return
  }
  this.active = false;
  this.sink.end(t, { index: this.index, value: x });
};

IndexSink.prototype.error = Pipe.prototype.error;

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function invoke (f, args) {
	/*eslint complexity: [2,7]*/
  switch (args.length) {
    case 0: return f()
    case 1: return f(args[0])
    case 2: return f(args[0], args[1])
    case 3: return f(args[0], args[1], args[2])
    case 4: return f(args[0], args[1], args[2], args[3])
    case 5: return f(args[0], args[1], args[2], args[3], args[4])
    default:
      return f.apply(void 0, args)
  }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var map$3 = map;
var tail$1 = tail;

/**
 * Combine latest events from all input streams
 * @param {function(...events):*} f function to combine most recent events
 * @returns {Stream} stream containing the result of applying f to the most recent
 *  event of each input stream, whenever a new event arrives on any stream.
 */
function combine (f /*, ...streams */) {
  return combineArray(f, tail$1(arguments))
}

/**
* Combine latest events from all input streams
* @param {function(...events):*} f function to combine most recent events
* @param {[Stream]} streams most recent events
* @returns {Stream} stream containing the result of applying f to the most recent
*  event of each input stream, whenever a new event arrives on any stream.
*/
function combineArray (f, streams) {
  var l = streams.length;
  return l === 0 ? empty$$1()
  : l === 1 ? map$2(f, streams[0])
  : new Stream(combineSources(f, streams))
}

function combineSources (f, streams) {
  return new Combine(f, map$3(getSource, streams))
}

function getSource (stream) {
  return stream.source
}

function Combine (f, sources) {
  this.f = f;
  this.sources = sources;
}

Combine.prototype.run = function (sink, scheduler) {
  var this$1 = this;

  var l = this.sources.length;
  var disposables = new Array(l);
  var sinks = new Array(l);

  var mergeSink = new CombineSink(disposables, sinks, sink, this.f);

  for (var indexSink, i = 0; i < l; ++i) {
    indexSink = sinks[i] = new IndexSink(i, mergeSink);
    disposables[i] = this$1.sources[i].run(indexSink, scheduler);
  }

  return all(disposables)
};

function CombineSink (disposables, sinks, sink, f) {
  var this$1 = this;

  this.sink = sink;
  this.disposables = disposables;
  this.sinks = sinks;
  this.f = f;

  var l = sinks.length;
  this.awaiting = l;
  this.values = new Array(l);
  this.hasValue = new Array(l);
  for (var i = 0; i < l; ++i) {
    this$1.hasValue[i] = false;
  }

  this.activeCount = sinks.length;
}

CombineSink.prototype.error = Pipe.prototype.error;

CombineSink.prototype.event = function (t, indexedValue) {
  var i = indexedValue.index;
  var awaiting = this._updateReady(i);

  this.values[i] = indexedValue.value;
  if (awaiting === 0) {
    this.sink.event(t, invoke(this.f, this.values));
  }
};

CombineSink.prototype._updateReady = function (index) {
  if (this.awaiting > 0) {
    if (!this.hasValue[index]) {
      this.hasValue[index] = true;
      this.awaiting -= 1;
    }
  }
  return this.awaiting
};

CombineSink.prototype.end = function (t, indexedValue) {
  tryDispose(t, this.disposables[indexedValue.index], this.sink);
  if (--this.activeCount === 0) {
    this.sink.end(t, indexedValue.value);
  }
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Assume fs is a stream containing functions, and apply the latest function
 * in fs to the latest value in xs.
 * fs:         --f---------g--------h------>
 * xs:         -a-------b-------c-------d-->
 * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->
 * @param {Stream} fs stream of functions to apply to the latest x
 * @param {Stream} xs stream of values to which to apply all the latest f
 * @returns {Stream} stream containing all the applications of fs to xs
 */
function ap (fs, xs) {
  return combine(apply, fs, xs)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Transform a stream by passing its events through a transducer.
 * @param  {function} transducer transducer function
 * @param  {Stream} stream stream whose events will be passed through the
 *  transducer
 * @return {Stream} stream of events transformed by the transducer
 */
function transduce (transducer, stream) {
  return new Stream(new Transduce(transducer, stream.source))
}

function Transduce (transducer, source) {
  this.transducer = transducer;
  this.source = source;
}

Transduce.prototype.run = function (sink, scheduler) {
  var xf = this.transducer(new Transformer(sink));
  return this.source.run(new TransduceSink(getTxHandler(xf), sink), scheduler)
};

function TransduceSink (adapter, sink) {
  this.xf = adapter;
  this.sink = sink;
}

TransduceSink.prototype.event = function (t, x) {
  var next = this.xf.step(t, x);

  return this.xf.isReduced(next)
    ? this.sink.end(t, this.xf.getResult(next))
    : next
};

TransduceSink.prototype.end = function (t, x) {
  return this.xf.result(x)
};

TransduceSink.prototype.error = function (t, e) {
  return this.sink.error(t, e)
};

function Transformer (sink) {
  this.time = -Infinity;
  this.sink = sink;
}

Transformer.prototype['@@transducer/init'] = Transformer.prototype.init = function () {};

Transformer.prototype['@@transducer/step'] = Transformer.prototype.step = function (t, x) {
  if (!isNaN(t)) {
    this.time = Math.max(t, this.time);
  }
  return this.sink.event(this.time, x)
};

Transformer.prototype['@@transducer/result'] = Transformer.prototype.result = function (x) {
  return this.sink.end(this.time, x)
};

/**
* Given an object supporting the new or legacy transducer protocol,
* create an adapter for it.
* @param {object} tx transform
* @returns {TxAdapter|LegacyTxAdapter}
*/
function getTxHandler (tx) {
  return typeof tx['@@transducer/step'] === 'function'
    ? new TxAdapter(tx)
    : new LegacyTxAdapter(tx)
}

/**
* Adapter for new official transducer protocol
* @param {object} tx transform
* @constructor
*/
function TxAdapter (tx) {
  this.tx = tx;
}

TxAdapter.prototype.step = function (t, x) {
  return this.tx['@@transducer/step'](t, x)
};
TxAdapter.prototype.result = function (x) {
  return this.tx['@@transducer/result'](x)
};
TxAdapter.prototype.isReduced = function (x) {
  return x != null && x['@@transducer/reduced']
};
TxAdapter.prototype.getResult = function (x) {
  return x['@@transducer/value']
};

/**
* Adapter for older transducer protocol
* @param {object} tx transform
* @constructor
*/
function LegacyTxAdapter (tx) {
  this.tx = tx;
}

LegacyTxAdapter.prototype.step = function (t, x) {
  return this.tx.step(t, x)
};
LegacyTxAdapter.prototype.result = function (x) {
  return this.tx.result(x)
};
LegacyTxAdapter.prototype.isReduced = function (x) {
  return x != null && x.__transducers_reduced__
};
LegacyTxAdapter.prototype.getResult = function (x) {
  return x.value
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Doubly linked list
 * @constructor
 */
function LinkedList () {
  this.head = null;
  this.length = 0;
}

/**
 * Add a node to the end of the list
 * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to add
 */
LinkedList.prototype.add = function (x) {
  if (this.head !== null) {
    this.head.prev = x;
    x.next = this.head;
  }
  this.head = x;
  ++this.length;
};

/**
 * Remove the provided node from the list
 * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to remove
 */
LinkedList.prototype.remove = function (x) { // eslint-disable-line  complexity
  --this.length;
  if (x === this.head) {
    this.head = this.head.next;
  }
  if (x.next !== null) {
    x.next.prev = x.prev;
    x.next = null;
  }
  if (x.prev !== null) {
    x.prev.next = x.next;
    x.prev = null;
  }
};

/**
 * @returns {boolean} true iff there are no nodes in the list
 */
LinkedList.prototype.isEmpty = function () {
  return this.length === 0
};

/**
 * Dispose all nodes
 * @returns {Promise} promise that fulfills when all nodes have been disposed,
 *  or rejects if an error occurs while disposing
 */
LinkedList.prototype.dispose = function () {
  if (this.isEmpty()) {
    return Promise.resolve()
  }

  var promises = [];
  var x = this.head;
  this.head = null;
  this.length = 0;

  while (x !== null) {
    promises.push(x.dispose());
    x = x.next;
  }

  return Promise.all(promises)
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function mergeConcurrently (concurrency, stream) {
  return mergeMapConcurrently(id, concurrency, stream)
}

function mergeMapConcurrently (f, concurrency, stream) {
  return new Stream(new MergeConcurrently(f, concurrency, stream.source))
}

function MergeConcurrently (f, concurrency, source) {
  this.f = f;
  this.concurrency = concurrency;
  this.source = source;
}

MergeConcurrently.prototype.run = function (sink, scheduler) {
  return new Outer(this.f, this.concurrency, this.source, sink, scheduler)
};

function Outer (f, concurrency, source, sink, scheduler) {
  this.f = f;
  this.concurrency = concurrency;
  this.sink = sink;
  this.scheduler = scheduler;
  this.pending = [];
  this.current = new LinkedList();
  this.disposable = once(source.run(this, scheduler));
  this.active = true;
}

Outer.prototype.event = function (t, x) {
  this._addInner(t, x);
};

Outer.prototype._addInner = function (t, x) {
  if (this.current.length < this.concurrency) {
    this._startInner(t, x);
  } else {
    this.pending.push(x);
  }
};

Outer.prototype._startInner = function (t, x) {
  try {
    this._initInner(t, x);
  } catch (e) {
    this.error(t, e);
  }
};

Outer.prototype._initInner = function (t, x) {
  var innerSink = new Inner(t, this, this.sink);
  innerSink.disposable = mapAndRun(this.f, x, innerSink, this.scheduler);
  this.current.add(innerSink);
};

function mapAndRun (f, x, sink, scheduler) {
  return f(x).source.run(sink, scheduler)
}

Outer.prototype.end = function (t, x) {
  this.active = false;
  tryDispose(t, this.disposable, this.sink);
  this._checkEnd(t, x);
};

Outer.prototype.error = function (t, e) {
  this.active = false;
  this.sink.error(t, e);
};

Outer.prototype.dispose = function () {
  this.active = false;
  this.pending.length = 0;
  return Promise.all([this.disposable.dispose(), this.current.dispose()])
};

Outer.prototype._endInner = function (t, x, inner) {
  this.current.remove(inner);
  tryDispose(t, inner, this);

  if (this.pending.length === 0) {
    this._checkEnd(t, x);
  } else {
    this._startInner(t, this.pending.shift());
  }
};

Outer.prototype._checkEnd = function (t, x) {
  if (!this.active && this.current.isEmpty()) {
    this.sink.end(t, x);
  }
};

function Inner (time, outer, sink) {
  this.prev = this.next = null;
  this.time = time;
  this.outer = outer;
  this.sink = sink;
  this.disposable = void 0;
}

Inner.prototype.event = function (t, x) {
  this.sink.event(Math.max(t, this.time), x);
};

Inner.prototype.end = function (t, x) {
  this.outer._endInner(Math.max(t, this.time), x, this);
};

Inner.prototype.error = function (t, e) {
  this.outer.error(Math.max(t, this.time), e);
};

Inner.prototype.dispose = function () {
  return this.disposable.dispose()
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Map each value in the stream to a new stream, and merge it into the
 * returned outer stream. Event arrival times are preserved.
 * @param {function(x:*):Stream} f chaining function, must return a Stream
 * @param {Stream} stream
 * @returns {Stream} new stream containing all events from each stream returned by f
 */
function flatMap (f, stream) {
  return mergeMapConcurrently(f, Infinity, stream)
}

/**
 * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner
 * streams to the outer. Event arrival times are preserved.
 * @param {Stream<Stream<X>>} stream stream of streams
 * @returns {Stream<X>} new stream containing all events of all inner streams
 */
function join (stream) {
  return mergeConcurrently(Infinity, stream)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Map each value in stream to a new stream, and concatenate them all
 * stream:              -a---b---cX
 * f(a):                 1-1-1-1X
 * f(b):                        -2-2-2-2X
 * f(c):                                -3-3-3-3X
 * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X
 * @param {function(x:*):Stream} f function to map each value to a stream
 * @param {Stream} stream
 * @returns {Stream} new stream containing all events from each stream returned by f
 */
function concatMap (f, stream) {
  return mergeMapConcurrently(f, 1, stream)
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var copy$1 = copy;
var reduce$2 = reduce;

/**
 * @returns {Stream} stream containing events from all streams in the argument
 * list in time order.  If two events are simultaneous they will be merged in
 * arbitrary order.
 */
function merge (/* ...streams*/) {
  return mergeArray(copy$1(arguments))
}

/**
 * @param {Array} streams array of stream to merge
 * @returns {Stream} stream containing events from all input observables
 * in time order.  If two events are simultaneous they will be merged in
 * arbitrary order.
 */
function mergeArray (streams) {
  var l = streams.length;
  return l === 0 ? empty$$1()
    : l === 1 ? streams[0]
    : new Stream(mergeSources(streams))
}

/**
 * This implements fusion/flattening for merge.  It will
 * fuse adjacent merge operations.  For example:
 * - a.merge(b).merge(c) effectively becomes merge(a, b, c)
 * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)
 * It does this by concatenating the sources arrays of
 * any nested Merge sources, in effect "flattening" nested
 * merge operations into a single merge.
 */
function mergeSources (streams) {
  return new Merge(reduce$2(appendSources, [], streams))
}

function appendSources (sources, stream) {
  var source = stream.source;
  return source instanceof Merge
    ? sources.concat(source.sources)
    : sources.concat(source)
}

function Merge (sources) {
  this.sources = sources;
}

Merge.prototype.run = function (sink, scheduler) {
  var this$1 = this;

  var l = this.sources.length;
  var disposables = new Array(l);
  var sinks = new Array(l);

  var mergeSink = new MergeSink(disposables, sinks, sink);

  for (var indexSink, i = 0; i < l; ++i) {
    indexSink = sinks[i] = new IndexSink(i, mergeSink);
    disposables[i] = this$1.sources[i].run(indexSink, scheduler);
  }

  return all(disposables)
};

function MergeSink (disposables, sinks, sink) {
  this.sink = sink;
  this.disposables = disposables;
  this.activeCount = sinks.length;
}

MergeSink.prototype.error = Pipe.prototype.error;

MergeSink.prototype.event = function (t, indexValue) {
  this.sink.event(t, indexValue.value);
};

MergeSink.prototype.end = function (t, indexedValue) {
  tryDispose(t, this.disposables[indexedValue.index], this.sink);
  if (--this.activeCount === 0) {
    this.sink.end(t, indexedValue.value);
  }
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * When an event arrives on sampler, emit the result of calling f with the latest
 * values of all streams being sampled
 * @param {function(...values):*} f function to apply to each set of sampled values
 * @param {Stream} sampler streams will be sampled whenever an event arrives
 *  on sampler
 * @returns {Stream} stream of sampled and transformed values
 */
function sample (f, sampler /*, ...streams */) {
  return sampleArray(f, sampler, drop(2, arguments))
}

/**
 * When an event arrives on sampler, emit the latest event value from stream.
 * @param {Stream} sampler stream of events at whose arrival time
 *  stream's latest value will be propagated
 * @param {Stream} stream stream of values
 * @returns {Stream} sampled stream of values
 */
function sampleWith (sampler, stream) {
  return new Stream(new Sampler(id, sampler.source, [stream.source]))
}

function sampleArray (f, sampler, streams) {
  return new Stream(new Sampler(f, sampler.source, map(getSource$1, streams)))
}

function getSource$1 (stream) {
  return stream.source
}

function Sampler (f, sampler, sources) {
  this.f = f;
  this.sampler = sampler;
  this.sources = sources;
}

Sampler.prototype.run = function (sink, scheduler) {
  var this$1 = this;

  var l = this.sources.length;
  var disposables = new Array(l + 1);
  var sinks = new Array(l);

  var sampleSink = new SampleSink(this.f, sinks, sink);

  for (var hold, i = 0; i < l; ++i) {
    hold = sinks[i] = new Hold(sampleSink);
    disposables[i] = this$1.sources[i].run(hold, scheduler);
  }

  disposables[i] = this.sampler.run(sampleSink, scheduler);

  return all(disposables)
};

function Hold (sink) {
  this.sink = sink;
  this.hasValue = false;
}

Hold.prototype.event = function (t, x) {
  this.value = x;
  this.hasValue = true;
  this.sink._notify(this);
};

Hold.prototype.end = function () {};
Hold.prototype.error = Pipe.prototype.error;

function SampleSink (f, sinks, sink) {
  this.f = f;
  this.sinks = sinks;
  this.sink = sink;
  this.active = false;
}

SampleSink.prototype._notify = function () {
  if (!this.active) {
    this.active = this.sinks.every(hasValue);
  }
};

SampleSink.prototype.event = function (t) {
  if (this.active) {
    this.sink.event(t, invoke(this.f, map(getValue, this.sinks)));
  }
};

SampleSink.prototype.end = Pipe.prototype.end;
SampleSink.prototype.error = Pipe.prototype.error;

function hasValue (hold) {
  return hold.hasValue
}

function getValue (hold) {
  return hold.value
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

// Based on https://github.com/petkaantonov/deque

function Queue (capPow2) {
  this._capacity = capPow2 || 32;
  this._length = 0;
  this._head = 0;
}

Queue.prototype.push = function (x) {
  var len = this._length;
  this._checkCapacity(len + 1);

  var i = (this._head + len) & (this._capacity - 1);
  this[i] = x;
  this._length = len + 1;
};

Queue.prototype.shift = function () {
  var head = this._head;
  var x = this[head];

  this[head] = void 0;
  this._head = (head + 1) & (this._capacity - 1);
  this._length--;
  return x
};

Queue.prototype.isEmpty = function () {
  return this._length === 0
};

Queue.prototype.length = function () {
  return this._length
};

Queue.prototype._checkCapacity = function (size) {
  if (this._capacity < size) {
    this._ensureCapacity(this._capacity << 1);
  }
};

Queue.prototype._ensureCapacity = function (capacity) {
  var oldCapacity = this._capacity;
  this._capacity = capacity;

  var last = this._head + this._length;

  if (last > oldCapacity) {
    copy$2(this, 0, this, oldCapacity, last & (oldCapacity - 1));
  }
};

function copy$2 (src, srcIndex, dst, dstIndex, len) {
  for (var j = 0; j < len; ++j) {
    dst[j + dstIndex] = src[j + srcIndex];
    src[j + srcIndex] = void 0;
  }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var map$4 = map;
var tail$2 = tail;

/**
 * Combine streams pairwise (or tuple-wise) by index by applying f to values
 * at corresponding indices.  The returned stream ends when any of the input
 * streams ends.
 * @param {function} f function to combine values
 * @returns {Stream} new stream with items at corresponding indices combined
 *  using f
 */
function zip (f /*, ...streams */) {
  return zipArray(f, tail$2(arguments))
}

/**
* Combine streams pairwise (or tuple-wise) by index by applying f to values
* at corresponding indices.  The returned stream ends when any of the input
* streams ends.
* @param {function} f function to combine values
* @param {[Stream]} streams streams to zip using f
* @returns {Stream} new stream with items at corresponding indices combined
*  using f
*/
function zipArray (f, streams) {
  return streams.length === 0 ? empty$$1()
: streams.length === 1 ? map$2(f, streams[0])
: new Stream(new Zip(f, map$4(getSource$2, streams)))
}

function getSource$2 (stream) {
  return stream.source
}

function Zip (f, sources) {
  this.f = f;
  this.sources = sources;
}

Zip.prototype.run = function (sink, scheduler) {
  var this$1 = this;

  var l = this.sources.length;
  var disposables = new Array(l);
  var sinks = new Array(l);
  var buffers = new Array(l);

  var zipSink = new ZipSink(this.f, buffers, sinks, sink);

  for (var indexSink, i = 0; i < l; ++i) {
    buffers[i] = new Queue();
    indexSink = sinks[i] = new IndexSink(i, zipSink);
    disposables[i] = this$1.sources[i].run(indexSink, scheduler);
  }

  return all(disposables)
};

function ZipSink (f, buffers, sinks, sink) {
  this.f = f;
  this.sinks = sinks;
  this.sink = sink;
  this.buffers = buffers;
}

ZipSink.prototype.event = function (t, indexedValue) { // eslint-disable-line complexity
  var buffers = this.buffers;
  var buffer = buffers[indexedValue.index];

  buffer.push(indexedValue.value);

  if (buffer.length() === 1) {
    if (!ready(this.buffers)) {
      return
    }

    emitZipped(this.f, t, buffers, this.sink);

    if (ended(this.buffers, this.sinks)) {
      this.sink.end(t, void 0);
    }
  }
};

ZipSink.prototype.end = function (t, indexedValue) {
  var buffer = this.buffers[indexedValue.index];
  if (buffer.isEmpty()) {
    this.sink.end(t, indexedValue.value);
  }
};

ZipSink.prototype.error = Pipe.prototype.error;

function emitZipped (f, t, buffers, sink) {
  sink.event(t, invoke(f, map$4(head, buffers)));
}

function head (buffer) {
  return buffer.shift()
}

function ended (buffers, sinks) {
  for (var i = 0, l = buffers.length; i < l; ++i) {
    if (buffers[i].isEmpty() && !sinks[i].active) {
      return true
    }
  }
  return false
}

function ready (buffers) {
  for (var i = 0, l = buffers.length; i < l; ++i) {
    if (buffers[i].isEmpty()) {
      return false
    }
  }
  return true
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Given a stream of streams, return a new stream that adopts the behavior
 * of the most recent inner stream.
 * @param {Stream} stream of streams on which to switch
 * @returns {Stream} switching stream
 */
function switchLatest (stream) {
  return new Stream(new Switch(stream.source))
}

function Switch (source) {
  this.source = source;
}

Switch.prototype.run = function (sink, scheduler) {
  var switchSink = new SwitchSink(sink, scheduler);
  return all([switchSink, this.source.run(switchSink, scheduler)])
};

function SwitchSink (sink, scheduler) {
  this.sink = sink;
  this.scheduler = scheduler;
  this.current = null;
  this.ended = false;
}

SwitchSink.prototype.event = function (t, stream) {
  this._disposeCurrent(t); // TODO: capture the result of this dispose
  this.current = new Segment(t, Infinity, this, this.sink);
  this.current.disposable = stream.source.run(this.current, this.scheduler);
};

SwitchSink.prototype.end = function (t, x) {
  this.ended = true;
  this._checkEnd(t, x);
};

SwitchSink.prototype.error = function (t, e) {
  this.ended = true;
  this.sink.error(t, e);
};

SwitchSink.prototype.dispose = function () {
  return this._disposeCurrent(this.scheduler.now())
};

SwitchSink.prototype._disposeCurrent = function (t) {
  if (this.current !== null) {
    return this.current._dispose(t)
  }
};

SwitchSink.prototype._disposeInner = function (t, inner) {
  inner._dispose(t); // TODO: capture the result of this dispose
  if (inner === this.current) {
    this.current = null;
  }
};

SwitchSink.prototype._checkEnd = function (t, x) {
  if (this.ended && this.current === null) {
    this.sink.end(t, x);
  }
};

SwitchSink.prototype._endInner = function (t, x, inner) {
  this._disposeInner(t, inner);
  this._checkEnd(t, x);
};

SwitchSink.prototype._errorInner = function (t, e, inner) {
  this._disposeInner(t, inner);
  this.sink.error(t, e);
};

function Segment (min, max, outer, sink) {
  this.min = min;
  this.max = max;
  this.outer = outer;
  this.sink = sink;
  this.disposable = empty$1();
}

Segment.prototype.event = function (t, x) {
  if (t < this.max) {
    this.sink.event(Math.max(t, this.min), x);
  }
};

Segment.prototype.end = function (t, x) {
  this.outer._endInner(Math.max(t, this.min), x, this);
};

Segment.prototype.error = function (t, e) {
  this.outer._errorInner(Math.max(t, this.min), e, this);
};

Segment.prototype._dispose = function (t) {
  this.max = t;
  tryDispose(t, this.disposable, this.sink);
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Retain only items matching a predicate
 * @param {function(x:*):boolean} p filtering predicate called for each item
 * @param {Stream} stream stream to filter
 * @returns {Stream} stream containing only items for which predicate returns truthy
 */
function filter (p, stream) {
  return new Stream(Filter.create(p, stream.source))
}

/**
 * Skip repeated events, using === to detect duplicates
 * @param {Stream} stream stream from which to omit repeated events
 * @returns {Stream} stream without repeated events
 */
function skipRepeats (stream) {
  return skipRepeatsWith(same, stream)
}

/**
 * Skip repeated events using the provided equals function to detect duplicates
 * @param {function(a:*, b:*):boolean} equals optional function to compare items
 * @param {Stream} stream stream from which to omit repeated events
 * @returns {Stream} stream without repeated events
 */
function skipRepeatsWith (equals, stream) {
  return new Stream(new SkipRepeats(equals, stream.source))
}

function SkipRepeats (equals, source) {
  this.equals = equals;
  this.source = source;
}

SkipRepeats.prototype.run = function (sink, scheduler) {
  return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler)
};

function SkipRepeatsSink (equals, sink) {
  this.equals = equals;
  this.sink = sink;
  this.value = void 0;
  this.init = true;
}

SkipRepeatsSink.prototype.end = Pipe.prototype.end;
SkipRepeatsSink.prototype.error = Pipe.prototype.error;

SkipRepeatsSink.prototype.event = function (t, x) {
  if (this.init) {
    this.init = false;
    this.value = x;
    this.sink.event(t, x);
  } else if (!this.equals(this.value, x)) {
    this.value = x;
    this.sink.event(t, x);
  }
};

function same (a, b) {
  return a === b
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * @param {number} n
 * @param {Stream} stream
 * @returns {Stream} new stream containing only up to the first n items from stream
 */
function take (n, stream) {
  return slice(0, n, stream)
}

/**
 * @param {number} n
 * @param {Stream} stream
 * @returns {Stream} new stream with the first n items removed
 */
function skip (n, stream) {
  return slice(n, Infinity, stream)
}

/**
 * Slice a stream by index. Negative start/end indexes are not supported
 * @param {number} start
 * @param {number} end
 * @param {Stream} stream
 * @returns {Stream} stream containing items where start <= index < end
 */
function slice (start, end, stream) {
  return end <= start ? empty$$1()
    : new Stream(sliceSource(start, end, stream.source))
}

function sliceSource (start, end, source) {
  return source instanceof Map ? commuteMapSlice(start, end, source)
    : source instanceof Slice ? fuseSlice(start, end, source)
    : new Slice(start, end, source)
}

function commuteMapSlice (start, end, source) {
  return Map.create(source.f, sliceSource(start, end, source.source))
}

function fuseSlice (start, end, source) {
  start += source.min;
  end = Math.min(end + source.min, source.max);
  return new Slice(start, end, source.source)
}

function Slice (min, max, source) {
  this.source = source;
  this.min = min;
  this.max = max;
}

Slice.prototype.run = function (sink, scheduler) {
  return new SliceSink(this.min, this.max - this.min, this.source, sink, scheduler)
};

function SliceSink (skip, take, source, sink, scheduler) {
  this.sink = sink;
  this.skip = skip;
  this.take = take;
  this.disposable = once(source.run(this, scheduler));
}

SliceSink.prototype.end = Pipe.prototype.end;
SliceSink.prototype.error = Pipe.prototype.error;

SliceSink.prototype.event = function (t, x) { // eslint-disable-line complexity
  if (this.skip > 0) {
    this.skip -= 1;
    return
  }

  if (this.take === 0) {
    return
  }

  this.take -= 1;
  this.sink.event(t, x);
  if (this.take === 0) {
    this.dispose();
    this.sink.end(t, x);
  }
};

SliceSink.prototype.dispose = function () {
  return this.disposable.dispose()
};

function takeWhile (p, stream) {
  return new Stream(new TakeWhile(p, stream.source))
}

function TakeWhile (p, source) {
  this.p = p;
  this.source = source;
}

TakeWhile.prototype.run = function (sink, scheduler) {
  return new TakeWhileSink(this.p, this.source, sink, scheduler)
};

function TakeWhileSink (p, source, sink, scheduler) {
  this.p = p;
  this.sink = sink;
  this.active = true;
  this.disposable = once(source.run(this, scheduler));
}

TakeWhileSink.prototype.end = Pipe.prototype.end;
TakeWhileSink.prototype.error = Pipe.prototype.error;

TakeWhileSink.prototype.event = function (t, x) {
  if (!this.active) {
    return
  }

  var p = this.p;
  this.active = p(x);
  if (this.active) {
    this.sink.event(t, x);
  } else {
    this.dispose();
    this.sink.end(t, x);
  }
};

TakeWhileSink.prototype.dispose = function () {
  return this.disposable.dispose()
};

function skipWhile (p, stream) {
  return new Stream(new SkipWhile(p, stream.source))
}

function SkipWhile (p, source) {
  this.p = p;
  this.source = source;
}

SkipWhile.prototype.run = function (sink, scheduler) {
  return this.source.run(new SkipWhileSink(this.p, sink), scheduler)
};

function SkipWhileSink (p, sink) {
  this.p = p;
  this.sink = sink;
  this.skipping = true;
}

SkipWhileSink.prototype.end = Pipe.prototype.end;
SkipWhileSink.prototype.error = Pipe.prototype.error;

SkipWhileSink.prototype.event = function (t, x) {
  if (this.skipping) {
    var p = this.p;
    this.skipping = p(x);
    if (this.skipping) {
      return
    }
  }

  this.sink.event(t, x);
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function takeUntil (signal, stream) {
  return new Stream(new Until(signal.source, stream.source))
}

function skipUntil (signal, stream) {
  return new Stream(new Since(signal.source, stream.source))
}

function during (timeWindow, stream) {
  return takeUntil(join(timeWindow), skipUntil(timeWindow, stream))
}

function Until (maxSignal, source) {
  this.maxSignal = maxSignal;
  this.source = source;
}

Until.prototype.run = function (sink, scheduler) {
  var min = new Bound(-Infinity, sink);
  var max = new UpperBound(this.maxSignal, sink, scheduler);
  var disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);

  return all([min, max, disposable])
};

function Since (minSignal, source) {
  this.minSignal = minSignal;
  this.source = source;
}

Since.prototype.run = function (sink, scheduler) {
  var min = new LowerBound(this.minSignal, sink, scheduler);
  var max = new Bound(Infinity, sink);
  var disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);

  return all([min, max, disposable])
};

function Bound (value, sink) {
  this.value = value;
  this.sink = sink;
}

Bound.prototype.error = Pipe.prototype.error;
Bound.prototype.event = noop;
Bound.prototype.end = noop;
Bound.prototype.dispose = noop;

function TimeWindowSink (min, max, sink) {
  this.min = min;
  this.max = max;
  this.sink = sink;
}

TimeWindowSink.prototype.event = function (t, x) {
  if (t >= this.min.value && t < this.max.value) {
    this.sink.event(t, x);
  }
};

TimeWindowSink.prototype.error = Pipe.prototype.error;
TimeWindowSink.prototype.end = Pipe.prototype.end;

function LowerBound (signal, sink, scheduler) {
  this.value = Infinity;
  this.sink = sink;
  this.disposable = signal.run(this, scheduler);
}

LowerBound.prototype.event = function (t /*, x */) {
  if (t < this.value) {
    this.value = t;
  }
};

LowerBound.prototype.end = noop;
LowerBound.prototype.error = Pipe.prototype.error;

LowerBound.prototype.dispose = function () {
  return this.disposable.dispose()
};

function UpperBound (signal, sink, scheduler) {
  this.value = Infinity;
  this.sink = sink;
  this.disposable = signal.run(this, scheduler);
}

UpperBound.prototype.event = function (t, x) {
  if (t < this.value) {
    this.value = t;
    this.sink.end(t, x);
  }
};

UpperBound.prototype.end = noop;
UpperBound.prototype.error = Pipe.prototype.error;

UpperBound.prototype.dispose = function () {
  return this.disposable.dispose()
};

function noop () {}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * @param {Number} delayTime milliseconds to delay each item
 * @param {Stream} stream
 * @returns {Stream} new stream containing the same items, but delayed by ms
 */
function delay (delayTime, stream) {
  return delayTime <= 0 ? stream
    : new Stream(new Delay(delayTime, stream.source))
}

function Delay (dt, source) {
  this.dt = dt;
  this.source = source;
}

Delay.prototype.run = function (sink, scheduler) {
  var delaySink = new DelaySink(this.dt, sink, scheduler);
  return all([delaySink, this.source.run(delaySink, scheduler)])
};

function DelaySink (dt, sink, scheduler) {
  this.dt = dt;
  this.sink = sink;
  this.scheduler = scheduler;
}

DelaySink.prototype.dispose = function () {
  var self = this;
  this.scheduler.cancelAll(function (task) {
    return task.sink === self.sink
  });
};

DelaySink.prototype.event = function (t, x) {
  this.scheduler.delay(this.dt, PropagateTask.event(x, this.sink));
};

DelaySink.prototype.end = function (t, x) {
  this.scheduler.delay(this.dt, PropagateTask.end(x, this.sink));
};

DelaySink.prototype.error = Pipe.prototype.error;

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function timestamp (stream) {
  return new Stream(new Timestamp(stream.source))
}

function Timestamp (source) {
  this.source = source;
}

Timestamp.prototype.run = function (sink, scheduler) {
  return this.source.run(new TimestampSink(sink), scheduler)
};

function TimestampSink (sink) {
  this.sink = sink;
}

TimestampSink.prototype.end = Pipe.prototype.end;
TimestampSink.prototype.error = Pipe.prototype.error;

TimestampSink.prototype.event = function (t, x) {
  this.sink.event(t, { time: t, value: x });
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Limit the rate of events by suppressing events that occur too often
 * @param {Number} period time to suppress events
 * @param {Stream} stream
 * @returns {Stream}
 */
function throttle (period, stream) {
  return new Stream(throttleSource(period, stream.source))
}

function throttleSource (period, source) {
  return source instanceof Map ? commuteMapThrottle(period, source)
    : source instanceof Throttle ? fuseThrottle(period, source)
    : new Throttle(period, source)
}

function commuteMapThrottle (period, source) {
  return Map.create(source.f, throttleSource(period, source.source))
}

function fuseThrottle (period, source) {
  return new Throttle(Math.max(period, source.period), source.source)
}

function Throttle (period, source) {
  this.period = period;
  this.source = source;
}

Throttle.prototype.run = function (sink, scheduler) {
  return this.source.run(new ThrottleSink(this.period, sink), scheduler)
};

function ThrottleSink (period, sink) {
  this.time = 0;
  this.period = period;
  this.sink = sink;
}

ThrottleSink.prototype.event = function (t, x) {
  if (t >= this.time) {
    this.time = t + this.period;
    this.sink.event(t, x);
  }
};

ThrottleSink.prototype.end = Pipe.prototype.end;

ThrottleSink.prototype.error = Pipe.prototype.error;

/**
 * Wait for a burst of events to subside and emit only the last event in the burst
 * @param {Number} period events occuring more frequently than this
 *  will be suppressed
 * @param {Stream} stream stream to debounce
 * @returns {Stream} new debounced stream
 */
function debounce (period, stream) {
  return new Stream(new Debounce(period, stream.source))
}

function Debounce (dt, source) {
  this.dt = dt;
  this.source = source;
}

Debounce.prototype.run = function (sink, scheduler) {
  return new DebounceSink(this.dt, this.source, sink, scheduler)
};

function DebounceSink (dt, source, sink, scheduler) {
  this.dt = dt;
  this.sink = sink;
  this.scheduler = scheduler;
  this.value = void 0;
  this.timer = null;

  var sourceDisposable = source.run(this, scheduler);
  this.disposable = all([this, sourceDisposable]);
}

DebounceSink.prototype.event = function (t, x) {
  this._clearTimer();
  this.value = x;
  this.timer = this.scheduler.delay(this.dt, PropagateTask.event(x, this.sink));
};

DebounceSink.prototype.end = function (t, x) {
  if (this._clearTimer()) {
    this.sink.event(t, this.value);
    this.value = void 0;
  }
  this.sink.end(t, x);
};

DebounceSink.prototype.error = function (t, x) {
  this._clearTimer();
  this.sink.error(t, x);
};

DebounceSink.prototype.dispose = function () {
  this._clearTimer();
};

DebounceSink.prototype._clearTimer = function () {
  if (this.timer === null) {
    return false
  }
  this.timer.dispose();
  this.timer = null;
  return true
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * Create a stream containing only the promise's fulfillment
 * value at the time it fulfills.
 * @param {Promise<T>} p promise
 * @return {Stream<T>} stream containing promise's fulfillment value.
 *  If the promise rejects, the stream will error
 */
function fromPromise (p) {
  return awaitPromises(of(p))
}

/**
 * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.
 * Event order is preserved.
 * @param {Stream<Promise<T>>} stream
 * @return {Stream<T>} stream of fulfillment values.  The stream will
 * error if any promise rejects.
 */
function awaitPromises (stream) {
  return new Stream(new Await(stream.source))
}

function Await (source) {
  this.source = source;
}

Await.prototype.run = function (sink, scheduler) {
  return this.source.run(new AwaitSink(sink, scheduler), scheduler)
};

function AwaitSink (sink, scheduler) {
  this.sink = sink;
  this.scheduler = scheduler;
  this.queue = Promise.resolve();
  var self = this;

	// Pre-create closures, to avoid creating them per event
  this._eventBound = function (x) {
    self.sink.event(self.scheduler.now(), x);
  };

  this._endBound = function (x) {
    self.sink.end(self.scheduler.now(), x);
  };

  this._errorBound = function (e) {
    self.sink.error(self.scheduler.now(), e);
  };
}

AwaitSink.prototype.event = function (t, promise) {
  var self = this;
  this.queue = this.queue.then(function () {
    return self._event(promise)
  }).catch(this._errorBound);
};

AwaitSink.prototype.end = function (t, x) {
  var self = this;
  this.queue = this.queue.then(function () {
    return self._end(x)
  }).catch(this._errorBound);
};

AwaitSink.prototype.error = function (t, e) {
  var self = this;
  // Don't resolve error values, propagate directly
  this.queue = this.queue.then(function () {
    return self._errorBound(e)
  }).catch(fatalError);
};

AwaitSink.prototype._event = function (promise) {
  return promise.then(this._eventBound)
};

AwaitSink.prototype._end = function (x) {
  return Promise.resolve(x).then(this._endBound)
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

function SafeSink (sink) {
  this.sink = sink;
  this.active = true;
}

SafeSink.prototype.event = function (t, x) {
  if (!this.active) {
    return
  }
  this.sink.event(t, x);
};

SafeSink.prototype.end = function (t, x) {
  if (!this.active) {
    return
  }
  this.disable();
  this.sink.end(t, x);
};

SafeSink.prototype.error = function (t, e) {
  this.disable();
  this.sink.error(t, e);
};

SafeSink.prototype.disable = function () {
  this.active = false;
  return this.sink
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * If stream encounters an error, recover and continue with items from stream
 * returned by f.
 * @param {function(error:*):Stream} f function which returns a new stream
 * @param {Stream} stream
 * @returns {Stream} new stream which will recover from an error by calling f
 */
function recoverWith (f, stream) {
  return new Stream(new RecoverWith(f, stream.source))
}

var flatMapError = recoverWith;

/**
 * Create a stream containing only an error
 * @param {*} e error value, preferably an Error or Error subtype
 * @returns {Stream} new stream containing only an error
 */
function throwError (e) {
  return new Stream(new ErrorSource(e))
}

function ErrorSource (e) {
  this.value = e;
}

ErrorSource.prototype.run = function (sink, scheduler) {
  return scheduler.asap(new PropagateTask(runError, this.value, sink))
};

function runError (t, e, sink) {
  sink.error(t, e);
}

function RecoverWith (f, source) {
  this.f = f;
  this.source = source;
}

RecoverWith.prototype.run = function (sink, scheduler) {
  return new RecoverWithSink(this.f, this.source, sink, scheduler)
};

function RecoverWithSink (f, source, sink, scheduler) {
  this.f = f;
  this.sink = new SafeSink(sink);
  this.scheduler = scheduler;
  this.disposable = source.run(this, scheduler);
}

RecoverWithSink.prototype.event = function (t, x) {
  tryEvent(t, x, this.sink);
};

RecoverWithSink.prototype.end = function (t, x) {
  tryEnd(t, x, this.sink);
};

RecoverWithSink.prototype.error = function (t, e) {
  var nextSink = this.sink.disable();

  tryDispose(t, this.disposable, this.sink);
  this._startNext(t, e, nextSink);
};

RecoverWithSink.prototype._startNext = function (t, x, sink) {
  try {
    this.disposable = this._continue(this.f, x, sink);
  } catch (e) {
    sink.error(t, e);
  }
};

RecoverWithSink.prototype._continue = function (f, x, sink) {
  var stream = f(x);
  return stream.source.run(sink, this.scheduler)
};

RecoverWithSink.prototype.dispose = function () {
  return this.disposable.dispose()
};

var MulticastDisposable = function MulticastDisposable (source, sink) {
  this.source = source;
  this.sink = sink;
  this.disposed = false;
};

MulticastDisposable.prototype.dispose = function dispose () {
  if (this.disposed) {
    return
  }
  this.disposed = true;
  var remaining = this.source.remove(this.sink);
  return remaining === 0 && this.source._dispose()
};

function tryEvent$1 (t, x, sink) {
  try {
    sink.event(t, x);
  } catch (e) {
    sink.error(t, e);
  }
}

function tryEnd$1 (t, x, sink) {
  try {
    sink.end(t, x);
  } catch (e) {
    sink.error(t, e);
  }
}

var dispose$1$1 = function (disposable) { return disposable.dispose(); };

var emptyDisposable = {
  dispose: function dispose$1 () {}
};

var MulticastSource = function MulticastSource (source) {
  this.source = source;
  this.sinks = [];
  this._disposable = emptyDisposable;
};

MulticastSource.prototype.run = function run (sink, scheduler) {
  var n = this.add(sink);
  if (n === 1) {
    this._disposable = this.source.run(this, scheduler);
  }
  return new MulticastDisposable(this, sink)
};

MulticastSource.prototype._dispose = function _dispose () {
  var disposable = this._disposable;
  this._disposable = emptyDisposable;
  return Promise.resolve(disposable).then(dispose$1$1)
};

MulticastSource.prototype.add = function add (sink) {
  this.sinks = append(sink, this.sinks);
  return this.sinks.length
};

MulticastSource.prototype.remove = function remove$1 (sink) {
  var i = findIndex(sink, this.sinks);
  // istanbul ignore next
  if (i >= 0) {
    this.sinks = remove(i, this.sinks);
  }

  return this.sinks.length
};

MulticastSource.prototype.event = function event (time, value) {
  var s = this.sinks;
  if (s.length === 1) {
    return s[0].event(time, value)
  }
  for (var i = 0; i < s.length; ++i) {
    tryEvent$1(time, value, s[i]);
  }
};

MulticastSource.prototype.end = function end (time, value) {
  var s = this.sinks;
  for (var i = 0; i < s.length; ++i) {
    tryEnd$1(time, value, s[i]);
  }
};

MulticastSource.prototype.error = function error (time, err) {
  var s = this.sinks;
  for (var i = 0; i < s.length; ++i) {
    s[i].error(time, err);
  }
};

function multicast (stream) {
  var source = stream.source;
  return source instanceof MulticastSource
    ? stream
    : new stream.constructor(new MulticastSource(source))
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

// Add of and empty to constructor for fantasy-land compat
Stream.of = of;
Stream.empty = empty$$1;
// Add from to constructor for ES Observable compat
Stream.from = from;
// -----------------------------------------------------------------------
// Draft ES Observable proposal interop
// https://github.com/zenparsing/es-observable

Stream.prototype.subscribe = function (subscriber) {
  return subscribe(subscriber, this)
};

Stream.prototype[result] = function () {
  return this
};

// -----------------------------------------------------------------------
// Fluent adapter

/**
 * Adapt a functional stream transform to fluent style.
 * It applies f to the this stream object
 * @param  {function(s: Stream): Stream} f function that
 * receives the stream itself and must return a new stream
 * @return {Stream}
 */
Stream.prototype.thru = function (f) {
  return thru(f, this)
};

// -----------------------------------------------------------------------
// Observing

/**
 * Process all the events in the stream
 * @returns {Promise} promise that fulfills when the stream ends, or rejects
 *  if the stream fails with an unhandled error.
 */
Stream.prototype.observe = Stream.prototype.forEach = function (f) {
  return observe(f, this)
};

/**
 * Consume all events in the stream, without providing a function to process each.
 * This causes a stream to become active and begin emitting events, and is useful
 * in cases where all processing has been setup upstream via other combinators, and
 * there is no need to process the terminal events.
 * @returns {Promise} promise that fulfills when the stream ends, or rejects
 *  if the stream fails with an unhandled error.
 */
Stream.prototype.drain = function () {
  return drain(this)
};

// -------------------------------------------------------

/**
 * Generalized feedback loop. Call a stepper function for each event. The stepper
 * will be called with 2 params: the current seed and the an event value.  It must
 * return a new { seed, value } pair. The `seed` will be fed back into the next
 * invocation of stepper, and the `value` will be propagated as the event value.
 * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function
 * @param {*} seed initial seed value passed to first stepper call
 * @returns {Stream} new stream whose values are the `value` field of the objects
 * returned by the stepper
 */
Stream.prototype.loop = function (stepper, seed) {
  return loop(stepper, seed, this)
};

// -------------------------------------------------------

/**
 * Create a stream containing successive reduce results of applying f to
 * the previous reduce result and the current stream item.
 * @param {function(result:*, x:*):*} f reducer function
 * @param {*} initial initial value
 * @returns {Stream} new stream containing successive reduce results
 */
Stream.prototype.scan = function (f, initial) {
  return scan(f, initial, this)
};

/**
 * Reduce the stream to produce a single result.  Note that reducing an infinite
 * stream will return a Promise that never fulfills, but that may reject if an error
 * occurs.
 * @param {function(result:*, x:*):*} f reducer function
 * @param {*} initial optional initial value
 * @returns {Promise} promise for the file result of the reduce
 */
Stream.prototype.reduce = function (f, initial) {
  return reduce$1(f, initial, this)
};

/**
 * @param {Stream} tail
 * @returns {Stream} new stream containing all items in this followed by
 *  all items in tail
 */
Stream.prototype.concat = function (tail$$1) {
  return concat(this, tail$$1)
};

/**
 * @param {*} x value to prepend
 * @returns {Stream} a new stream with x prepended
 */
Stream.prototype.startWith = function (x) {
  return cons$1(x, this)
};

// -----------------------------------------------------------------------
// Transforming

/**
 * Transform each value in the stream by applying f to each
 * @param {function(*):*} f mapping function
 * @returns {Stream} stream containing items transformed by f
 */
Stream.prototype.map = function (f) {
  return map$2(f, this)
};

/**
 * Assume this stream contains functions, and apply each function to each item
 * in the provided stream.  This generates, in effect, a cross product.
 * @param {Stream} xs stream of items to which
 * @returns {Stream} stream containing the cross product of items
 */
Stream.prototype.ap = function (xs) {
  return ap(this, xs)
};

/**
 * Replace each value in the stream with x
 * @param {*} x
 * @returns {Stream} stream containing items replaced with x
 */
Stream.prototype.constant = function (x) {
  return constant(x, this)
};

/**
 * Perform a side effect for each item in the stream
 * @param {function(x:*):*} f side effect to execute for each item. The
 *  return value will be discarded.
 * @returns {Stream} new stream containing the same items as this stream
 */
Stream.prototype.tap = function (f) {
  return tap(f, this)
};

// -----------------------------------------------------------------------
// Transducer support

/**
 * Transform this stream by passing its events through a transducer.
 * @param  {function} transducer transducer function
 * @return {Stream} stream of events transformed by the transducer
 */
Stream.prototype.transduce = function (transducer) {
  return transduce(transducer, this)
};

// -----------------------------------------------------------------------
// FlatMapping

/**
 * Map each value in the stream to a new stream, and merge it into the
 * returned outer stream. Event arrival times are preserved.
 * @param {function(x:*):Stream} f chaining function, must return a Stream
 * @returns {Stream} new stream containing all events from each stream returned by f
 */
Stream.prototype.flatMap = Stream.prototype.chain = function (f) {
  return flatMap(f, this)
};

/**
 * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner
 * streams to the outer. Event arrival times are preserved.
 * @returns {Stream<X>} new stream containing all events of all inner streams
 */
Stream.prototype.join = function () {
  return join(this)
};

/**
 * Map the end event to a new stream, and begin emitting its values.
 * @param {function(x:*):Stream} f function that receives the end event value,
 * and *must* return a new Stream to continue with.
 * @returns {Stream} new stream that emits all events from the original stream,
 * followed by all events from the stream returned by f.
 */
Stream.prototype.continueWith = Stream.prototype.flatMapEnd = function (f) {
  return continueWith(f, this)
};

Stream.prototype.concatMap = function (f) {
  return concatMap(f, this)
};

// -----------------------------------------------------------------------
// Concurrent merging

/**
 * Flatten a Stream<Stream<X>> to Stream<X> by merging inner
 * streams to the outer, limiting the number of inner streams that may
 * be active concurrently.
 * @param {number} concurrency at most this many inner streams will be
 *  allowed to be active concurrently.
 * @return {Stream<X>} new stream containing all events of all inner
 *  streams, with limited concurrency.
 */
Stream.prototype.mergeConcurrently = function (concurrency) {
  return mergeConcurrently(concurrency, this)
};

// -----------------------------------------------------------------------
// Merging

/**
 * Merge this stream and all the provided streams
 * @returns {Stream} stream containing items from this stream and s in time
 * order.  If two events are simultaneous they will be merged in
 * arbitrary order.
 */
Stream.prototype.merge = function (/* ...streams*/) {
  return mergeArray(cons(this, arguments))
};

// -----------------------------------------------------------------------
// Combining

/**
 * Combine latest events from all input streams
 * @param {function(...events):*} f function to combine most recent events
 * @returns {Stream} stream containing the result of applying f to the most recent
 *  event of each input stream, whenever a new event arrives on any stream.
 */
Stream.prototype.combine = function (f /*, ...streams*/) {
  return combineArray(f, replace(this, 0, arguments))
};

// -----------------------------------------------------------------------
// Sampling

/**
 * When an event arrives on sampler, emit the latest event value from stream.
 * @param {Stream} sampler stream of events at whose arrival time
 *  signal's latest value will be propagated
 * @returns {Stream} sampled stream of values
 */
Stream.prototype.sampleWith = function (sampler) {
  return sampleWith(sampler, this)
};

/**
 * When an event arrives on this stream, emit the result of calling f with the latest
 * values of all streams being sampled
 * @param {function(...values):*} f function to apply to each set of sampled values
 * @returns {Stream} stream of sampled and transformed values
 */
Stream.prototype.sample = function (f /* ...streams */) {
  return sampleArray(f, this, tail(arguments))
};

// -----------------------------------------------------------------------
// Zipping

/**
 * Pair-wise combine items with those in s. Given 2 streams:
 * [1,2,3] zipWith f [4,5,6] -> [f(1,4),f(2,5),f(3,6)]
 * Note: zip causes fast streams to buffer and wait for slow streams.
 * @param {function(a:Stream, b:Stream, ...):*} f function to combine items
 * @returns {Stream} new stream containing pairs
 */
Stream.prototype.zip = function (f /*, ...streams*/) {
  return zipArray(f, replace(this, 0, arguments))
};

// -----------------------------------------------------------------------
// Switching

/**
 * Given a stream of streams, return a new stream that adopts the behavior
 * of the most recent inner stream.
 * @returns {Stream} switching stream
 */
Stream.prototype.switch = Stream.prototype.switchLatest = function () {
  return switchLatest(this)
};

// -----------------------------------------------------------------------
// Filtering

/**
 * Retain only items matching a predicate
 * stream:                           -12345678-
 * filter(x => x % 2 === 0, stream): --2-4-6-8-
 * @param {function(x:*):boolean} p filtering predicate called for each item
 * @returns {Stream} stream containing only items for which predicate returns truthy
 */
Stream.prototype.filter = function (p) {
  return filter(p, this)
};

/**
 * Skip repeated events, using === to compare items
 * stream:           -abbcd-
 * distinct(stream): -ab-cd-
 * @returns {Stream} stream with no repeated events
 */
Stream.prototype.skipRepeats = function () {
  return skipRepeats(this)
};

/**
 * Skip repeated events, using supplied equals function to compare items
 * @param {function(a:*, b:*):boolean} equals function to compare items
 * @returns {Stream} stream with no repeated events
 */
Stream.prototype.skipRepeatsWith = function (equals) {
  return skipRepeatsWith(equals, this)
};

// -----------------------------------------------------------------------
// Slicing

/**
 * stream:          -abcd-
 * take(2, stream): -ab|
 * @param {Number} n take up to this many events
 * @returns {Stream} stream containing at most the first n items from this stream
 */
Stream.prototype.take = function (n) {
  return take(n, this)
};

/**
 * stream:          -abcd->
 * skip(2, stream): ---cd->
 * @param {Number} n skip this many events
 * @returns {Stream} stream not containing the first n events
 */
Stream.prototype.skip = function (n) {
  return skip(n, this)
};

/**
 * Slice a stream by event index. Equivalent to, but more efficient than
 * stream.take(end).skip(start);
 * NOTE: Negative start and end are not supported
 * @param {Number} start skip all events before the start index
 * @param {Number} end allow all events from the start index to the end index
 * @returns {Stream} stream containing items where start <= index < end
 */
Stream.prototype.slice = function (start, end) {
  return slice(start, end, this)
};

/**
 * stream:                        -123451234->
 * takeWhile(x => x < 5, stream): -1234|
 * @param {function(x:*):boolean} p predicate
 * @returns {Stream} stream containing items up to, but not including, the
 * first item for which p returns falsy.
 */
Stream.prototype.takeWhile = function (p) {
  return takeWhile(p, this)
};

/**
 * stream:                        -123451234->
 * skipWhile(x => x < 5, stream): -----51234->
 * @param {function(x:*):boolean} p predicate
 * @returns {Stream} stream containing items following *and including* the
 * first item for which p returns falsy.
 */
Stream.prototype.skipWhile = function (p) {
  return skipWhile(p, this)
};

// -----------------------------------------------------------------------
// Time slicing

/**
 * stream:                    -a-b-c-d-e-f-g->
 * signal:                    -------x
 * takeUntil(signal, stream): -a-b-c-|
 * @param {Stream} signal retain only events in stream before the first
 * event in signal
 * @returns {Stream} new stream containing only events that occur before
 * the first event in signal.
 */
Stream.prototype.until = Stream.prototype.takeUntil = function (signal) {
  return takeUntil(signal, this)
};

/**
 * stream:                    -a-b-c-d-e-f-g->
 * signal:                    -------x
 * takeUntil(signal, stream): -------d-e-f-g->
 * @param {Stream} signal retain only events in stream at or after the first
 * event in signal
 * @returns {Stream} new stream containing only events that occur after
 * the first event in signal.
 */
Stream.prototype.since = Stream.prototype.skipUntil = function (signal) {
  return skipUntil(signal, this)
};

/**
 * stream:                    -a-b-c-d-e-f-g->
 * timeWindow:                -----s
 * s:                               -----t
 * stream.during(timeWindow): -----c-d-e-|
 * @param {Stream<Stream>} timeWindow a stream whose first event (s) represents
 *  the window start time.  That event (s) is itself a stream whose first event (t)
 *  represents the window end time
 * @returns {Stream} new stream containing only events within the provided timespan
 */
Stream.prototype.during = function (timeWindow) {
  return during(timeWindow, this)
};

// -----------------------------------------------------------------------
// Delaying

/**
 * @param {Number} delayTime milliseconds to delay each item
 * @returns {Stream} new stream containing the same items, but delayed by ms
 */
Stream.prototype.delay = function (delayTime) {
  return delay(delayTime, this)
};

// -----------------------------------------------------------------------
// Getting event timestamp

/**
 * Expose event timestamps into the stream. Turns a Stream<X> into
 * Stream<{time:t, value:X}>
 * @returns {Stream<{time:number, value:*}>}
 */
Stream.prototype.timestamp = function () {
  return timestamp(this)
};

// -----------------------------------------------------------------------
// Rate limiting

/**
 * Limit the rate of events
 * stream:              abcd----abcd----
 * throttle(2, stream): a-c-----a-c-----
 * @param {Number} period time to suppress events
 * @returns {Stream} new stream that skips events for throttle period
 */
Stream.prototype.throttle = function (period) {
  return throttle(period, this)
};

/**
 * Wait for a burst of events to subside and emit only the last event in the burst
 * stream:              abcd----abcd----
 * debounce(2, stream): -----d-------d--
 * @param {Number} period events occuring more frequently than this
 *  on the provided scheduler will be suppressed
 * @returns {Stream} new debounced stream
 */
Stream.prototype.debounce = function (period) {
  return debounce(period, this)
};

// -----------------------------------------------------------------------
// Awaiting Promises

/**
 * Await promises, turning a Stream<Promise<X>> into Stream<X>.  Preserves
 * event order, but timeshifts events based on promise resolution time.
 * @returns {Stream<X>} stream containing non-promise values
 */
Stream.prototype.await = function () {
  return awaitPromises(this)
};

// -----------------------------------------------------------------------
// Error handling

/**
 * If this stream encounters an error, recover and continue with items from stream
 * returned by f.
 * stream:                  -a-b-c-X-
 * f(X):                           d-e-f-g-
 * flatMapError(f, stream): -a-b-c-d-e-f-g-
 * @param {function(error:*):Stream} f function which returns a new stream
 * @returns {Stream} new stream which will recover from an error by calling f
 */
Stream.prototype.recoverWith = Stream.prototype.flatMapError = function (f) {
  return flatMapError(f, this)
};

// -----------------------------------------------------------------------
// Multicasting

/**
 * Transform the stream into multicast stream.  That means that many subscribers
 * to the stream will not cause multiple invocations of the internal machinery.
 * @returns {Stream} new stream which will multicast events to all observers.
 */
Stream.prototype.multicast = function () {
  return multicast(this)
};

// export the instance of the defaultScheduler for third-party libraries
// export an implementation of Task used internally for third-party libraries

exports.Stream = Stream;
exports.of = of;
exports.just = of;
exports.empty = empty$$1;
exports.never = never;
exports.from = from;
exports.periodic = periodic;
exports.observe = observe;
exports.forEach = observe;
exports.drain = drain;
exports.loop = loop;
exports.scan = scan;
exports.reduce = reduce$1;
exports.concat = concat;
exports.startWith = cons$1;
exports.map = map$2;
exports.constant = constant;
exports.tap = tap;
exports.ap = ap;
exports.transduce = transduce;
exports.flatMap = flatMap;
exports.chain = flatMap;
exports.join = join;
exports.continueWith = continueWith;
exports.flatMapEnd = continueWith;
exports.concatMap = concatMap;
exports.mergeConcurrently = mergeConcurrently;
exports.merge = merge;
exports.mergeArray = mergeArray;
exports.combine = combine;
exports.combineArray = combineArray;
exports.sample = sample;
exports.sampleArray = sampleArray;
exports.sampleWith = sampleWith;
exports.zip = zip;
exports.zipArray = zipArray;
exports.switchLatest = switchLatest;
exports.switch = switchLatest;
exports.filter = filter;
exports.skipRepeats = skipRepeats;
exports.distinct = skipRepeats;
exports.skipRepeatsWith = skipRepeatsWith;
exports.distinctBy = skipRepeatsWith;
exports.take = take;
exports.skip = skip;
exports.slice = slice;
exports.takeWhile = takeWhile;
exports.skipWhile = skipWhile;
exports.takeUntil = takeUntil;
exports.until = takeUntil;
exports.skipUntil = skipUntil;
exports.since = skipUntil;
exports.during = during;
exports.delay = delay;
exports.timestamp = timestamp;
exports.throttle = throttle;
exports.debounce = debounce;
exports.fromPromise = fromPromise;
exports.awaitPromises = awaitPromises;
exports.await = awaitPromises;
exports.recoverWith = recoverWith;
exports.flatMapError = flatMapError;
exports.throwError = throwError;
exports.multicast = multicast;
exports.defaultScheduler = defaultScheduler;
exports.PropagateTask = PropagateTask;
exports.fromEvent = fromEvent;
exports.unfold = unfold;
exports.iterate = iterate;
exports.generate = generate;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=most.js.map
</script>
<script>var scope = function (args) {
				args = args || {};
                return  (function (self) {
					
					self .__incoming_memory = riot .observable ();
						self .__incoming_memory .addListener = self .__incoming_memory .on;
						self .__incoming_memory .removeListener = self .__incoming_memory .off;
					
					self .__memory_pathway = {};
					
					self .__incoming_memory_filter = {};
					self .__last_memory = {};
					self .__outgoing_memory_filter = {};
					
					self .__outgoing_knowledge = args .__outgoing_knowledge || riot .observable ();
						self .__outgoing_knowledge .addListener = self .__outgoing_knowledge .on;
						self .__outgoing_knowledge .removeListener = self .__outgoing_knowledge .off;
					
					
					self .parent = function (parent) {
                					    self .__parent = parent;
                					    parent .on ('*', function (what, how) {
											if (! self .__memory_pathway [what]) {
	                					    	self .__outgoing_knowledge .trigger (what, how);
											}
                					    });
                					};
					if (args .parent)
						self .parent (args .parent);
					
					
					//do i need to add lifecycle (sth) here to prevent memory leak? prolly not
					self .connects =	function (what, pathway) {
											var incoming_memories = most .fromEvent (what, self .__incoming_memory);
											self .__memory_pathway [what] = pathway (incoming_memories);
											self .__memory_pathway [what] .observe (function (how_it_really_is) {
												self.__outgoing_knowledge .trigger (what, how_it_really_is);
											});
											if ((pathway .filter || {}) .__incoming_memory_filter)
												self .__incoming_memory_filter [what] = pathway .filter .__incoming_memory_filter;
											if ((pathway .filter || {}) .__outgoing_memory_filter)
												self .__outgoing_memory_filter [what] = pathway .filter .__outgoing_memory_filter;
										};
					self .remembers =	function (what) {
											self .connects (what, function (incoming_memories) {
												return incoming_memories;
											});
										};
					self .disconnect =	function (what) {
											self .__incoming_memory .off (what);
											self .__outgoing_knowledge .off (what);
											delete self .__incoming_memory_filter [what];
											delete self .__memory_pathway [what];
											delete self .__outgoing_memory_filter [what];
											delete self .__last_memory [what];
										};
					self .recalls =	function (what) {
    										if (self .__memory_pathway [what])
    											return (self .__outgoing_memory_filter [what] || function (how) { return how; }) (self .__last_memory [what]);
    										else if (self .__parent)
    											return self .__parent .recalls (what);
    									};
					self .emit =   function (what, how) {
										if (self .__memory_pathway [what])
											self .__incoming_memory .trigger (what, how); //IMPORTANT: variadic event values are compressed into array by mostjs. Compress myself explicitly.
										else if (self .__parent)
											self .__parent .emit .apply (this, arguments);
										else if (args .ex_emit) {
											args .ex_emit .apply (this, arguments);
										}
									};
    				if (args .extend) {
    					args .extend .connects = self .connects;
    					args .extend .remembers = self .remembers;
    					args .extend .recalls = self .recalls;
    					args .extend .emit = self .emit;
    				}
    
        							
        			self .on = self .__outgoing_knowledge .on .bind (self .__outgoing_knowledge);
        			self .one = self .__outgoing_knowledge .one .bind (self .__outgoing_knowledge);
        			self .off = self .__outgoing_knowledge .off .bind (self .__outgoing_knowledge);
        			self .addListener = self .__outgoing_knowledge .addListener .bind (self .__outgoing_knowledge);
        			self .removeListener = self .__outgoing_knowledge .removeListener .bind (self .__outgoing_knowledge);
    				if (args .extend && args .extend !== args .__outgoing_knowledge) {
    					args .extend .on = self .on;
    					args .extend .one = self .one;
    					args .extend .off = self .off;
    					args .extend .addListener = self .addListener;
    					args .extend .removeListener = self .removeListener;
    				}
	
	
	
				    self .on ('*', function (what, how) {
						if (self .__memory_pathway [what]) {
							self .__last_memory [what] = (self .__incoming_memory_filter [what] || function (how) { return how; }) (how);
						}
				    });
				    if ((args .on || {}) .new_memory)
					    self .on ('*', function (what, how) {
							if (self .__memory_pathway [what]) {
								args .on .new_memory .apply (this, arguments);
							}
					    });	
				    
				    return self;
                }) ({});
			};	</script>
<script>/*
global log
global riot
global localStorage
global fetch
*/		
			
					
					
	var replace_all =	function (search, replacement) {
							return	function (string) {
									    var target = string;
									    return target .split (search) .join (replacement);
									};
						};
	var index =	function (test) {
					return	function (array) {
								for (var x = 0; x < array .length; x ++) {
								    if (test (array [x])) return x;
								}
								// not found, return fail value
								return -1;
							};
				};
	var push =	function (key, value) {
					return	function (object) {
								object [key] = value;
								return object;
							};
				};
								
								
										
	var without =	function (you) {
						return	function (baby) {
									var i = {};
									for (var key in baby) {
										i [key] = baby [key];
									}
									delete i [you];
									return i;
								};
					};
	var with_ =	function (who, what) {
					return	function (baby) {
								var i = {};
								for (var key in baby) {
									i [key] = baby [key];
								}
								i [who] = what;
								return i;
							};
				};
				
	var parse =	function (json) {
					try {
						return JSON .parse (json);
					}
					catch (e) {
					}
				};
				
								
	var is_picture =	function (url) {
							var ext = url .split ('.') .reverse () [0];
							return ext === 'jpg' || ext === 'png' || ext === 'bmp' || ext === 'gif' || ext === 'jpeg';
						};		
	var not_picture =	function (url) {
							return ! is_picture (url);
						};
								
		var on_next_tick =	function (action) {
								requestAnimationFrame (action);
							};
							
					
    var upload =    function (bin, return__from, self) {
    	



    var url = backend_path + '/upload/';
    	return function (file) {
            var xhr = new XMLHttpRequest();
            upload = xhr.upload;
            xhr.onload = function(e) {
                if (xhr.status == 201 && xhr.readyState == 4) {
                    self .emit (return__from, JSON.parse(xhr.responseText) .links [0] .href);
                }
            };

            xhr.open(
                "POST",
                url
            );
            xhr.setRequestHeader("Cache-Control", "no-cache");
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            xhr.setRequestHeader("Filename", file.name.replace(/[^A-Za-z0-9-_=,.]/g, "_"));
            xhr.setRequestHeader("Size", file.size);
            xhr.setRequestHeader("Bin", bin);
            xhr.send(file);
                    }};		
							
var array_push =	function (thing) {
						return	function (arr) {
									arr = arr ? [] .concat (arr) : [];
									thing = [] .concat (thing);
									return arr .concat (thing);
								};
					};
								
								
var filename =	function (url) {
					return url .split ('/') .reverse () [0];
				};

var each_ref =	function (ref) {
					return	function (ref_changes) {
								return	ref_changes .filter (function (change) {
											return change .add;
										})
										.map (function (change) {
											return change .add;
										});
							};
				};			
var all_refs =	function (ref) {
					var refs = [];
					return	function (ref_changes) {
								return	most .just (refs) .concat (
											ref_changes .tap (function (change) {
												if (change .add)
													refs .concat ([change .add]);
												if (change .remove)
													refs .splice (refs .indexOf (change .remove), 1);
											})
											.map (function () {
												return refs;
											})
										);
							};
				};								
								

								
	
	var rehash = function () { window.location.reload(); };
	
	
										var refs = {};
										var self_ref_expression =	function (self, ref) {
																		refs [ref] = (+ (refs [ref]) || 0) + 1;
																		var ref_id = ref + '__' + refs [ref];
																		
																		var dom;
																		var get_dom =	function () {
																							if (! dom) {
																								dom = self .root .querySelector ('[faux_ref="' + ref_id + '"]');
																								if (dom) {
																									dom .removeAttribute ('faux_ref');
																								}
																							}
																						};
																//log (self);
																		self .on ('mount', function () {
																			get_dom ();
																			self .emit (ref, { add: dom });
																		});
																		self .on ('before-unmount', function () {
																			get_dom ();
																			self .emit (ref, { remove: dom });
																		});
																		self .on ('updated', function () {
																			get_dom ();
																			self .emit (ref, { add: dom });
																			//self .emit (ref, { change: dom });
																		});
																		
																		return ref_id;
																	};

			
			
			
			
			
		
		
		
		has_done =	function (module) {
						return module .done;
					};
		has_not_done =	function (module) {
							return ! module .done;
						};
			
			
			
			
			
			
		
	var remembers =	function (data) {
						return	function (self) {
									for (var name in data) {
										self .remembers (name);
										self .emit (name, data [name]);
									}
								};
					};
	var connects =	function (connections) {
						return	function (self) {
									for (var name in connections) {
										self .connects (name, connections [name]);
									}
								};
					};
var pathway =	function (what) {
						return	function (scope) {
									return	function (incoming_memories) {
												incoming_memories .observe (function (how) {
													scope .emit (what, how);
												});
												return most .fromEvent (what, scope);
											};
								};
					};
				
					
					
var scope_next_known =	function (what) {
							return	function (scope) {
										return	(scope .recalls (what)
													? Promise .resolve (scope .recalls (what))
													: event_next (what) (scope))
									};
						};
					
var event_next =	function (event) {
						return	function (observable) {
									return	new Promise (function (resolve, reject) {
												/*try {*/
													observable .one (event, resolve);
												/*}
												catch (error) {
													reject (error);
												}*/
											});
								};
					};
var eventify =	function (observable) {
					var eventable = Object .create (observable);
					eventable .addListener = eventable .on;
					eventable .removeListener = eventable .off;
					return eventable;
				};
				

var display_errors =	function (data) {
							value ('.error') (data) && alert (value ('.error') (data));
						};
						

var value =	function (/*property_name*/) {
				var property_names = [] .slice .call (arguments);
				return	function (object) {
							var value = object;
							
							for (var property_name of property_names) {
								if (! property_name)
									continue;
								property_name = trim_first_dot (property_name) .replace (/\s/g, '');
								if (! property_name)
									continue;
									
								for (var property_bit of property_name .split ('.') .filter (function (truthy) { return truthy; })) {
									if (! value)
										return value;
									value = value [property_bit];
								}
							}
							
							return value;
						};
			};
			
							var trim_first_dot =	function (string) {//debugger;
														string = string + '';
														if (string [0] === '.')
															return string .slice (1);
														else
															return string;
													};
			
			
var lifecycle =	function (tag) {
					return most .fromEvent ('unmount', tag);
				};
			
					
		var assemble =	function (module_set) {
			                if (module_set) {
	    						var modules = {};
	    						modules .length = 0;
	    						for (var module of module_set) {
	    							modules [module .order] = module;
	    							modules .length ++;
	    						}
	    						return [] .slice .call (modules);
			                }
						};
		var piece =	function (course_set) {
						if (course_set) {
							var courses = {};
							for (var course of course_set) {
								courses [course .id] = course;
							}
							return courses;
						}
					};</script>
<!-- setup -->
<script>/*
Use app
*/
document .addEventListener ('DOMContentLoaded', function () {
	riot .mount ('*');
});
/*
Catch errors
*/
riot .util .tmpl .errorHandler = log .error;/* now riot throws automatically. still catch with log? */
window .onerror =   function (message, source, lineno, colno, error) {
						if ((((message || {}) .srcElement || {}) .outerHTML || {} ) [0] === '<script src="cordova.js') {
							log .error ('does not contain real cordova');
						}
						else if (message && message === "Uncaught TypeError: Cannot read property 'OneSignal' of undefined"
								&& ((source || {}) .indexOf || function () {}) ('/js/use-onesignal.js') !== -1) {
							log .error ('does not contain cordova onesignal');
						}
						else {
							log .error ('error', arguments);
							log .error ('stack', (error || {}) .stack);
						}
					};
/*
Use riot data layer
*/
riot .mixin (
	{
		init:	function () {
					(function (self) {
											var send_event =	function (element) {
																	return	function (what, how) {
																				element .dispatchEvent (
																					new CustomEvent ('emit', { detail: { what: what, how: how }, bubbles: true } )
																				);
																			};
																};
						self .scope =	scope ({
											//be child of riot parent
											parent: (self .parent || {}) .scope,
											//latch onto riot tag
											extend: self,
											__outgoing_knowledge: self,
											//bubble as dom event on uncaptured
											ex_emit: self .root .parentNode && send_event (self .root .parentNode),
											//logging
											on:	{
													new_memory:	function (/*what, how, other args*/) {
														            log ([self] .concat .apply ([] .slice .call (arguments)));
																}
												}
										});
										
						self .my =	function (what, property_name) {
										return value (property_name) (self .recalls (what));
									};
						self .self = self;
						
				        //capturing bubbling events
			        	self .root .addEventListener ('emit', function (event) {
			        		var detail = event .detail;
			        		self .emit (detail .what, detail .how);
			        		event .stopPropagation ();
			        		return false;
			        	}, false);
					}) (this);			
				}
	} );
/*
Polyfill for dom util methods
*/
window .Element && (function (ElementPrototype) {
	ElementPrototype .matchesSelector =	ElementPrototype .matchesSelector 
										|| ElementPrototype .mozMatchesSelector
										|| ElementPrototype .msMatchesSelector
										|| ElementPrototype .oMatchesSelector
										|| ElementPrototype .webkitMatchesSelector
										||	function (selector) {
												var node = this, nodes = (node .parentNode || node .document) .querySelectorAll (selector), i = -1;
										
												while (nodes [++ i] && nodes [i] != node);
										
												return !!nodes[i];
											};
}) (Element. prototype);
















	
var children =  function (el, selector) {
					var selectors      = null,
						children       = null,
						childSelectors = [],
						tempId         = '';
				
					selectors = selector.split(',');
				
					if (!el.id) {
						tempId = '_temp_';
				
						el.id = tempId;
					}
				
					while (selectors.length) {
						childSelectors.push('#' + el.id + ' ' + selectors.pop());
					}
				
					children = document.querySelectorAll(childSelectors.join(', '));
				
					if (tempId) {
						el.removeAttribute('id');
					}
				
					return children;
				};
				
				
				
var child =  function (el, selector) {
	var tempId         = '';

	if (!el.id) {
		tempId = '_temp_';

		el.id = tempId;
	}

	var child = document.querySelectorAll('#' + el.id + ' > ' + selector);

	if (tempId) {
		el.removeAttribute('id');
	}

	return child;
};
var one_child =  function (el, selector) {
	var tempId = '';

	if (!el.id) {
		tempId = '_temp_';

		el.id = tempId;
	}
	var child = document.querySelector('#' + el.id + ' > ' + selector);

	if (tempId) {
		el.removeAttribute('id');
	}

	return child;
};

var closest_parent = function (el, selector) {
						var includeSelf = true;
						var parent = el.parentNode;
					
						if (includeSelf && el.matches(selector)) {
							return el;
						}
					
						while (parent && parent !== document.body) {
							if (parent.matches && parent.matches(selector)) {
								return parent;
							} else if (parent.parentNode) {
								parent = parent.parentNode;
							} else {
								return null;
							}
						}
					
						return null;
					};
					
					
					
					
					
					
var prepend =	function (parent, child) {
					parent .insertBefore (child, parent .firstChild);
				};	
var append =	function (parent, child) {
					parent .insertBefore (child, null);
				};
					
					
					
					
					
					
					
					
					


var swap_nodes =	function (obj1, obj2) {
					    // save the location of obj2
					    var parent2 = obj2.parentNode;
					    var next2 = obj2.nextSibling;
					    // special case for obj1 is the next sibling of obj2
					    if (next2 === obj1) {
					        // just put obj1 before obj2
					        parent2.insertBefore(obj1, obj2);
					    } else {
					        // insert obj2 right before obj1
					        obj1.parentNode.insertBefore(obj2, obj1);
					
					        // now insert obj1 where obj2 was
					        if (next2) {
					            // if there was an element after obj2, then insert obj1 right before that
					            parent2.insertBefore(obj1, next2);
					        } else {
					            // otherwise, just append as last child
					            parent2.appendChild(obj1);
					        }
					    }
					};</script>
<script>/*
global log
global riot
global most
global localStorage
global fetch
*/				
				
var get_cache =	function (key) {
						var data = localStorage .getItem (key);
						return data && (data === 'undefined' ? undefined : JSON .parse (data));
					};
var set_cache =	function (key, value) {
					localStorage .setItem (key, JSON .stringify (value));
				};
				
				
				
var fetcher = riot .observable ();
	fetcher .addListener = fetcher .on;
	fetcher .removeListener = fetcher .off;
var fetch_path =	function (path) {
						return	function (request, response) {
							return	query (path, {
										method: request .method,
										headers: request .headers,
										body: request .body && JSON .stringify (request .body)
									}) .then (function (response_data) {
										var value = eval_response (response, { data: response_data, response: response_data });
								        /*if (request .method === 'GET'
								        		|| request .method === 'local'
											)*/ cache (path, value);
										fetcher .trigger (path, value);
										return value;
									})/* .catch (function (error) {
										log (error);
									})*/;
						};
					};
						var eval_response =	function (response, data) {
												return riot .util .tmpl (response, data);
											};
						var query =	function (path, request) {
										if (request .method === 'local') {
											log ('queryied local', path, request, request .body && (request .body === 'undefined' ? undefined : JSON .parse (request .body)));
											return	Promise .resolve (request .body && (request .body === 'undefined' ? undefined : JSON .parse (request .body)));
										}
										else {
											return	fetch (path, request)
														.then (function (response) {//log (response);
														    return response .json ();
														})
														.then (function (response) {
															log ('queryied network', path, request, response);
															return response;
														});
										}
									};
						var cache =	function (path, value) {
								        if (JSON .stringify (value) !== JSON .stringify (get_cache (path))) {
								        	set_cache (path, value);
								        	return value;
								        }
									};
					
				

var check_out =	function (path, request, response) {
					add_temp (path, request, response);
					resolve_temps ();
				};
					var add_temp =	function (path, request, response) {
											var temps = get_cache (temp_key) || {};
											if (! temps [path]) {
												temps [path] = { request: request, response: response };
												set_cache (temp_key, temps);
											}
										};
					var resolve_temps =	function () {
											var temps = get_cache (temp_key) || {};
											for (var path in temps) {
												if (! resolutions [path]) {
													var request = temps [path] .request;
													var response = temps [path] .response;
													resolutions [path] =	fetch_path (path) (request, response) .then (
																				remove_temp .bind (this, path)
																			);
												}
											};
										};
					var remove_temp =	function (path) {
												var temps = get_cache (temp_key) || {};
												if (temps [path]) {
													delete temps [path];
													delete resolutions [path];
													set_cache (temp_key, temps);
												}
											};
					var temp_key = '__temp__';
					var resolutions = {};

				
				
var read_path =	function (path) {
						return	function (request, response) {
									return	function () {
												return (function (path) {
													check_out (path, eval_request (request), response);
													return get_cache (path);
												}) (eval_path (path));
											};
								};
					};
var edit_path =	function (path) {
					return	function (request, response, predicter) {
								return	function (data) {
											return (function (path) {
												var value =	predicter (data);
												if (value && JSON .stringify (value) !== JSON .stringify (get_cache (path)))
										        	set_cache (path, value);
													
												check_out (path, eval_request (request, { data: data }), response);
											}) (eval_path (path, { data: data }));
										};
							};
				};
var write_path =	function (path) {
						return	function (request, response) {
									return	function (data) {
												(function (path) {
													check_out (path, eval_request (request, { data: data }), response);
												}) (eval_path (path, { data: data }));
											};
								};
					};
					var eval_path =	function (path, data) {
										return	riot .util .tmpl (path, data);
									};
					var eval_request =	function (request, data) {
											return	{
														method: request .method && riot .util .tmpl (request .method, data),
														headers: request .headers && riot .util .tmpl (request .headers, data),
														body: request .body && riot .util .tmpl (request .body, data)
													};
										};
				
				
				
var reader =	function (path, request, response) {
					request = request || {};
					response = response || '{ data }';
					
					var read = read_path (path) (request .read || {}, response);
					
					var reader =	function (interest) {
										interest .observe (read);
										return most .fromEvent (path, fetcher);
									};
					reader .filter =	{
											__outgoing_memory_filter: read
										};
					
					return reader;
				};
var editer =	function (path, request, response, predicter) {
					request = request || {};
					response = response || '{ data }';
					
					var read = read_path (path) (request .read || {}, response);
					var edit = edit_path (path) (request .edit || {}, response, predicter || function (data) { return undefined; });
					
					var editer =	function (interest) {
										interest .observe (edit);
										return most .fromEvent (path, fetcher);
									}
					editer .filter =	{
											__outgoing_memory_filter: read
										};
					
					return editer;
				};
var writer =	function (path, request, response) {
					request = request || {};

					var write = write_path (path) (request .write || {}, response);
					
					var writer =	function (interest) {
										interest .observe (write);
										return most .fromEvent (path, fetcher);
									};
					writer .filter =	{
											__incoming_memory_filter: function () {}
										};
					
					return writer;
				};
				

				
	
				


var logged_in_header =	function () {
							var login_value = get_cache (backend_path + '/login');
							return login_value && { 'x-user': login_value .id };
						};

if (window .location .protocol !== 'https:') {
	window .location .replace ('https://' + window .location .hostname + window .location .pathname + window .location .hash);
}


var frontend_path = 'https://' + window .location .hostname + '/app';
var backend_path =  'https://' + window .location .hostname + '/api';
				
				
var util = {};
var content = {};


util .register =	writer (backend_path + '/register', {
						write:	{
									method: 'GET',
									headers: '{ { "x-username": data .username, "x-password": data .password } }'
								}
					}, '{ response }');
util .login =	editer (backend_path + '/login', {
					edit:	{
								method: 'GET',
								headers: '{ { "x-username": data .username, "x-password": data .password } }'
							}
				}, '{ response }');
util .logout =	writer (backend_path + '/login', {
					write:	{
								method: 'local',
								body: '{ undefined }'
							}
				}, '{ response }');
util .course_enroll =	function (course_id) {
							return	writer (backend_path + '/course/' + course_id + '/enroll', {
										write:	{
													method: 'GET',
													headers: '{ logged_in_header () }'
												}
									}, '{ response }')
						};
util .component_done =	function (course_id, module_order, component_order) {
							return	writer (backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/' + component_order + '/done', {
										write:	{
													method: 'GET',
													headers: '{ logged_in_header () }'
												}
									}, '{ response }');
						};
						
						
util .course_new =	writer (backend_path + '/my/course/new', {
						write:	{
									method: 'GET',
									headers: '{ with_ ("x-course-category", data .course_category) (with_ ("x-course-name", data .course_name) (with_ ("x-course-description", data .course_description) (logged_in_header ()))) }'
								}
					}, '{ response }');
util .course_delete =	writer (backend_path + '/my/course/delete', {
							write:	{
										method: 'GET',
										headers: '{ with_ ("x-course", data .course_id) (logged_in_header ()) }'
									}
						}, '{ response }');
util .course_publish =	writer (backend_path + '/my/course/publish', {
							write:	{
										method: 'GET',
										headers: '{ with_ ("x-course", data .course_id) (logged_in_header ()) }'
									}
						}, '{ response }');
						
util .module_new =	function (course_id) {
						return	writer (backend_path + '/my/course/' + course_id + '/module/new', {
									write:	{
												method: 'GET',
												headers: '{ with_ ("x-module-name", data .module_name) (logged_in_header ()) }'
											}
								}, '{ response }');
					};	
util .module_reorder =	function (course_id) {
							return	writer (backend_path + '/my/course/' + course_id + '/module/reorder', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-module-1", data .module_1_order) (with_ ("x-module-2", data .module_2_order) (logged_in_header ())) }'
												}
									}, '{ response }');
						};
util .module_delete =	function (course_id) {
							return	writer (backend_path + '/my/course/' + course_id + '/module/delete', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-module", data .module_order) (logged_in_header ()) }'
												}
									}, '{ response }');
						};
						
util .component_new =	function (course_id, module_order) {
							return	writer (backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/new', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-component-videos", data .component_videos) (with_ ("x-component-files", data .component_files) (with_ ("x-component-name", data .component_name) (with_ ("x-component-content", data .component_content) (logged_in_header ())))) }'
												}
									}, '{ response }');
						};	
util .component_reorder =	function (course_id, module_order) {
								return	writer (backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/reorder', {
											write:	{
														method: 'GET',
														headers: '{ with_ ("x-component-1", data .component_1_order) (with_ ("x-component-2", data .component_2_order) (logged_in_header ())) }'
													}
										}, '{ response }');
							};
util .component_delete =	function (course_id, module_order) {
								return	writer (backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/delete', {
											write:	{
														method: 'GET',
														headers: '{ with_ ("x-component", data .component_order) (logged_in_header ()) }'
													}
										}, '{ response }');
							};
util .component_edit =	function (course_id, module_order, component_order) {
							return	writer (backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/' + component_order + '/edit', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-component-videos", data .component_videos) (with_ ("x-component-files", data .component_files) (with_ ("x-component-name", data .component_name) (with_ ("x-component-content", data .component_content) (logged_in_header ())))) }'
												}
									}, '{ response }');
						};	
						
util .user_edit =	function (user_id) {
						return	writer (backend_path + '/user/' + user_id + '/edit', {
									write:	{
												method: 'GET',
												headers: '{ with_ ("x-" + data .edit_type, data .edit_content) (logged_in_header ()) }'
											}
								}, '{ response }');
					};	
						
						
						
						
						
						
content .courses =	reader (backend_path + '/courses', {
						read:	{
									method: 'GET',
									headers: '{ logged_in_header () }'
								}
							
					}, '{ response }');
content .course =	function (course_id) {
						return	reader (backend_path + '/course/' + course_id, {
									read:	{
												method: 'GET',
												headers: '{ logged_in_header () }'
											}
										
								}, '{ response }');
					};
content .my_courses =	reader (backend_path + '/my/courses', {
							read:	{
										method: 'GET',
										headers: '{ logged_in_header () }'
									}
								
						}, '{ response }');
						
content .users =	reader (backend_path + '/users', {
						read:	{
									method: 'GET',
									headers: '{ logged_in_header () }'
								}
							
					}, '{ response }');
content .user =	function (user_id) {
					return	reader (backend_path + '/user/' + user_id, {
								read:	{
											method: 'GET',
											headers: '{ logged_in_header () }'
										}
									
							}, '{ response }');
				};</script>
<script>riot.tag2('body', '', 'html { width: 100% !important; height: 100% !important; } body { width: 100% !important; height: 100% !important; position: relative; } .border { border: 2px solid black; } .cursor-pointer { cursor: pointer; } .title { font-size: 30; text-align: center; color: #101010; } .subtitle1 { text-align: center; font-size: 22px; color: #696969; } .scroll { overflow-x: hidden; overflow-y: scroll !important; } .scroll::-webkit-scrollbar { display: none; } .position-fixed { position: fixed !important; } .position-absolute { position: absolute !important; } .position-relative { position: relative !important; } .full-height { height: 100% !important; } .ninety-five-width { width: 95%; } .most-height { height: 80% !important; } .slider-box-height { height: 100px !important; } .little-height { height: 10% !important; } .most-width { width: 80% !important; } .full-width { width: 100% !important; } .no-frills { padding: 0 !important; } .no-shock { margin: 0 !important; } .match-edge { position: absolute; height: auto; width: auto; display: block; top: 0; bottom: 0; left: 0; right: 0; } .top-down { overflow: hidden; } .text-center { text-align: center; } .text-middle { vertical-align: middle; } .half-height { height: 50%; } .quarter-height { height: 25%; } .block-left { display: block; position: absolute; left: 0%; transform: translatex(0%); -webkit-transform: translatex(0%); } .block-center { display: block; position: absolute; left: 50%; transform: translatex(-50%); -webkit-transform: translatex(-50%); } .block-right { display: block; position: absolute; left: 100%; transform: translatex(-100%); -webkit-transform: translatex(-100%); } .block-top { display: block; position: absolute; top: 0%; transform: translatey(0%); -webkit-transform: translatey(0%); } .block-middle { display: block; position: absolute; top: 50% !important; transform: translatey(-50%); -webkit-transform: translatey(-50%); } .block-bottom { display: block; position: absolute; top: 100%; transform: translatey(-100%); -webkit-transform: translatey(-100%); } .block-left.block-top { top: 0%; left: 0%; transform: translatex(-0%) translatey(-0%); -webkit-transform: translatex(-0%) translatey(-0%); } .block-left.block-middle { top: 50%; left: 0%; transform: translatex(-0%) translatey(-50%); -webkit-transform: translatex(-0%) translatey(-50%); } .block-left.block-bottom { top: 100%; left: 0%; transform: translatex(-0%) translatey(-100%); -webkit-transform: translatex(-0%) translatey(-100%); } .block-center.block-top { top: 0%; left: 50%; transform: translatex(-50%) translatey(0%); -webkit-transform: translatex(-50%) translatey(0%); } .block-center.block-middle { top: 50%; left: 50%; transform: translatex(-50%) translatey(-50%); -webkit-transform: translatex(-50%) translatey(-50%); } .block-center.block-bottom { top: 100%; left: 50%; transform: translatex(-50%) translatey(-100%); -webkit-transform: translatex(-50%) translatey(-100%); } .block-right.block-top { top: 0%; left: 100%; transform: translatex(-100%) translatey(0%); -webkit-transform: translatex(-100%) translatey(0%); } .block-right.block-middle { top: 50%; left: 100%; transform: translatex(-100%) translatey(-50%); -webkit-transform: translatex(-100%) translatey(-50%); } .block-right.block-bottom { top: 100%; left: 100%; transform: translatex(-100%) translatey(-100%); -webkit-transform: translatex(-100%) translatey(-100%); } .nudge-up { padding-bottom: 20px; } .nudge-down { padding-top: 20px; } .nudge-left { padding-right: 20px; } .nudge-right { padding-left: 20px; } .nudge-up-more { padding-bottom: 40px; } .nudge-down-more { padding-top: 40px; } .nudge-left-more { padding-right: 40px; } .nudge-right-more { padding-left: 40px; } .under-half { top: 50%; } .under-bar-44 { top: 44px; } .under-bar-47 { top: 47px; } .above-bar-44 { bottom: 44px; } .above-bar-49 { bottom: 49px; } .under-bar-88 { top: 88px; } .match-me { position: relative !important; height: 100% !important; width: 100% !important; overflow: hidden; } .font-large,.font-large:before,.font-large:after { font-size: 2em !important; } .font-big,.font-big:before,.font-big:after { font-size: 1.5em !important; } .font-somewhat-big,.font-somewhat-big:before,.font-somewhat-big:after { font-size: 1.45em !important; } .font-more,.font-more:before,.font-more:after { font-size: 1.4em !important; } .font-regular,.font-regular:before,.font-regular:after { font-size: 1.2em !important; } .font-small,.font-small:before,.font-small:after { font-size: 0.8em !important; } .font-tiny,.font-tiny:before,font-tiny:after { font-size: 0.2em; line-height: 0.2em; } .neutral-color { color: white; } .sixty-height { height: 60px; } .eighty-height { height: 80px; } .hundred-fifty-height { height: 150px; } .hundred-height { height: 100px; } .prized-asset { min-height: 260px; max-height: 100%; } .free-icon { min-width: none !important; min-height: none !important; max-width: none !important; max-height: none !important; } .free-icon:before,.free-icon:after { width: auto !important; height: auto !important; } .inline { display: inline; } .inline-center { text-align: center; } .inline-left { text-align: left; } .inline-right { text-align: right; } .inline-justify { text-align: justify; } .header-text { white-space: nowrap; } .invisible { visibility: none; } .top-layer { z-index: 999; } .bottom-layer { z-index: -999; } .lax { overflow: visible !important; } .higher { z-index: 1000; } .push-up { margin-top: -10px; } .area-0to100x0to30 { position: absolute; width: 100%; height: 30%; top: 0; left: 0; } .area-0to100x30to60 { position: absolute; width: 100%; height: 30%; top: 30%; left: 0; } .area-0to100x60to100 { position: absolute; width: 100%; height: 40%; top: 60%; left: 0; } .area-0to30x0to100 { position: absolute; width: 30%; height: 100%; top: 0; left: 0; } .area-0to50x0to50 { position: absolute; width: 50%; height: 50%; top: 0; left: 0; } .area-50to85x0to50 { position: absolute; width: 35%; height: 50%; top: 0; left: 50%; } .area-0to60x50to100 { position: absolute; width: 60%; height: 50%; top: 50%; left: 0; } .area-0to20x0to100 { position: absolute; width: 20%; height: 100%; top: 0; left: 0; } .area-20to100x0to100 { position: absolute; width: 80%; height: 100%; top: 0; left: 20%; } .area-0to100x0to50 { position: absolute; width: 100%; height: 50%; top: 0; left: 0; } .area-0to100x50to100 { position: absolute; width: 100%; height: 50%; top: 50%; left: 0; } .area-0to35x0to100 { position: absolute; width: 35%; height: 100%; top: 0; left: 0; } .area-35to55x0to100 { position: absolute; width: 20%; height: 100%; top: 0; left: 35%; } .area-55to100x0to100 { position: absolute; width: 45%; height: 100%; top: 0; left: 55%; } .area-30to100x0to100 { position: absolute; width: 70%; height: 100%; top: 0; left: 30%; } .area-20to80x0to100 { position: absolute; width: 60%; height: 100%; top: 0; left: 20%; } .area-80to100x0to100 { position: absolute; width: 20%; height: 100%; top: 0; left: 80%; } .area-0to40x0to50 { position: absolute; width: 40%; height: 50%; top: 0; left: 0; } .area-40to60x0to50 { position: absolute; width: 20%; height: 50%; top: 0; left: 40%; } .area-60to100x0to50 { position: absolute; width: 40%; height: 50%; top: 0; left: 60%; } .area-0to100x50to100 { position: absolute; width: 100%; height: 50%; top: 50%; left: 0; } .area-0to50x0to100 { position: absolute; width: 50%; height: 100%; top: 0; left: 0; } .area-50to100x0to100 { position: absolute; width: 50%; height: 100%; top: 0; left: 50%; } .area-50to100x0to50 { position: absolute; width: 50%; height: 50%; top: 0; left: 50%; } .area-0to80x0to100 { position: absolute; width: 80%; height: 100%; top: 0; left: 0; } .area-0to25x0to100 { position: absolute; width: 25%; height: 100%; top: 0; left: 0; } .area-25to100x0to100 { position: absolute; width: 75%; height: 100%; top: 0; left: 25%; } .area-0to100x0to60 { position: absolute; width: 100%; height: 60%; top: 0; left: 0; } .area-0to100x60to100 { position: absolute; width: 100%; height: 40%; top: 60%; left: 0; } .area-0to12x50to100 { position: absolute; width: 12%; height: 50%; top: 50%; left: 0; } .area-12to100x50to100 { position: absolute; width: 88%; height: 50%; top: 50%; left: 12%; } .paragraph-text { white-space: normal !important; word-break: break-all !important; word-wrap: break-word !important; } .fitting-size { max-height: 100%; max-width: 100%; } .text-icons { font-family: Ionicons, icomoon !important; } .minify-slight { -ms-transform: scale(0.99, 0.99); -webkit-transform: scale(0.99, 0.99); transform: scale(0.99, 0.99); } .minify-some { -ms-transform: scale(0.9, 0.9); -webkit-transform: scale(0.9, 0.9); transform: scale(0.9, 0.9); } .inset-more { padding: 15px; } .inset-some { padding: 10px; } .inset-little { padding: 5px; } .inset-slight { padding: 2px; } .outset-quite { margin: 20px; } .outset-little { margin: 5px; } .outset-some { margin: 10px; } .seventy-five-height { height: 75px; } .no-border { border: none !important; } .bold { font-weight: bold; } .background-black { background: black; } .list { will-change: scroll-position; } .background-texture::after { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.1; z-index: -1; background: url(../imgs/3d_soccer15.gif); } .background-transparent { background: transparent; } .background-shadowed { background: rgba(0,0,0,0.1); } .background-double-shadowed { background: rgba(0,0,0,0.2); } .background-translucent { background: rgba(0,0,0,0.03); } .icon-size { width: 1em; height: 1em; text-align: center; } .black-to-gray { -webkit-filter: invert(50%); filter: invert(50%); } .a-block { display: block; } .a-inline-block { display: inline-block; } .square { padding-bottom: 100%; } .square > .match-edge { background-size: cover !important; } .page { margin: 0 !important; } .display-none { display: none; } .dashed { border: 1px #bbb dashed; border-radius: 5px; } @-webkit-keyframes spinAround { from { -webkit-transform: rotate(0deg); transform: rotate(0deg); } to { -webkit-transform: rotate(359deg); transform: rotate(359deg); } } @keyframes spinAround { from { -webkit-transform: rotate(0deg); transform: rotate(0deg); } to { -webkit-transform: rotate(359deg); transform: rotate(359deg); } } html, body, p, ol, ul, li, dl, dt, dd, blockquote, figure, fieldset, legend, textarea, pre, iframe, hr, h1, h2, h3, h4, h5, h6 { margin: 0; padding: 0; } h1, h2, h3, h4, h5, h6 { font-size: 100%; font-weight: normal; } ul { list-style: none; } button, input, select, textarea { margin: 0; } html { box-sizing: border-box; } * { box-sizing: inherit; } *:before, *:after { box-sizing: inherit; } img, embed, object, audio, video { height: auto; max-width: 100%; } iframe { border: 0; } table { border-collapse: collapse; border-spacing: 0; } td, th { padding: 0; text-align: left; } html { background-color: whitesmoke; font-size: 14px; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; min-width: 300px; overflow-x: hidden; overflow-y: scroll; text-rendering: optimizeLegibility; } article, aside, figure, footer, header, hgroup, section { display: block; } body, button, input, select, textarea { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", "Helvetica", "Arial", sans-serif; } code, pre { -moz-osx-font-smoothing: auto; -webkit-font-smoothing: auto; font-family: "Inconsolata", "Consolas", "Monaco", monospace; line-height: 1.25; } body { color: #4a4a4a; font-size: 1rem; font-weight: 400; line-height: 1.428571428571429; } a { color: #00d1b2; cursor: pointer; text-decoration: none; -webkit-transition: none 86ms ease-out; transition: none 86ms ease-out; } a:hover { color: #363636; } code { background-color: whitesmoke; color: #ff3860; font-size: 12px; font-weight: normal; padding: 1px 2px 2px; } hr { background-color: #dbdbdb; border: none; display: block; height: 1px; margin: 20px 0; } img { max-width: 100%; } input[type="checkbox"], input[type="radio"] { vertical-align: baseline; } small { font-size: 11px; } span { font-style: inherit; font-weight: inherit; } strong { color: #363636; font-weight: 700; } pre { background-color: whitesmoke; color: #4a4a4a; white-space: pre; word-wrap: normal; } pre code { background-color: whitesmoke; color: #4a4a4a; display: block; overflow-x: auto; padding: 16px 20px; } table { width: 100%; } table td, table th { text-align: left; vertical-align: top; } table th { color: #363636; } .is-block { display: block; } @media screen and (max-width: 768px) { .is-block-mobile { display: block !important; } } @media screen and (min-width: 769px) { .is-block-tablet { display: block !important; } } @media screen and (min-width: 769px) and (max-width: 979px) { .is-block-tablet-only { display: block !important; } } @media screen and (max-width: 979px) { .is-block-touch { display: block !important; } } @media screen and (min-width: 980px) { .is-block-desktop { display: block !important; } } @media screen and (min-width: 980px) and (max-width: 1179px) { .is-block-desktop-only { display: block !important; } } @media screen and (min-width: 1180px) { .is-block-widescreen { display: block !important; } } .is-flex { display: -webkit-box; display: -ms-flexbox; display: flex; } @media screen and (max-width: 768px) { .is-flex-mobile { display: -webkit-box !important; display: -ms-flexbox !important; display: flex !important; } } @media screen and (min-width: 769px) { .is-flex-tablet { display: -webkit-box !important; display: -ms-flexbox !important; display: flex !important; } } @media screen and (min-width: 769px) and (max-width: 979px) { .is-flex-tablet-only { display: -webkit-box !important; display: -ms-flexbox !important; display: flex !important; } } @media screen and (max-width: 979px) { .is-flex-touch { display: -webkit-box !important; display: -ms-flexbox !important; display: flex !important; } } @media screen and (min-width: 980px) { .is-flex-desktop { display: -webkit-box !important; display: -ms-flexbox !important; display: flex !important; } } @media screen and (min-width: 980px) and (max-width: 1179px) { .is-flex-desktop-only { display: -webkit-box !important; display: -ms-flexbox !important; display: flex !important; } } @media screen and (min-width: 1180px) { .is-flex-widescreen { display: -webkit-box !important; display: -ms-flexbox !important; display: flex !important; } } .is-inline { display: inline; } @media screen and (max-width: 768px) { .is-inline-mobile { display: inline !important; } } @media screen and (min-width: 769px) { .is-inline-tablet { display: inline !important; } } @media screen and (min-width: 769px) and (max-width: 979px) { .is-inline-tablet-only { display: inline !important; } } @media screen and (max-width: 979px) { .is-inline-touch { display: inline !important; } } @media screen and (min-width: 980px) { .is-inline-desktop { display: inline !important; } } @media screen and (min-width: 980px) and (max-width: 1179px) { .is-inline-desktop-only { display: inline !important; } } @media screen and (min-width: 1180px) { .is-inline-widescreen { display: inline !important; } } .is-inline-block { display: inline-block; } @media screen and (max-width: 768px) { .is-inline-block-mobile { display: inline-block !important; } } @media screen and (min-width: 769px) { .is-inline-block-tablet { display: inline-block !important; } } @media screen and (min-width: 769px) and (max-width: 979px) { .is-inline-block-tablet-only { display: inline-block !important; } } @media screen and (max-width: 979px) { .is-inline-block-touch { display: inline-block !important; } } @media screen and (min-width: 980px) { .is-inline-block-desktop { display: inline-block !important; } } @media screen and (min-width: 980px) and (max-width: 1179px) { .is-inline-block-desktop-only { display: inline-block !important; } } @media screen and (min-width: 1180px) { .is-inline-block-widescreen { display: inline-block !important; } } .is-inline-flex { display: -webkit-inline-box; display: -ms-inline-flexbox; display: inline-flex; } @media screen and (max-width: 768px) { .is-inline-flex-mobile { display: -webkit-inline-box !important; display: -ms-inline-flexbox !important; display: inline-flex !important; } } @media screen and (min-width: 769px) { .is-inline-flex-tablet { display: -webkit-inline-box !important; display: -ms-inline-flexbox !important; display: inline-flex !important; } } @media screen and (min-width: 769px) and (max-width: 979px) { .is-inline-flex-tablet-only { display: -webkit-inline-box !important; display: -ms-inline-flexbox !important; display: inline-flex !important; } } @media screen and (max-width: 979px) { .is-inline-flex-touch { display: -webkit-inline-box !important; display: -ms-inline-flexbox !important; display: inline-flex !important; } } @media screen and (min-width: 980px) { .is-inline-flex-desktop { display: -webkit-inline-box !important; display: -ms-inline-flexbox !important; display: inline-flex !important; } } @media screen and (min-width: 980px) and (max-width: 1179px) { .is-inline-flex-desktop-only { display: -webkit-inline-box !important; display: -ms-inline-flexbox !important; display: inline-flex !important; } } @media screen and (min-width: 1180px) { .is-inline-flex-widescreen { display: -webkit-inline-box !important; display: -ms-inline-flexbox !important; display: inline-flex !important; } } .is-clearfix:after { clear: both; content: " "; display: table; } .is-pulled-left { float: left; } .is-pulled-right { float: right; } .is-clipped { overflow: hidden !important; } .is-overlay { bottom: 0; left: 0; position: absolute; right: 0; top: 0; } .has-text-centered { text-align: center; } .has-text-left { text-align: left; } .has-text-right { text-align: right; } .is-hidden { display: none !important; } @media screen and (max-width: 768px) { .is-hidden-mobile { display: none !important; } } @media screen and (min-width: 769px) { .is-hidden-tablet { display: none !important; } } @media screen and (min-width: 769px) and (max-width: 979px) { .is-hidden-tablet-only { display: none !important; } } @media screen and (max-width: 979px) { .is-hidden-touch { display: none !important; } } @media screen and (min-width: 980px) { .is-hidden-desktop { display: none !important; } } @media screen and (min-width: 980px) and (max-width: 1179px) { .is-hidden-desktop-only { display: none !important; } } @media screen and (min-width: 1180px) { .is-hidden-widescreen { display: none !important; } } .is-disabled { pointer-events: none; } .is-marginless { margin: 0 !important; } .is-paddingless { padding: 0 !important; } .is-unselectable { -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .box { background-color: white; border-radius: 5px; box-shadow: 0 2px 3px rgba(10, 10, 10, 0.1), 0 0 0 1px rgba(10, 10, 10, 0.1); display: block; padding: 20px; } .box:not(:last-child) { margin-bottom: 20px; } a.box:hover, a.box:focus { box-shadow: 0 2px 3px rgba(10, 10, 10, 0.1), 0 0 0 1px #00d1b2; } a.box:active { box-shadow: inset 0 1px 2px rgba(10, 10, 10, 0.2), 0 0 0 1px #00d1b2; } .button { -moz-appearance: none; -webkit-appearance: none; -webkit-box-align: center; -ms-flex-align: center; align-items: center; background-color: white; border: 1px solid #dbdbdb; border-radius: 3px; color: #363636; display: -webkit-inline-box; display: -ms-inline-flexbox; display: inline-flex; font-size: 14px; height: 32px; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; line-height: 24px; padding-left: 8px; padding-right: 8px; position: relative; vertical-align: top; -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; padding-left: 10px; padding-right: 10px; text-align: center; white-space: nowrap; } .button:hover { border-color: #b5b5b5; } .button:active, .button:focus, .button.is-active { border-color: #00d1b2; outline: none; } .button[disabled], .button.is-disabled { background-color: whitesmoke; border-color: #dbdbdb; cursor: not-allowed; pointer-events: none; } .button[disabled]::-moz-placeholder, .button.is-disabled::-moz-placeholder { color: rgba(54, 54, 54, 0.3); } .button[disabled]::-webkit-input-placeholder, .button.is-disabled::-webkit-input-placeholder { color: rgba(54, 54, 54, 0.3); } .button[disabled]:-moz-placeholder, .button.is-disabled:-moz-placeholder { color: rgba(54, 54, 54, 0.3); } .button[disabled]:-ms-input-placeholder, .button.is-disabled:-ms-input-placeholder { color: rgba(54, 54, 54, 0.3); } .button strong { color: inherit; } .button small { display: block; font-size: 11px; line-height: 1; margin-top: 5px; } .button .icon:first-child, .button .tag:first-child { margin-left: -2px; margin-right: 4px; } .button .icon:last-child, .button .tag:last-child { margin-left: 4px; margin-right: -2px; } .button:hover, .button:focus, .button.is-active { color: #363636; } .button:active { box-shadow: inset 0 1px 2px rgba(10, 10, 10, 0.2); } .button.is-white { background-color: white; border-width: 0; color: #0a0a0a; } .button.is-white:hover, .button.is-white:focus, .button.is-white.is-active { background-color: #f2f2f2; border-color: transparent; color: #0a0a0a; } .button.is-white.is-inverted { background-color: #0a0a0a; color: white; } .button.is-white.is-inverted:hover { background-color: black; } .button.is-white.is-loading:after { border-color: transparent transparent #0a0a0a #0a0a0a !important; } .button.is-white.is-outlined { background-color: transparent; border-color: white; border-width: 1px; color: white; } .button.is-white.is-outlined:hover, .button.is-white.is-outlined:focus { background-color: white; border-color: white; color: #0a0a0a; } .button.is-black { background-color: #0a0a0a; border-width: 0; color: white; } .button.is-black:hover, .button.is-black:focus, .button.is-black.is-active { background-color: black; border-color: transparent; color: white; } .button.is-black.is-inverted { background-color: white; color: #0a0a0a; } .button.is-black.is-inverted:hover { background-color: #f2f2f2; } .button.is-black.is-loading:after { border-color: transparent transparent white white !important; } .button.is-black.is-outlined { background-color: transparent; border-color: #0a0a0a; border-width: 1px; color: #0a0a0a; } .button.is-black.is-outlined:hover, .button.is-black.is-outlined:focus { background-color: #0a0a0a; border-color: #0a0a0a; color: white; } .button.is-light { background-color: whitesmoke; border-width: 0; color: #363636; } .button.is-light:hover, .button.is-light:focus, .button.is-light.is-active { background-color: #e8e8e8; border-color: transparent; color: #363636; } .button.is-light.is-inverted { background-color: #363636; color: whitesmoke; } .button.is-light.is-inverted:hover { background-color: #292929; } .button.is-light.is-loading:after { border-color: transparent transparent #363636 #363636 !important; } .button.is-light.is-outlined { background-color: transparent; border-color: whitesmoke; border-width: 1px; color: whitesmoke; } .button.is-light.is-outlined:hover, .button.is-light.is-outlined:focus { background-color: whitesmoke; border-color: whitesmoke; color: #363636; } .button.is-dark { background-color: #363636; border-width: 0; color: whitesmoke; } .button.is-dark:hover, .button.is-dark:focus, .button.is-dark.is-active { background-color: #292929; border-color: transparent; color: whitesmoke; } .button.is-dark.is-inverted { background-color: whitesmoke; color: #363636; } .button.is-dark.is-inverted:hover { background-color: #e8e8e8; } .button.is-dark.is-loading:after { border-color: transparent transparent whitesmoke whitesmoke !important; } .button.is-dark.is-outlined { background-color: transparent; border-color: #363636; border-width: 1px; color: #363636; } .button.is-dark.is-outlined:hover, .button.is-dark.is-outlined:focus { background-color: #363636; border-color: #363636; color: whitesmoke; } .button.is-primary { background-color: #00d1b2; border-width: 0; color: white; } .button.is-primary:hover, .button.is-primary:focus, .button.is-primary.is-active { background-color: #00b89c; border-color: transparent; color: white; } .button.is-primary.is-inverted { background-color: white; color: #00d1b2; } .button.is-primary.is-inverted:hover { background-color: #f2f2f2; } .button.is-primary.is-loading:after { border-color: transparent transparent white white !important; } .button.is-primary.is-outlined { background-color: transparent; border-color: #00d1b2; border-width: 1px; color: #00d1b2; } .button.is-primary.is-outlined:hover, .button.is-primary.is-outlined:focus { background-color: #00d1b2; border-color: #00d1b2; color: white; } .button.is-info { background-color: #3273dc; border-width: 0; color: white; } .button.is-info:hover, .button.is-info:focus, .button.is-info.is-active { background-color: #2366d1; border-color: transparent; color: white; } .button.is-info.is-inverted { background-color: white; color: #3273dc; } .button.is-info.is-inverted:hover { background-color: #f2f2f2; } .button.is-info.is-loading:after { border-color: transparent transparent white white !important; } .button.is-info.is-outlined { background-color: transparent; border-color: #3273dc; border-width: 1px; color: #3273dc; } .button.is-info.is-outlined:hover, .button.is-info.is-outlined:focus { background-color: #3273dc; border-color: #3273dc; color: white; } .button.is-success { background-color: #23d160; border-width: 0; color: white; } .button.is-success:hover, .button.is-success:focus, .button.is-success.is-active { background-color: #20bc56; border-color: transparent; color: white; } .button.is-success.is-inverted { background-color: white; color: #23d160; } .button.is-success.is-inverted:hover { background-color: #f2f2f2; } .button.is-success.is-loading:after { border-color: transparent transparent white white !important; } .button.is-success.is-outlined { background-color: transparent; border-color: #23d160; border-width: 1px; color: #23d160; } .button.is-success.is-outlined:hover, .button.is-success.is-outlined:focus { background-color: #23d160; border-color: #23d160; color: white; } .button.is-warning { background-color: #ffdd57; border-width: 0; color: rgba(0, 0, 0, 0.7); } .button.is-warning:hover, .button.is-warning:focus, .button.is-warning.is-active { background-color: #ffd83d; border-color: transparent; color: rgba(0, 0, 0, 0.7); } .button.is-warning.is-inverted { background-color: rgba(0, 0, 0, 0.7); color: #ffdd57; } .button.is-warning.is-inverted:hover { background-color: rgba(0, 0, 0, 0.7); } .button.is-warning.is-loading:after { border-color: transparent transparent rgba(0, 0, 0, 0.7) rgba(0, 0, 0, 0.7) !important; } .button.is-warning.is-outlined { background-color: transparent; border-color: #ffdd57; border-width: 1px; color: #ffdd57; } .button.is-warning.is-outlined:hover, .button.is-warning.is-outlined:focus { background-color: #ffdd57; border-color: #ffdd57; color: rgba(0, 0, 0, 0.7); } .button.is-danger { background-color: #ff3860; border-width: 0; color: white; } .button.is-danger:hover, .button.is-danger:focus, .button.is-danger.is-active { background-color: #ff1f4b; border-color: transparent; color: white; } .button.is-danger.is-inverted { background-color: white; color: #ff3860; } .button.is-danger.is-inverted:hover { background-color: #f2f2f2; } .button.is-danger.is-loading:after { border-color: transparent transparent white white !important; } .button.is-danger.is-outlined { background-color: transparent; border-color: #ff3860; border-width: 1px; color: #ff3860; } .button.is-danger.is-outlined:hover, .button.is-danger.is-outlined:focus { background-color: #ff3860; border-color: #ff3860; color: white; } .button.is-link { background-color: transparent; border-width: 0; color: #4a4a4a; text-decoration: underline; } .button.is-link:hover, .button.is-link:focus { background-color: whitesmoke; color: #363636; } .button.is-small { border-radius: 2px; font-size: 11px; height: 24px; line-height: 16px; padding-left: 6px; padding-right: 6px; } .button.is-medium { font-size: 18px; height: 40px; padding-left: 14px; padding-right: 14px; } .button.is-large { font-size: 22px; height: 48px; padding-left: 20px; padding-right: 20px; } .button[disabled], .button.is-disabled { opacity: 0.5; } .button.is-fullwidth { display: -webkit-box; display: -ms-flexbox; display: flex; width: 100%; } .button.is-loading { color: transparent !important; pointer-events: none; } .button.is-loading:after { -webkit-animation: spinAround 500ms infinite linear; animation: spinAround 500ms infinite linear; border: 2px solid #dbdbdb; border-radius: 290486px; border-right-color: transparent; border-top-color: transparent; content: ""; display: block; height: 16px; position: relative; width: 16px; left: 50%; margin-left: -8px; margin-top: -8px; position: absolute; top: 50%; position: absolute !important; } .content { color: #4a4a4a; } .content:not(:last-child) { margin-bottom: 20px; } .content a:not(.button) { border-bottom: 1px solid #dbdbdb; } .content a:not(.button):visited { color: #b86bff; } .content a:not(.button):hover { border-bottom-color: #00d1b2; } .content li + li { margin-top: 0.25em; } .content blockquote:not(:last-child), .content p:not(:last-child), .content ol:not(:last-child), .content ul:not(:last-child) { margin-bottom: 1em; } .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 { color: #363636; font-weight: 300; line-height: 1.125; margin-bottom: 20px; } .content h1:not(:first-child), .content h2:not(:first-child), .content h3:not(:first-child) { margin-top: 40px; } .content blockquote { background-color: whitesmoke; border-left: 5px solid #dbdbdb; padding: 1.5em; } .content h1 { font-size: 2em; } .content h2 { font-size: 1.75em; } .content h3 { font-size: 1.5em; } .content h4 { font-size: 1.25em; } .content h5 { font-size: 1.125em; } .content h6 { font-size: 1em; } .content ol { list-style: decimal outside; margin-left: 2em; margin-right: 2em; margin-top: 1em; } .content ul { list-style: disc outside; margin-left: 2em; margin-right: 2em; margin-top: 1em; } .content ul ul { list-style-type: circle; margin-top: 0.5em; } .content ul ul ul { list-style-type: square; } .content.is-medium { font-size: 18px; } .content.is-medium code { font-size: 14px; } .content.is-large { font-size: 24px; } .content.is-large code { font-size: 18px; } .input, .textarea { -moz-appearance: none; -webkit-appearance: none; -webkit-box-align: center; -ms-flex-align: center; align-items: center; background-color: white; border: 1px solid #dbdbdb; border-radius: 3px; color: #363636; display: -webkit-inline-box; display: -ms-inline-flexbox; display: inline-flex; font-size: 14px; height: 32px; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; line-height: 24px; padding-left: 8px; padding-right: 8px; position: relative; vertical-align: top; box-shadow: inset 0 1px 2px rgba(10, 10, 10, 0.1); max-width: 100%; width: 100%; } .input:hover, .textarea:hover { border-color: #b5b5b5; } .input:active, .input:focus, .input.is-active, .textarea:active, .textarea:focus, .textarea.is-active { border-color: #00d1b2; outline: none; } .input[disabled], .input.is-disabled, .textarea[disabled], .textarea.is-disabled { background-color: whitesmoke; border-color: #dbdbdb; cursor: not-allowed; pointer-events: none; } .input[disabled]::-moz-placeholder, .input.is-disabled::-moz-placeholder, .textarea[disabled]::-moz-placeholder, .textarea.is-disabled::-moz-placeholder { color: rgba(54, 54, 54, 0.3); } .input[disabled]::-webkit-input-placeholder, .input.is-disabled::-webkit-input-placeholder, .textarea[disabled]::-webkit-input-placeholder, .textarea.is-disabled::-webkit-input-placeholder { color: rgba(54, 54, 54, 0.3); } .input[disabled]:-moz-placeholder, .input.is-disabled:-moz-placeholder, .textarea[disabled]:-moz-placeholder, .textarea.is-disabled:-moz-placeholder { color: rgba(54, 54, 54, 0.3); } .input[disabled]:-ms-input-placeholder, .input.is-disabled:-ms-input-placeholder, .textarea[disabled]:-ms-input-placeholder, .textarea.is-disabled:-ms-input-placeholder { color: rgba(54, 54, 54, 0.3); } .input.is-white, .textarea.is-white { border-color: white; } .input.is-black, .textarea.is-black { border-color: #0a0a0a; } .input.is-light, .textarea.is-light { border-color: whitesmoke; } .input.is-dark, .textarea.is-dark { border-color: #363636; } .input.is-primary, .textarea.is-primary { border-color: #00d1b2; } .input.is-info, .textarea.is-info { border-color: #3273dc; } .input.is-success, .textarea.is-success { border-color: #23d160; } .input.is-warning, .textarea.is-warning { border-color: #ffdd57; } .input.is-danger, .textarea.is-danger { border-color: #ff3860; } .input[type="search"], .textarea[type="search"] { border-radius: 290486px; } .input.is-small, .textarea.is-small { border-radius: 2px; font-size: 11px; height: 24px; line-height: 16px; padding-left: 6px; padding-right: 6px; } .input.is-medium, .textarea.is-medium { font-size: 18px; height: 40px; line-height: 32px; padding-left: 10px; padding-right: 10px; } .input.is-large, .textarea.is-large { font-size: 24px; height: 48px; line-height: 40px; padding-left: 12px; padding-right: 12px; } .input.is-fullwidth, .textarea.is-fullwidth { display: block; width: 100%; } .input.is-inline, .textarea.is-inline { display: inline; width: auto; } .textarea { display: block; line-height: 1.2; max-height: 600px; max-width: 100%; min-height: 120px; min-width: 100%; padding: 10px; resize: vertical; } .checkbox, .radio { cursor: pointer; display: inline-block; line-height: 16px; position: relative; vertical-align: top; } .checkbox input, .radio input { cursor: pointer; } .checkbox:hover, .radio:hover { color: #363636; } .checkbox.is-disabled, .radio.is-disabled { color: #dbdbdb; pointer-events: none; } .checkbox.is-disabled input, .radio.is-disabled input { pointer-events: none; } .radio + .radio { margin-left: 10px; } .select { display: inline-block; height: 32px; position: relative; vertical-align: top; } .select select { -moz-appearance: none; -webkit-appearance: none; -webkit-box-align: center; -ms-flex-align: center; align-items: center; background-color: white; border: 1px solid #dbdbdb; border-radius: 3px; color: #363636; display: -webkit-inline-box; display: -ms-inline-flexbox; display: inline-flex; font-size: 14px; height: 32px; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; line-height: 24px; padding-left: 8px; padding-right: 8px; position: relative; vertical-align: top; cursor: pointer; display: block; outline: none; padding-right: 36px; } .select select:hover { border-color: #b5b5b5; } .select select:active, .select select:focus, .select select.is-active { border-color: #00d1b2; outline: none; } .select select[disabled], .select select.is-disabled { background-color: whitesmoke; border-color: #dbdbdb; cursor: not-allowed; pointer-events: none; } .select select[disabled]::-moz-placeholder, .select select.is-disabled::-moz-placeholder { color: rgba(54, 54, 54, 0.3); } .select select[disabled]::-webkit-input-placeholder, .select select.is-disabled::-webkit-input-placeholder { color: rgba(54, 54, 54, 0.3); } .select select[disabled]:-moz-placeholder, .select select.is-disabled:-moz-placeholder { color: rgba(54, 54, 54, 0.3); } .select select[disabled]:-ms-input-placeholder, .select select.is-disabled:-ms-input-placeholder { color: rgba(54, 54, 54, 0.3); } .select select.is-white { border-color: white; } .select select.is-black { border-color: #0a0a0a; } .select select.is-light { border-color: whitesmoke; } .select select.is-dark { border-color: #363636; } .select select.is-primary { border-color: #00d1b2; } .select select.is-info { border-color: #3273dc; } .select select.is-success { border-color: #23d160; } .select select.is-warning { border-color: #ffdd57; } .select select.is-danger { border-color: #ff3860; } .select select:hover { border-color: #b5b5b5; } .select select::ms-expand { display: none; } .select.is-fullwidth { width: 100%; } .select.is-fullwidth select { width: 100%; } .select:after { border: 1px solid #00d1b2; border-right: 0; border-top: 0; content: " "; display: block; height: 7px; pointer-events: none; position: absolute; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); width: 7px; margin-top: -6px; right: 16px; top: 50%; } .select:hover:after { border-color: #363636; } .select.is-small { height: 24px; } .select.is-small select { border-radius: 2px; font-size: 11px; height: 24px; line-height: 16px; padding-left: 6px; padding-right: 6px; padding-right: 28px; } .select.is-medium { height: 40px; } .select.is-medium select { font-size: 18px; height: 40px; line-height: 32px; padding-left: 10px; padding-right: 10px; padding-right: 44px; } .select.is-large { height: 48px; } .select.is-large select { font-size: 24px; height: 48px; line-height: 40px; padding-left: 12px; padding-right: 12px; padding-right: 52px; } .label { color: #363636; display: block; font-weight: bold; } .label:not(:last-child) { margin-bottom: 5px; } .help { display: block; font-size: 11px; margin-top: 5px; } .help.is-white { color: white; } .help.is-black { color: #0a0a0a; } .help.is-light { color: whitesmoke; } .help.is-dark { color: #363636; } .help.is-primary { color: #00d1b2; } .help.is-info { color: #3273dc; } .help.is-success { color: #23d160; } .help.is-warning { color: #ffdd57; } .help.is-danger { color: #ff3860; } @media screen and (max-width: 768px) { .control-label { margin-bottom: 5px; } } @media screen and (min-width: 769px) { .control-label { -ms-flex-preferred-size: 0; flex-basis: 0; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; margin-right: 20px; padding-top: 7px; text-align: right; } } .control { position: relative; text-align: left; } .control:not(:last-child) { margin-bottom: 10px; } .control.has-addons { display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; } .control.has-addons .button, .control.has-addons .input, .control.has-addons .select { border-radius: 0; margin-right: -1px; width: auto; } .control.has-addons .button:hover, .control.has-addons .input:hover, .control.has-addons .select:hover { z-index: 2; } .control.has-addons .button:active, .control.has-addons .button:focus, .control.has-addons .input:active, .control.has-addons .input:focus, .control.has-addons .select:active, .control.has-addons .select:focus { z-index: 3; } .control.has-addons .button:first-child, .control.has-addons .input:first-child, .control.has-addons .select:first-child { border-radius: 3px 0 0 3px; } .control.has-addons .button:first-child select, .control.has-addons .input:first-child select, .control.has-addons .select:first-child select { border-radius: 3px 0 0 3px; } .control.has-addons .button:last-child, .control.has-addons .input:last-child, .control.has-addons .select:last-child { border-radius: 0 3px 3px 0; } .control.has-addons .button:last-child select, .control.has-addons .input:last-child select, .control.has-addons .select:last-child select { border-radius: 0 3px 3px 0; } .control.has-addons .button.is-expanded, .control.has-addons .input.is-expanded, .control.has-addons .select.is-expanded { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; } .control.has-addons.has-addons-centered { -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; } .control.has-addons.has-addons-right { -webkit-box-pack: end; -ms-flex-pack: end; justify-content: flex-end; } .control.has-addons.has-addons-fullwidth .button, .control.has-addons.has-addons-fullwidth .input, .control.has-addons.has-addons-fullwidth .select { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; } .control.has-icon > .fa { display: inline-block; font-size: 14px; height: 24px; line-height: 24px; text-align: center; vertical-align: top; width: 24px; color: #dbdbdb; pointer-events: none; position: absolute; top: 4px; z-index: 4; } .control.has-icon .input:focus + .fa { color: #b5b5b5; } .control.has-icon .input.is-small + .fa { font-size: 10.5px; top: 0; } .control.has-icon .input.is-medium + .fa { font-size: 21px; top: 8px; } .control.has-icon .input.is-large + .fa { font-size: 21px; top: 12px; } .control.has-icon:not(.has-icon-right) > .fa { left: 4px; } .control.has-icon:not(.has-icon-right) .input { padding-left: 32px; } .control.has-icon:not(.has-icon-right) .input.is-small { padding-left: 24px; } .control.has-icon:not(.has-icon-right) .input.is-small + .fa { left: 0; } .control.has-icon:not(.has-icon-right) .input.is-medium { padding-left: 40px; } .control.has-icon:not(.has-icon-right) .input.is-medium + .fa { left: 8px; } .control.has-icon:not(.has-icon-right) .input.is-large { padding-left: 48px; } .control.has-icon:not(.has-icon-right) .input.is-large + .fa { left: 12px; } .control.has-icon.has-icon-right > .fa { right: 4px; } .control.has-icon.has-icon-right .input { padding-right: 32px; } .control.has-icon.has-icon-right .input.is-small { padding-right: 24px; } .control.has-icon.has-icon-right .input.is-small + .fa { right: 0; } .control.has-icon.has-icon-right .input.is-medium { padding-right: 40px; } .control.has-icon.has-icon-right .input.is-medium + .fa { right: 8px; } .control.has-icon.has-icon-right .input.is-large { padding-right: 48px; } .control.has-icon.has-icon-right .input.is-large + .fa { right: 12px; } .control.is-grouped { display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; } .control.is-grouped > .control:not(:last-child) { margin-bottom: 0; margin-right: 10px; } .control.is-grouped > .control.is-expanded { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 1; flex-shrink: 1; } .control.is-grouped.is-grouped-centered { -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; } .control.is-grouped.is-grouped-right { -webkit-box-pack: end; -ms-flex-pack: end; justify-content: flex-end; } @media screen and (min-width: 769px) { .control.is-horizontal { display: -webkit-box; display: -ms-flexbox; display: flex; } .control.is-horizontal > .control { display: -webkit-box; display: -ms-flexbox; display: flex; -ms-flex-preferred-size: 0; flex-basis: 0; -webkit-box-flex: 5; -ms-flex-positive: 5; flex-grow: 5; -ms-flex-negative: 1; flex-shrink: 1; } } .control.is-loading:after { -webkit-animation: spinAround 500ms infinite linear; animation: spinAround 500ms infinite linear; border: 2px solid #dbdbdb; border-radius: 290486px; border-right-color: transparent; border-top-color: transparent; content: ""; display: block; height: 16px; position: relative; width: 16px; position: absolute !important; right: 8px; top: 8px; } .image { display: block; position: relative; } .image img { display: block; height: auto; width: 100%; } .image.is-square img, .image.is-1by1 img, .image.is-4by3 img, .image.is-3by2 img, .image.is-16by9 img, .image.is-2by1 img { bottom: 0; left: 0; position: absolute; right: 0; top: 0; height: 100%; width: 100%; } .image.is-square, .image.is-1by1 { padding-top: 100%; } .image.is-4by3 { padding-top: 75%; } .image.is-3by2 { padding-top: 66.6666%; } .image.is-16by9 { padding-top: 56.25%; } .image.is-2by1 { padding-top: 50%; } .image.is-16x16 { height: 16px; width: 16px; } .image.is-24x24 { height: 24px; width: 24px; } .image.is-32x32 { height: 32px; width: 32px; } .image.is-48x48 { height: 48px; width: 48px; } .image.is-64x64 { height: 64px; width: 64px; } .image.is-96x96 { height: 96px; width: 96px; } .image.is-128x128 { height: 128px; width: 128px; } .notification { background-color: whitesmoke; border-radius: 3px; padding: 16px 20px; position: relative; } .notification:not(:last-child) { margin-bottom: 20px; } .notification:after { clear: both; content: " "; display: table; } .notification .delete { border-radius: 0 3px; float: right; margin: -16px -20px 0 20px; } .notification .title, .notification .subtitle, .notification .content { color: inherit; } .notification.is-white { background-color: white; color: #0a0a0a; } .notification.is-black { background-color: #0a0a0a; color: white; } .notification.is-light { background-color: whitesmoke; color: #363636; } .notification.is-dark { background-color: #363636; color: whitesmoke; } .notification.is-primary { background-color: #00d1b2; color: white; } .notification.is-info { background-color: #3273dc; color: white; } .notification.is-success { background-color: #23d160; color: white; } .notification.is-warning { background-color: #ffdd57; color: rgba(0, 0, 0, 0.7); } .notification.is-danger { background-color: #ff3860; color: white; } .progress { -moz-appearance: none; -webkit-appearance: none; border: none; border-radius: 290486px; display: block; height: 12px; overflow: hidden; padding: 0; width: 100%; } .progress:not(:last-child) { margin-bottom: 20px; } .progress::-webkit-progress-bar { background-color: #dbdbdb; } .progress::-webkit-progress-value { background-color: #4a4a4a; } .progress::-moz-progress-bar { background-color: #4a4a4a; } .progress.is-white::-webkit-progress-value { background-color: white; } .progress.is-white::-moz-progress-bar { background-color: white; } .progress.is-black::-webkit-progress-value { background-color: #0a0a0a; } .progress.is-black::-moz-progress-bar { background-color: #0a0a0a; } .progress.is-light::-webkit-progress-value { background-color: whitesmoke; } .progress.is-light::-moz-progress-bar { background-color: whitesmoke; } .progress.is-dark::-webkit-progress-value { background-color: #363636; } .progress.is-dark::-moz-progress-bar { background-color: #363636; } .progress.is-primary::-webkit-progress-value { background-color: #00d1b2; } .progress.is-primary::-moz-progress-bar { background-color: #00d1b2; } .progress.is-info::-webkit-progress-value { background-color: #3273dc; } .progress.is-info::-moz-progress-bar { background-color: #3273dc; } .progress.is-success::-webkit-progress-value { background-color: #23d160; } .progress.is-success::-moz-progress-bar { background-color: #23d160; } .progress.is-warning::-webkit-progress-value { background-color: #ffdd57; } .progress.is-warning::-moz-progress-bar { background-color: #ffdd57; } .progress.is-danger::-webkit-progress-value { background-color: #ff3860; } .progress.is-danger::-moz-progress-bar { background-color: #ff3860; } .progress.is-small { height: 8px; } .progress.is-medium { height: 16px; } .progress.is-large { height: 20px; } .table { background-color: white; color: #363636; margin-bottom: 20px; width: 100%; } .table td, .table th { border: 1px solid #dbdbdb; border-width: 0 0 1px; padding: 8px 10px; vertical-align: top; } .table td.is-icon, .table th.is-icon { padding: 5px; text-align: center; white-space: nowrap; width: 1%; } .table td.is-icon .fa, .table th.is-icon .fa { display: inline-block; font-size: 21px; height: 24px; line-height: 24px; text-align: center; vertical-align: top; width: 24px; } .table td.is-icon.is-link, .table th.is-icon.is-link { padding: 0; } .table td.is-icon.is-link > a, .table th.is-icon.is-link > a { padding: 5px; } .table td.is-link, .table th.is-link { padding: 0; } .table td.is-link > a, .table th.is-link > a { display: block; padding: 8px 10px; } .table td.is-link > a:hover, .table th.is-link > a:hover { background-color: #00d1b2; color: white; } .table td.is-narrow, .table th.is-narrow { white-space: nowrap; width: 1%; } .table th { color: #363636; text-align: left; } .table tr:hover { background-color: whitesmoke; } .table thead td, .table thead th { border-width: 0 0 2px; color: #7a7a7a; } .table tbody tr:last-child td, .table tbody tr:last-child th { border-bottom-width: 0; } .table tfoot td, .table tfoot th { border-width: 2px 0 0; color: #7a7a7a; } .table.is-bordered td, .table.is-bordered th { border-width: 1px; } .table.is-bordered tr:last-child td, .table.is-bordered tr:last-child th { border-bottom-width: 1px; } .table.is-narrow td, .table.is-narrow th { padding: 5px 10px; } .table.is-narrow td.is-icon, .table.is-narrow th.is-icon { padding: 2px; } .table.is-narrow td.is-icon.is-link, .table.is-narrow th.is-icon.is-link { padding: 0; } .table.is-narrow td.is-icon.is-link > a, .table.is-narrow th.is-icon.is-link > a { padding: 2px; } .table.is-narrow td.is-link, .table.is-narrow th.is-link { padding: 0; } .table.is-narrow td.is-link > a, .table.is-narrow th.is-link > a { padding: 5px 10px; } .table.is-striped tbody tr:nth-child(even) { background-color: #fafafa; } .table.is-striped tbody tr:nth-child(even):hover { background-color: whitesmoke; } .title, .subtitle { font-weight: 300; word-break: break-word; } .title:not(:last-child), .subtitle:not(:last-child) { margin-bottom: 20px; } .title em, .title span, .subtitle em, .subtitle span { font-weight: 300; } .title a:hover, .subtitle a:hover { border-bottom: 1px solid; } .title strong, .subtitle strong { font-weight: 500; } .title .tag, .subtitle .tag { vertical-align: bottom; } .title { color: #363636; font-size: 28px; line-height: 1; } .title code { display: inline-block; font-size: 28px; } .title strong { color: inherit; } .title + .highlight { margin-top: -10px; } .title + .subtitle { margin-top: -10px; } .title.is-1 { font-size: 48px; } .title.is-1 code { font-size: 40px; } .title.is-2 { font-size: 40px; } .title.is-2 code { font-size: 28px; } .title.is-3 { font-size: 28px; } .title.is-3 code { font-size: 24px; } .title.is-4 { font-size: 24px; } .title.is-4 code { font-size: 18px; } .title.is-5 { font-size: 18px; } .title.is-5 code { font-size: 14px; } .title.is-6 { font-size: 14px; } .title.is-6 code { font-size: 14px; } .title.is-normal { font-weight: 400; } .title.is-normal strong { font-weight: 700; } @media screen and (min-width: 769px) { .title + .subtitle { margin-top: -15px; } } .subtitle { color: #4a4a4a; font-size: 18px; line-height: 1.125; } .subtitle code { border-radius: 3px; display: inline-block; font-size: 14px; padding: 2px 3px; vertical-align: top; } .subtitle strong { color: #363636; } .subtitle + .title { margin-top: -20px; } .subtitle.is-1 { font-size: 48px; } .subtitle.is-1 code { font-size: 40px; } .subtitle.is-2 { font-size: 40px; } .subtitle.is-2 code { font-size: 28px; } .subtitle.is-3 { font-size: 28px; } .subtitle.is-3 code { font-size: 24px; } .subtitle.is-4 { font-size: 24px; } .subtitle.is-4 code { font-size: 18px; } .subtitle.is-5 { font-size: 18px; } .subtitle.is-5 code { font-size: 14px; } .subtitle.is-6 { font-size: 14px; } .subtitle.is-6 code { font-size: 14px; } .subtitle.is-normal { font-weight: 400; } .subtitle.is-normal strong { font-weight: 700; } .block:not(:last-child) { margin-bottom: 20px; } .container { position: relative; } @media screen and (min-width: 980px) { .container { margin: 0 auto; max-width: 960px; } .container.is-fluid { margin: 0 20px; max-width: none; } } @media screen and (min-width: 1180px) { .container { max-width: 1200px; } } .delete { -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -moz-appearance: none; -webkit-appearance: none; background-color: rgba(10, 10, 10, 0.1); border: none; border-radius: 290486px; cursor: pointer; display: inline-block; height: 24px; outline: none; position: relative; vertical-align: top; width: 24px; } .delete:before, .delete:after { background-color: white; content: ""; display: block; height: 2px; left: 50%; margin-left: -25%; margin-top: -1px; position: absolute; top: 50%; width: 50%; } .delete:before { -webkit-transform: rotate(45deg); transform: rotate(45deg); } .delete:after { -webkit-transform: rotate(-45deg); transform: rotate(-45deg); } .delete:hover { background-color: rgba(10, 10, 10, 0.2); } .delete.is-small { height: 16px; width: 16px; } .delete.is-medium { height: 32px; width: 32px; } .delete.is-large { height: 40px; width: 40px; } .fa { font-size: 21px; text-align: center; vertical-align: top; } .icon { display: inline-block; font-size: 21px; height: 24px; line-height: 24px; text-align: center; vertical-align: top; width: 24px; } .icon .fa { font-size: inherit; line-height: inherit; } .icon.is-small { display: inline-block; font-size: 14px; height: 16px; line-height: 16px; text-align: center; vertical-align: top; width: 16px; } .icon.is-medium { display: inline-block; font-size: 28px; height: 32px; line-height: 32px; text-align: center; vertical-align: top; width: 32px; } .icon.is-large { display: inline-block; font-size: 42px; height: 48px; line-height: 48px; text-align: center; vertical-align: top; width: 48px; } .heading { display: block; font-size: 11px; letter-spacing: 1px; margin-bottom: 5px; text-transform: uppercase; } .highlight { font-size: 12px; font-weight: normal; max-width: 100%; overflow: hidden; padding: 0; } .highlight:not(:last-child) { margin-bottom: 20px; } .highlight pre { overflow: auto; max-width: 100%; } .loader { -webkit-animation: spinAround 500ms infinite linear; animation: spinAround 500ms infinite linear; border: 2px solid #dbdbdb; border-radius: 290486px; border-right-color: transparent; border-top-color: transparent; content: ""; display: block; height: 16px; position: relative; width: 16px; } .number { background-color: whitesmoke; border-radius: 290486px; display: inline-block; font-size: 18px; vertical-align: top; } .tag { -webkit-box-align: center; -ms-flex-align: center; align-items: center; background-color: whitesmoke; border-radius: 290486px; color: #4a4a4a; display: -webkit-inline-box; display: -ms-inline-flexbox; display: inline-flex; font-size: 12px; height: 24px; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; line-height: 16px; padding-left: 10px; padding-right: 10px; vertical-align: top; white-space: nowrap; } .tag .delete { margin-left: 4px; margin-right: -6px; } .tag.is-white { background-color: white; color: #0a0a0a; } .tag.is-black { background-color: #0a0a0a; color: white; } .tag.is-light { background-color: whitesmoke; color: #363636; } .tag.is-dark { background-color: #363636; color: whitesmoke; } .tag.is-primary { background-color: #00d1b2; color: white; } .tag.is-info { background-color: #3273dc; color: white; } .tag.is-success { background-color: #23d160; color: white; } .tag.is-warning { background-color: #ffdd57; color: rgba(0, 0, 0, 0.7); } .tag.is-danger { background-color: #ff3860; color: white; } .tag.is-small { font-size: 11px; height: 20px; padding-left: 8px; padding-right: 8px; } .tag.is-medium { font-size: 14px; height: 32px; padding-left: 14px; padding-right: 14px; } .tag.is-large { font-size: 18px; height: 40px; line-height: 24px; padding-left: 18px; padding-right: 18px; } .tag.is-large .delete { margin-left: 4px; margin-right: -8px; } .card-header { -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; box-shadow: 0 1px 2px rgba(10, 10, 10, 0.1); display: -webkit-box; display: -ms-flexbox; display: flex; min-height: 40px; } .card-header-title { -webkit-box-align: start; -ms-flex-align: start; align-items: flex-start; color: #363636; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; font-weight: bold; padding: 10px; } .card-header-icon { -webkit-box-align: center; -ms-flex-align: center; align-items: center; cursor: pointer; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; width: 40px; } .card-image { display: block; position: relative; } .card-content { padding: 20px; } .card-content .title + .subtitle { margin-top: -20px; } .card-footer { border-top: 1px solid #dbdbdb; -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; display: -webkit-box; display: -ms-flexbox; display: flex; } .card-footer-item { -webkit-box-align: center; -ms-flex-align: center; align-items: center; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; padding: 10px; } .card-footer-item:not(:last-child) { border-right: 1px solid #dbdbdb; } .card { background-color: white; box-shadow: 0 2px 3px rgba(10, 10, 10, 0.1), 0 0 0 1px rgba(10, 10, 10, 0.1); color: #4a4a4a; max-width: 100%; position: relative; width: 300px; } .card .media:not(:last-child) { margin-bottom: 10px; } .card.is-fullwidth { width: 100%; } .card.is-rounded { border-radius: 5px; } .highlight { background-color: #fdf6e3; color: #586e75; } .highlight .c { color: #93a1a1; } .highlight .err, .highlight .g { color: #586e75; } .highlight .k { color: #859900; } .highlight .l, .highlight .n { color: #586e75; } .highlight .o { color: #859900; } .highlight .x { color: #cb4b16; } .highlight .p { color: #586e75; } .highlight .cm { color: #93a1a1; } .highlight .cp { color: #859900; } .highlight .c1 { color: #93a1a1; } .highlight .cs { color: #859900; } .highlight .gd { color: #2aa198; } .highlight .ge { color: #586e75; font-style: italic; } .highlight .gr { color: #dc322f; } .highlight .gh { color: #cb4b16; } .highlight .gi { color: #859900; } .highlight .go, .highlight .gp { color: #586e75; } .highlight .gs { color: #586e75; font-weight: bold; } .highlight .gu { color: #cb4b16; } .highlight .gt { color: #586e75; } .highlight .kc { color: #cb4b16; } .highlight .kd { color: #268bd2; } .highlight .kn, .highlight .kp { color: #859900; } .highlight .kr { color: #268bd2; } .highlight .kt { color: #dc322f; } .highlight .ld { color: #586e75; } .highlight .m, .highlight .s { color: #2aa198; } .highlight .na { color: #B58900; } .highlight .nb { color: #586e75; } .highlight .nc { color: #268bd2; } .highlight .no { color: #cb4b16; } .highlight .nd { color: #268bd2; } .highlight .ni, .highlight .ne { color: #cb4b16; } .highlight .nf { color: #268bd2; } .highlight .nl, .highlight .nn, .highlight .nx, .highlight .py { color: #586e75; } .highlight .nt, .highlight .nv { color: #268bd2; } .highlight .ow { color: #859900; } .highlight .w { color: #586e75; } .highlight .mf, .highlight .mh, .highlight .mi, .highlight .mo { color: #2aa198; } .highlight .sb { color: #93a1a1; } .highlight .sc { color: #2aa198; } .highlight .sd { color: #586e75; } .highlight .s2 { color: #2aa198; } .highlight .se { color: #cb4b16; } .highlight .sh { color: #586e75; } .highlight .si, .highlight .sx { color: #2aa198; } .highlight .sr { color: #dc322f; } .highlight .s1, .highlight .ss { color: #2aa198; } .highlight .bp, .highlight .vc, .highlight .vg, .highlight .vi { color: #268bd2; } .highlight .il { color: #2aa198; } .level-item .title, .level-item .subtitle { margin-bottom: 0; } @media screen and (max-width: 768px) { .level-item:not(:last-child) { margin-bottom: 10px; } } .level-left .level-item:not(:last-child), .level-right .level-item:not(:last-child) { margin-right: 10px; } .level-left .level-item.is-flexible, .level-right .level-item.is-flexible { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; } @media screen and (max-width: 768px) { .level-left + .level-right { margin-top: 20px; } } @media screen and (min-width: 769px) { .level-left { -webkit-box-align: center; -ms-flex-align: center; align-items: center; display: -webkit-box; display: -ms-flexbox; display: flex; } } @media screen and (min-width: 769px) { .level-right { -webkit-box-align: center; -ms-flex-align: center; align-items: center; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: end; -ms-flex-pack: end; justify-content: flex-end; } } .level { -webkit-box-align: center; -ms-flex-align: center; -ms-grid-row-align: center; align-items: center; -webkit-box-pack: justify; -ms-flex-pack: justify; justify-content: space-between; } .level:not(:last-child) { margin-bottom: 20px; } .level code { border-radius: 3px; } .level img { display: inline-block; vertical-align: top; } .level.is-mobile { display: -webkit-box; display: -ms-flexbox; display: flex; } .level.is-mobile > .level-item:not(:last-child) { margin-bottom: 0; } .level.is-mobile > .level-item:not(.is-narrow) { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; } @media screen and (min-width: 769px) { .level { display: -webkit-box; display: -ms-flexbox; display: flex; } .level > .level-item:not(.is-narrow) { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; } } .media-number, .media-left, .media-right { -webkit-box-flex: 0; -ms-flex-positive: 0; flex-grow: 0; -ms-flex-negative: 0; flex-shrink: 0; } .media-number { background-color: whitesmoke; border-radius: 290486px; display: inline-block; font-size: 18px; height: 32px; line-height: 24px; margin-right: 10px; min-width: 32px; padding: 4px 8px; text-align: center; vertical-align: top; } .media-left { margin-right: 10px; } .media-right { margin-left: 10px; } .media-content { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 1; flex-shrink: 1; text-align: left; } .media { -webkit-box-align: start; -ms-flex-align: start; align-items: flex-start; display: -webkit-box; display: -ms-flexbox; display: flex; text-align: left; } .media .content:not(:last-child) { margin-bottom: 10px; } .media .media { border-top: 1px solid rgba(219, 219, 219, 0.5); display: -webkit-box; display: -ms-flexbox; display: flex; padding-top: 10px; } .media .media .content:not(:last-child), .media .media .control:not(:last-child) { margin-bottom: 5px; } .media .media .media { padding-top: 5px; } .media .media .media + .media { margin-top: 5px; } .media + .media { border-top: 1px solid rgba(219, 219, 219, 0.5); margin-top: 10px; padding-top: 10px; } .media.is-large + .media { margin-top: 20px; padding-top: 20px; } @media screen and (min-width: 769px) { .media.is-large .media-number { margin-right: 20px; } } .menu-nav a { display: block; padding: 5px 10px; } .menu-list a { border-radius: 2px; color: #4a4a4a; display: block; padding: 5px 10px; } .menu-list a:hover { background-color: whitesmoke; color: #00d1b2; } .menu-list a.is-active { background-color: #00d1b2; color: white; } .menu-list li ul { border-left: 1px solid #dbdbdb; margin: 10px; padding-left: 10px; } .menu-label { color: #7a7a7a; font-size: 11px; letter-spacing: 1px; margin-bottom: 5px; text-transform: uppercase; } .menu-label:not(:first-child) { margin-top: 20px; } .message-body { border: 1px solid #dbdbdb; border-radius: 3px; padding: 12px 15px; } .message-body strong { color: inherit; } .message-header { background-color: #4a4a4a; border-radius: 3px 3px 0 0; color: white; padding: 7px 10px; } .message-header strong { color: inherit; } .message-header + .message-body { border-radius: 0 0 3px 3px; border-top: none; } .message { background-color: whitesmoke; border-radius: 3px; } .message:not(:last-child) { margin-bottom: 20px; } .message.is-white { background-color: white; } .message.is-white .message-header { background-color: white; color: #0a0a0a; } .message.is-white .message-body { border-color: white; color: #666666; } .message.is-black { background-color: whitesmoke; } .message.is-black .message-header { background-color: #0a0a0a; color: white; } .message.is-black .message-body { border-color: #0a0a0a; color: gray; } .message.is-light { background-color: whitesmoke; } .message.is-light .message-header { background-color: whitesmoke; color: #363636; } .message.is-light .message-body { border-color: whitesmoke; color: #666666; } .message.is-dark { background-color: whitesmoke; } .message.is-dark .message-header { background-color: #363636; color: whitesmoke; } .message.is-dark .message-body { border-color: #363636; color: gray; } .message.is-primary { background-color: #ebfffc; } .message.is-primary .message-header { background-color: #00d1b2; color: white; } .message.is-primary .message-body { border-color: #00d1b2; color: gray; } .message.is-info { background-color: #eef3fc; } .message.is-info .message-header { background-color: #3273dc; color: white; } .message.is-info .message-body { border-color: #3273dc; color: gray; } .message.is-success { background-color: #eefcf3; } .message.is-success .message-header { background-color: #23d160; color: white; } .message.is-success .message-body { border-color: #23d160; color: gray; } .message.is-warning { background-color: #fffbeb; } .message.is-warning .message-header { background-color: #ffdd57; color: rgba(0, 0, 0, 0.7); } .message.is-warning .message-body { border-color: #ffdd57; color: gray; } .message.is-danger { background-color: #ffebef; } .message.is-danger .message-header { background-color: #ff3860; color: white; } .message.is-danger .message-body { border-color: #ff3860; color: gray; } .modal-background { bottom: 0; left: 0; position: absolute; right: 0; top: 0; background-color: rgba(10, 10, 10, 0.86); } .modal-content, .modal-card { margin: 0 20px; max-height: calc(100vh - 160px); overflow: auto; position: relative; width: 100%; } @media screen and (min-width: 769px) { .modal-content, .modal-card { margin: 0 auto; max-height: calc(100vh - 40px); width: 640px; } } .modal-close { -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -moz-appearance: none; -webkit-appearance: none; background-color: rgba(10, 10, 10, 0.1); border: none; border-radius: 290486px; cursor: pointer; display: inline-block; height: 24px; outline: none; position: relative; vertical-align: top; width: 24px; background: none; height: 40px; position: fixed; right: 20px; top: 20px; width: 40px; } .modal-close:before, .modal-close:after { background-color: white; content: ""; display: block; height: 2px; left: 50%; margin-left: -25%; margin-top: -1px; position: absolute; top: 50%; width: 50%; } .modal-close:before { -webkit-transform: rotate(45deg); transform: rotate(45deg); } .modal-close:after { -webkit-transform: rotate(-45deg); transform: rotate(-45deg); } .modal-close:hover { background-color: rgba(10, 10, 10, 0.2); } .modal-close.is-small { height: 16px; width: 16px; } .modal-close.is-medium { height: 32px; width: 32px; } .modal-close.is-large { height: 40px; width: 40px; } .modal-card { display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; -ms-flex-direction: column; flex-direction: column; max-height: calc(100vh - 40px); overflow: hidden; } .modal-card-head, .modal-card-foot { -webkit-box-align: center; -ms-flex-align: center; align-items: center; background-color: whitesmoke; display: -webkit-box; display: -ms-flexbox; display: flex; -ms-flex-negative: 0; flex-shrink: 0; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; padding: 20px; position: relative; } .modal-card-head { border-bottom: 1px solid #dbdbdb; border-top-left-radius: 5px; border-top-right-radius: 5px; } .modal-card-title { color: #363636; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; font-size: 24px; line-height: 1; } .modal-card-foot { border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; border-top: 1px solid #dbdbdb; } .modal-card-foot .button:not(:last-child) { margin-right: 10px; } .modal-card-body { background-color: white; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 1; flex-shrink: 1; overflow: auto; padding: 20px; } .modal { bottom: 0; left: 0; position: absolute; right: 0; top: 0; -webkit-box-align: center; -ms-flex-align: center; -ms-grid-row-align: center; align-items: center; display: none; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; overflow: hidden; position: fixed; z-index: 1986; } .modal.is-active { display: -webkit-box; display: -ms-flexbox; display: flex; } .nav-toggle { cursor: pointer; display: block; height: 50px; position: relative; width: 50px; } .nav-toggle span { background-color: #4a4a4a; display: block; height: 1px; left: 50%; margin-left: -7px; position: absolute; top: 50%; -webkit-transition: none 86ms ease-out; transition: none 86ms ease-out; -webkit-transition-property: background, left, opacity, -webkit-transform; transition-property: background, left, opacity, -webkit-transform; transition-property: background, left, opacity, transform; transition-property: background, left, opacity, transform, -webkit-transform; width: 15px; } .nav-toggle span:nth-child(1) { margin-top: -6px; } .nav-toggle span:nth-child(2) { margin-top: -1px; } .nav-toggle span:nth-child(3) { margin-top: 4px; } .nav-toggle:hover { background-color: whitesmoke; } .nav-toggle.is-active span { background-color: #00d1b2; } .nav-toggle.is-active span:nth-child(1) { margin-left: -5px; -webkit-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: left top; transform-origin: left top; } .nav-toggle.is-active span:nth-child(2) { opacity: 0; } .nav-toggle.is-active span:nth-child(3) { margin-left: -5px; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: left bottom; transform-origin: left bottom; } @media screen and (min-width: 769px) { .nav-toggle { display: none; } } .nav-item { -webkit-box-align: center; -ms-flex-align: center; align-items: center; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-flex: 0; -ms-flex-positive: 0; flex-grow: 0; -ms-flex-negative: 0; flex-shrink: 0; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; padding: 10px; } .nav-item a { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; } .nav-item img { max-height: 24px; } .nav-item .button + .button { margin-left: 10px; } .nav-item .tag:first-child { margin-right: 5px; } .nav-item .tag:last-child { margin-left: 5px; } @media screen and (max-width: 768px) { .nav-item { -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; } } .nav-item a, a.nav-item { color: #7a7a7a; } .nav-item a:hover, a.nav-item:hover { color: #363636; } .nav-item a.is-active, a.nav-item.is-active { color: #363636; } .nav-item a.is-tab, a.nav-item.is-tab { border-bottom: 1px solid transparent; border-top: 1px solid transparent; padding-left: 12px; padding-right: 12px; } .nav-item a.is-tab:hover, a.nav-item.is-tab:hover { border-bottom: 1px solid #00d1b2; border-top: 1px solid transparent; } .nav-item a.is-tab.is-active, a.nav-item.is-tab.is-active { border-bottom: 3px solid #00d1b2; border-top: 3px solid transparent; color: #00d1b2; } @media screen and (max-width: 768px) { .nav-menu { background-color: white; box-shadow: 0 4px 7px rgba(10, 10, 10, 0.1); left: 0; display: none; right: 0; top: 100%; position: absolute; } .nav-menu .nav-item { border-top: 1px solid rgba(219, 219, 219, 0.5); padding: 10px; } .nav-menu.is-active { display: block; } } @media screen and (min-width: 769px) and (max-width: 979px) { .nav-menu { padding-right: 20px; } } .nav-left { -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; display: -webkit-box; display: -ms-flexbox; display: flex; -ms-flex-preferred-size: 0; flex-basis: 0; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; overflow: hidden; overflow-x: auto; white-space: nowrap; } .nav-center { -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; margin-left: auto; margin-right: auto; } @media screen and (min-width: 769px) { .nav-right { -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; display: -webkit-box; display: -ms-flexbox; display: flex; -ms-flex-preferred-size: 0; flex-basis: 0; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; -webkit-box-pack: end; -ms-flex-pack: end; justify-content: flex-end; } } .nav { -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; background-color: white; display: -webkit-box; display: -ms-flexbox; display: flex; min-height: 50px; position: relative; text-align: center; z-index: 2; } .nav > .container { -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; display: -webkit-box; display: -ms-flexbox; display: flex; min-height: 50px; width: 100%; } .nav > .container > .nav-left > .nav-item:first-child:not(.is-tab) { padding-left: 0; } .nav > .container > .nav-right > .nav-item:last-child:not(.is-tab) { padding-right: 0; } .container > .nav > .nav-left > .nav-item:first-child:not(.is-tab) { padding-left: 0; } .container > .nav > .nav-right > .nav-item:last-child:not(.is-tab) { padding-right: 0; } .nav.has-shadow { box-shadow: 0 2px 3px rgba(10, 10, 10, 0.1); } @media screen and (max-width: 979px) { .nav > .container > .nav-left > .nav-item.is-brand:first-child, .container > .nav > .nav-left > .nav-item.is-brand:first-child { padding-left: 20px; } } .pagination { -webkit-box-align: center; -ms-flex-align: center; align-items: center; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; text-align: center; } .pagination a { display: block; min-width: 32px; padding: 3px 8px; } .pagination span { color: #7a7a7a; display: block; margin: 0 4px; } .pagination li { margin: 0 2px; } .pagination ul { -webkit-box-align: center; -ms-flex-align: center; align-items: center; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; } @media screen and (max-width: 768px) { .pagination { -ms-flex-wrap: wrap; flex-wrap: wrap; } .pagination > a { width: calc(50% - 5px); } .pagination > a:not(:first-child) { margin-left: 10px; } .pagination li { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; } .pagination ul { margin-top: 10px; } } @media screen and (min-width: 769px) { .pagination > a:not(:first-child) { -webkit-box-ordinal-group: 2; -ms-flex-order: 1; order: 1; } } .panel-icon { display: inline-block; font-size: 14px; height: 16px; line-height: 16px; text-align: center; vertical-align: top; width: 16px; color: #7a7a7a; float: left; margin: 0 4px 0 -2px; } .panel-icon .fa { font-size: inherit; line-height: inherit; } .panel-heading { background-color: whitesmoke; border-bottom: 1px solid #dbdbdb; border-radius: 4px 4px 0 0; color: #363636; font-size: 18px; font-weight: 300; padding: 10px; } .panel-list a { color: #4a4a4a; } .panel-list a:hover { color: #00d1b2; } .panel-tabs { display: -webkit-box; display: -ms-flexbox; display: flex; font-size: 11px; padding: 5px 10px 0; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; } .panel-tabs a { border-bottom: 1px solid #dbdbdb; margin-bottom: -1px; padding: 5px; } .panel-tabs a.is-active { border-bottom-color: #363636; color: #363636; } .panel-tabs:not(:last-child) { border-bottom: 1px solid #dbdbdb; } .panel-block { color: #363636; display: block; line-height: 16px; padding: 10px; } .panel-block:not(:last-child) { border-bottom: 1px solid #dbdbdb; } a.panel-block:hover { background-color: whitesmoke; } .panel { border: 1px solid #dbdbdb; border-radius: 5px; } .panel:not(:last-child) { margin-bottom: 20px; } .tabs { -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: justify; -ms-flex-pack: justify; justify-content: space-between; line-height: 24px; overflow: hidden; overflow-x: auto; white-space: nowrap; } .tabs:not(:last-child) { margin-bottom: 20px; } .tabs a { -webkit-box-align: center; -ms-flex-align: center; align-items: center; border-bottom: 1px solid #dbdbdb; color: #4a4a4a; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; margin-bottom: -1px; padding: 6px 12px; vertical-align: top; } .tabs a:hover { border-bottom-color: #363636; color: #363636; } .tabs li { display: block; } .tabs li.is-active a { border-bottom-color: #00d1b2; color: #00d1b2; } .tabs ul { -webkit-box-align: center; -ms-flex-align: center; align-items: center; border-bottom: 1px solid #dbdbdb; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; } .tabs ul.is-left { padding-right: 10px; } .tabs ul.is-center { -webkit-box-flex: 0; -ms-flex: none; flex: none; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; padding-left: 10px; padding-right: 10px; } .tabs ul.is-right { -webkit-box-pack: end; -ms-flex-pack: end; justify-content: flex-end; padding-left: 10px; } .tabs .icon:first-child { margin-right: 8px; } .tabs .icon:last-child { margin-left: 8px; } .tabs.is-centered ul { -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; } .tabs.is-right ul { -webkit-box-pack: end; -ms-flex-pack: end; justify-content: flex-end; } .tabs.is-boxed a { border: 1px solid transparent; border-radius: 3px 3px 0 0; padding-bottom: 5px; padding-top: 5px; } .tabs.is-boxed a:hover { background-color: whitesmoke; border-bottom-color: #dbdbdb; } .tabs.is-boxed li.is-active a { background-color: white; border-color: #dbdbdb; border-bottom-color: transparent !important; } .tabs.is-fullwidth li { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; } .tabs.is-toggle a { border: 1px solid #dbdbdb; margin-bottom: 0; padding-bottom: 5px; padding-top: 5px; position: relative; } .tabs.is-toggle a:hover { background-color: whitesmoke; border-color: #b5b5b5; z-index: 2; } .tabs.is-toggle li + li { margin-left: -1px; } .tabs.is-toggle li:first-child a { border-radius: 3px 0 0 3px; } .tabs.is-toggle li:last-child a { border-radius: 0 3px 3px 0; } .tabs.is-toggle li.is-active a { background-color: #00d1b2; border-color: #00d1b2; color: white; z-index: 1; } .tabs.is-toggle ul { border-bottom: none; } .tabs.is-small { font-size: 11px; } .tabs.is-small a { padding: 2px 8px; } .tabs.is-small.is-boxed a, .tabs.is-small.is-toggle a { padding-bottom: 1px; padding-top: 1px; } .tabs.is-medium { font-size: 18px; } .tabs.is-medium a { padding: 10px 16px; } .tabs.is-medium.is-boxed a, .tabs.is-medium.is-toggle a { padding-bottom: 9px; padding-top: 9px; } .tabs.is-large { font-size: 28px; } .tabs.is-large a { padding: 14px 20px; } .tabs.is-large.is-boxed a, .tabs.is-large.is-toggle a { padding-bottom: 13px; padding-top: 13px; } .column { display: block; -ms-flex-preferred-size: 0; flex-basis: 0; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 1; flex-shrink: 1; padding: 10px; } .columns.is-mobile > .column.is-narrow { -webkit-box-flex: 0; -ms-flex: none; flex: none; } .columns.is-mobile > .column.is-full { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .columns.is-mobile > .column.is-three-quarters { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .columns.is-mobile > .column.is-two-thirds { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.6666%; } .columns.is-mobile > .column.is-half { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .columns.is-mobile > .column.is-one-third { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.3333%; } .columns.is-mobile > .column.is-one-quarter { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .columns.is-mobile > .column.is-offset-three-quarters { margin-left: 75%; } .columns.is-mobile > .column.is-offset-two-thirds { margin-left: 66.6666%; } .columns.is-mobile > .column.is-offset-half { margin-left: 50%; } .columns.is-mobile > .column.is-offset-one-third { margin-left: 33.3333%; } .columns.is-mobile > .column.is-offset-one-quarter { margin-left: 25%; } .columns.is-mobile > .column.is-1 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 8.33333%; } .columns.is-mobile > .column.is-offset-1 { margin-left: 8.33333%; } .columns.is-mobile > .column.is-2 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 16.66667%; } .columns.is-mobile > .column.is-offset-2 { margin-left: 16.66667%; } .columns.is-mobile > .column.is-3 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .columns.is-mobile > .column.is-offset-3 { margin-left: 25%; } .columns.is-mobile > .column.is-4 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.33333%; } .columns.is-mobile > .column.is-offset-4 { margin-left: 33.33333%; } .columns.is-mobile > .column.is-5 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 41.66667%; } .columns.is-mobile > .column.is-offset-5 { margin-left: 41.66667%; } .columns.is-mobile > .column.is-6 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .columns.is-mobile > .column.is-offset-6 { margin-left: 50%; } .columns.is-mobile > .column.is-7 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 58.33333%; } .columns.is-mobile > .column.is-offset-7 { margin-left: 58.33333%; } .columns.is-mobile > .column.is-8 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.66667%; } .columns.is-mobile > .column.is-offset-8 { margin-left: 66.66667%; } .columns.is-mobile > .column.is-9 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .columns.is-mobile > .column.is-offset-9 { margin-left: 75%; } .columns.is-mobile > .column.is-10 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 83.33333%; } .columns.is-mobile > .column.is-offset-10 { margin-left: 83.33333%; } .columns.is-mobile > .column.is-11 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 91.66667%; } .columns.is-mobile > .column.is-offset-11 { margin-left: 91.66667%; } .columns.is-mobile > .column.is-12 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .columns.is-mobile > .column.is-offset-12 { margin-left: 100%; } @media screen and (max-width: 768px) { .column.is-narrow-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; } .column.is-full-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-three-quarters-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-two-thirds-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.6666%; } .column.is-half-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-one-third-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.3333%; } .column.is-one-quarter-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-three-quarters-mobile { margin-left: 75%; } .column.is-offset-two-thirds-mobile { margin-left: 66.6666%; } .column.is-offset-half-mobile { margin-left: 50%; } .column.is-offset-one-third-mobile { margin-left: 33.3333%; } .column.is-offset-one-quarter-mobile { margin-left: 25%; } .column.is-1-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 8.33333%; } .column.is-offset-1-mobile { margin-left: 8.33333%; } .column.is-2-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 16.66667%; } .column.is-offset-2-mobile { margin-left: 16.66667%; } .column.is-3-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-3-mobile { margin-left: 25%; } .column.is-4-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.33333%; } .column.is-offset-4-mobile { margin-left: 33.33333%; } .column.is-5-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 41.66667%; } .column.is-offset-5-mobile { margin-left: 41.66667%; } .column.is-6-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-offset-6-mobile { margin-left: 50%; } .column.is-7-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 58.33333%; } .column.is-offset-7-mobile { margin-left: 58.33333%; } .column.is-8-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.66667%; } .column.is-offset-8-mobile { margin-left: 66.66667%; } .column.is-9-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-offset-9-mobile { margin-left: 75%; } .column.is-10-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 83.33333%; } .column.is-offset-10-mobile { margin-left: 83.33333%; } .column.is-11-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 91.66667%; } .column.is-offset-11-mobile { margin-left: 91.66667%; } .column.is-12-mobile { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-offset-12-mobile { margin-left: 100%; } } @media screen and (min-width: 769px) { .column.is-narrow, .column.is-narrow-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; } .column.is-full, .column.is-full-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-three-quarters, .column.is-three-quarters-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-two-thirds, .column.is-two-thirds-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.6666%; } .column.is-half, .column.is-half-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-one-third, .column.is-one-third-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.3333%; } .column.is-one-quarter, .column.is-one-quarter-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-three-quarters, .column.is-offset-three-quarters-tablet { margin-left: 75%; } .column.is-offset-two-thirds, .column.is-offset-two-thirds-tablet { margin-left: 66.6666%; } .column.is-offset-half, .column.is-offset-half-tablet { margin-left: 50%; } .column.is-offset-one-third, .column.is-offset-one-third-tablet { margin-left: 33.3333%; } .column.is-offset-one-quarter, .column.is-offset-one-quarter-tablet { margin-left: 25%; } .column.is-1, .column.is-1-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 8.33333%; } .column.is-offset-1, .column.is-offset-1-tablet { margin-left: 8.33333%; } .column.is-2, .column.is-2-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 16.66667%; } .column.is-offset-2, .column.is-offset-2-tablet { margin-left: 16.66667%; } .column.is-3, .column.is-3-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-3, .column.is-offset-3-tablet { margin-left: 25%; } .column.is-4, .column.is-4-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.33333%; } .column.is-offset-4, .column.is-offset-4-tablet { margin-left: 33.33333%; } .column.is-5, .column.is-5-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 41.66667%; } .column.is-offset-5, .column.is-offset-5-tablet { margin-left: 41.66667%; } .column.is-6, .column.is-6-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-offset-6, .column.is-offset-6-tablet { margin-left: 50%; } .column.is-7, .column.is-7-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 58.33333%; } .column.is-offset-7, .column.is-offset-7-tablet { margin-left: 58.33333%; } .column.is-8, .column.is-8-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.66667%; } .column.is-offset-8, .column.is-offset-8-tablet { margin-left: 66.66667%; } .column.is-9, .column.is-9-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-offset-9, .column.is-offset-9-tablet { margin-left: 75%; } .column.is-10, .column.is-10-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 83.33333%; } .column.is-offset-10, .column.is-offset-10-tablet { margin-left: 83.33333%; } .column.is-11, .column.is-11-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 91.66667%; } .column.is-offset-11, .column.is-offset-11-tablet { margin-left: 91.66667%; } .column.is-12, .column.is-12-tablet { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-offset-12, .column.is-offset-12-tablet { margin-left: 100%; } } @media screen and (min-width: 980px) { .column.is-narrow-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; } .column.is-full-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-three-quarters-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-two-thirds-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.6666%; } .column.is-half-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-one-third-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.3333%; } .column.is-one-quarter-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-three-quarters-desktop { margin-left: 75%; } .column.is-offset-two-thirds-desktop { margin-left: 66.6666%; } .column.is-offset-half-desktop { margin-left: 50%; } .column.is-offset-one-third-desktop { margin-left: 33.3333%; } .column.is-offset-one-quarter-desktop { margin-left: 25%; } .column.is-1-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 8.33333%; } .column.is-offset-1-desktop { margin-left: 8.33333%; } .column.is-2-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 16.66667%; } .column.is-offset-2-desktop { margin-left: 16.66667%; } .column.is-3-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-3-desktop { margin-left: 25%; } .column.is-4-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.33333%; } .column.is-offset-4-desktop { margin-left: 33.33333%; } .column.is-5-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 41.66667%; } .column.is-offset-5-desktop { margin-left: 41.66667%; } .column.is-6-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-offset-6-desktop { margin-left: 50%; } .column.is-7-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 58.33333%; } .column.is-offset-7-desktop { margin-left: 58.33333%; } .column.is-8-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.66667%; } .column.is-offset-8-desktop { margin-left: 66.66667%; } .column.is-9-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-offset-9-desktop { margin-left: 75%; } .column.is-10-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 83.33333%; } .column.is-offset-10-desktop { margin-left: 83.33333%; } .column.is-11-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 91.66667%; } .column.is-offset-11-desktop { margin-left: 91.66667%; } .column.is-12-desktop { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-offset-12-desktop { margin-left: 100%; } } @media screen and (min-width: 1180px) { .column.is-narrow-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; } .column.is-full-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-three-quarters-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-two-thirds-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.6666%; } .column.is-half-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-one-third-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.3333%; } .column.is-one-quarter-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-three-quarters-widescreen { margin-left: 75%; } .column.is-offset-two-thirds-widescreen { margin-left: 66.6666%; } .column.is-offset-half-widescreen { margin-left: 50%; } .column.is-offset-one-third-widescreen { margin-left: 33.3333%; } .column.is-offset-one-quarter-widescreen { margin-left: 25%; } .column.is-1-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 8.33333%; } .column.is-offset-1-widescreen { margin-left: 8.33333%; } .column.is-2-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 16.66667%; } .column.is-offset-2-widescreen { margin-left: 16.66667%; } .column.is-3-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .column.is-offset-3-widescreen { margin-left: 25%; } .column.is-4-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.33333%; } .column.is-offset-4-widescreen { margin-left: 33.33333%; } .column.is-5-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 41.66667%; } .column.is-offset-5-widescreen { margin-left: 41.66667%; } .column.is-6-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .column.is-offset-6-widescreen { margin-left: 50%; } .column.is-7-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 58.33333%; } .column.is-offset-7-widescreen { margin-left: 58.33333%; } .column.is-8-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.66667%; } .column.is-offset-8-widescreen { margin-left: 66.66667%; } .column.is-9-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .column.is-offset-9-widescreen { margin-left: 75%; } .column.is-10-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 83.33333%; } .column.is-offset-10-widescreen { margin-left: 83.33333%; } .column.is-11-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 91.66667%; } .column.is-offset-11-widescreen { margin-left: 91.66667%; } .column.is-12-widescreen { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } .column.is-offset-12-widescreen { margin-left: 100%; } } .columns { margin-left: -10px; margin-right: -10px; margin-top: -10px; } .columns:last-child { margin-bottom: -10px; } .columns:not(:last-child) { margin-bottom: 10px; } .columns.is-centered { -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; } .columns.is-gapless { margin-left: 0; margin-right: 0; margin-top: 0; } .columns.is-gapless:last-child { margin-bottom: 0; } .columns.is-gapless:not(:last-child) { margin-bottom: 20px; } .columns.is-gapless > .column { margin: 0; padding: 0; } @media screen and (min-width: 769px) { .columns.is-grid { -ms-flex-wrap: wrap; flex-wrap: wrap; } .columns.is-grid > .column { max-width: 33.3333%; padding: 10px; width: 33.3333%; } .columns.is-grid > .column + .column { margin-left: 0; } } .columns.is-mobile { display: -webkit-box; display: -ms-flexbox; display: flex; } .columns.is-multiline { -ms-flex-wrap: wrap; flex-wrap: wrap; } .columns.is-vcentered { -webkit-box-align: center; -ms-flex-align: center; -ms-grid-row-align: center; align-items: center; } @media screen and (min-width: 769px) { .columns:not(.is-desktop) { display: -webkit-box; display: -ms-flexbox; display: flex; } } @media screen and (min-width: 980px) { .columns.is-desktop { display: -webkit-box; display: -ms-flexbox; display: flex; } } .tile { -webkit-box-align: stretch; -ms-flex-align: stretch; -ms-grid-row-align: stretch; align-items: stretch; display: block; -ms-flex-preferred-size: auto; flex-basis: auto; -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 1; flex-shrink: 1; min-height: -webkit-min-content; min-height: -moz-min-content; min-height: min-content; } .tile.is-ancestor { margin-left: -10px; margin-right: -10px; margin-top: -10px; } .tile.is-ancestor:last-child { margin-bottom: -10px; } .tile.is-ancestor:not(:last-child) { margin-bottom: 10px; } .tile.is-child { margin: 0 !important; } .tile.is-parent { padding: 10px; } .tile.is-vertical { -webkit-box-orient: vertical; -webkit-box-direction: normal; -ms-flex-direction: column; flex-direction: column; } .tile.is-vertical > .tile.is-child:not(:last-child) { margin-bottom: 20px !important; } @media screen and (min-width: 769px) { .tile:not(.is-child) { display: -webkit-box; display: -ms-flexbox; display: flex; } .tile.is-1 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 8.33333%; } .tile.is-2 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 16.66667%; } .tile.is-3 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 25%; } .tile.is-4 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 33.33333%; } .tile.is-5 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 41.66667%; } .tile.is-6 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 50%; } .tile.is-7 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 58.33333%; } .tile.is-8 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 66.66667%; } .tile.is-9 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 75%; } .tile.is-10 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 83.33333%; } .tile.is-11 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 91.66667%; } .tile.is-12 { -webkit-box-flex: 0; -ms-flex: none; flex: none; width: 100%; } } .hero-video { bottom: 0; left: 0; position: absolute; right: 0; top: 0; overflow: hidden; } .hero-video video { left: 50%; min-height: 100%; min-width: 100%; position: absolute; top: 50%; -webkit-transform: translate3d(-50%, -50%, 0); transform: translate3d(-50%, -50%, 0); } .hero-video.is-transparent { opacity: 0.3; } @media screen and (max-width: 768px) { .hero-video { display: none; } } .hero-buttons { margin-top: 20px; } @media screen and (max-width: 768px) { .hero-buttons .button { display: -webkit-box; display: -ms-flexbox; display: flex; } .hero-buttons .button:not(:last-child) { margin-bottom: 10px; } } @media screen and (min-width: 769px) { .hero-buttons { display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; } .hero-buttons .button:not(:last-child) { margin-right: 20px; } } .hero-head, .hero-foot { -ms-flex-negative: 0; flex-shrink: 0; } .hero-body { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 0; flex-shrink: 0; padding: 40px 20px; } @media screen and (min-width: 1240px) { .hero-body { padding-left: 0; padding-right: 0; } } .hero { -webkit-box-align: stretch; -ms-flex-align: stretch; align-items: stretch; background-color: white; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; -ms-flex-direction: column; flex-direction: column; -webkit-box-pack: justify; -ms-flex-pack: justify; justify-content: space-between; } .hero .nav { background: none; box-shadow: 0 1px 0 rgba(219, 219, 219, 0.3); } .hero .tabs ul { border-bottom: none; } .hero.is-white { background-color: white; color: #0a0a0a; } .hero.is-white .title { color: #0a0a0a; } .hero.is-white .title a, .hero.is-white .title strong { color: inherit; } .hero.is-white .subtitle { color: rgba(10, 10, 10, 0.9); } .hero.is-white .subtitle a, .hero.is-white .subtitle strong { color: #0a0a0a; } .hero.is-white .nav { box-shadow: 0 1px 0 rgba(10, 10, 10, 0.2); } @media screen and (max-width: 768px) { .hero.is-white .nav-menu { background-color: white; } } .hero.is-white a.nav-item, .hero.is-white .nav-item a:not(.button) { color: rgba(10, 10, 10, 0.7); } .hero.is-white a.nav-item:hover, .hero.is-white a.nav-item.is-active, .hero.is-white .nav-item a:not(.button):hover, .hero.is-white .nav-item a:not(.button).is-active { color: #0a0a0a; } .hero.is-white .tabs a { color: #0a0a0a; opacity: 0.9; } .hero.is-white .tabs a:hover { opacity: 1; } .hero.is-white .tabs li.is-active a { opacity: 1; } .hero.is-white .tabs.is-boxed a, .hero.is-white .tabs.is-toggle a { color: #0a0a0a; } .hero.is-white .tabs.is-boxed a:hover, .hero.is-white .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-white .tabs.is-boxed li.is-active a, .hero.is-white .tabs.is-boxed li.is-active a:hover, .hero.is-white .tabs.is-toggle li.is-active a, .hero.is-white .tabs.is-toggle li.is-active a:hover { background-color: #0a0a0a; border-color: #0a0a0a; color: white; } .hero.is-white.is-bold { background-image: -webkit-linear-gradient(309deg, #e6e6e6 0%, white 71%, white 100%); background-image: linear-gradient(141deg, #e6e6e6 0%, white 71%, white 100%); } @media screen and (max-width: 768px) { .hero.is-white .nav-toggle span { background-color: #0a0a0a; } .hero.is-white .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-white .nav-toggle.is-active span { background-color: #0a0a0a; } .hero.is-white .nav-menu .nav-item { border-top-color: rgba(10, 10, 10, 0.2); } } .hero.is-black { background-color: #0a0a0a; color: white; } .hero.is-black .title { color: white; } .hero.is-black .title a, .hero.is-black .title strong { color: inherit; } .hero.is-black .subtitle { color: rgba(255, 255, 255, 0.9); } .hero.is-black .subtitle a, .hero.is-black .subtitle strong { color: white; } .hero.is-black .nav { box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2); } @media screen and (max-width: 768px) { .hero.is-black .nav-menu { background-color: #0a0a0a; } } .hero.is-black a.nav-item, .hero.is-black .nav-item a:not(.button) { color: rgba(255, 255, 255, 0.7); } .hero.is-black a.nav-item:hover, .hero.is-black a.nav-item.is-active, .hero.is-black .nav-item a:not(.button):hover, .hero.is-black .nav-item a:not(.button).is-active { color: white; } .hero.is-black .tabs a { color: white; opacity: 0.9; } .hero.is-black .tabs a:hover { opacity: 1; } .hero.is-black .tabs li.is-active a { opacity: 1; } .hero.is-black .tabs.is-boxed a, .hero.is-black .tabs.is-toggle a { color: white; } .hero.is-black .tabs.is-boxed a:hover, .hero.is-black .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-black .tabs.is-boxed li.is-active a, .hero.is-black .tabs.is-boxed li.is-active a:hover, .hero.is-black .tabs.is-toggle li.is-active a, .hero.is-black .tabs.is-toggle li.is-active a:hover { background-color: white; border-color: white; color: #0a0a0a; } .hero.is-black.is-bold { background-image: -webkit-linear-gradient(309deg, black 0%, #0a0a0a 71%, #181616 100%); background-image: linear-gradient(141deg, black 0%, #0a0a0a 71%, #181616 100%); } @media screen and (max-width: 768px) { .hero.is-black .nav-toggle span { background-color: white; } .hero.is-black .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-black .nav-toggle.is-active span { background-color: white; } .hero.is-black .nav-menu .nav-item { border-top-color: rgba(255, 255, 255, 0.2); } } .hero.is-light { background-color: whitesmoke; color: #363636; } .hero.is-light .title { color: #363636; } .hero.is-light .title a, .hero.is-light .title strong { color: inherit; } .hero.is-light .subtitle { color: rgba(54, 54, 54, 0.9); } .hero.is-light .subtitle a, .hero.is-light .subtitle strong { color: #363636; } .hero.is-light .nav { box-shadow: 0 1px 0 rgba(54, 54, 54, 0.2); } @media screen and (max-width: 768px) { .hero.is-light .nav-menu { background-color: whitesmoke; } } .hero.is-light a.nav-item, .hero.is-light .nav-item a:not(.button) { color: rgba(54, 54, 54, 0.7); } .hero.is-light a.nav-item:hover, .hero.is-light a.nav-item.is-active, .hero.is-light .nav-item a:not(.button):hover, .hero.is-light .nav-item a:not(.button).is-active { color: #363636; } .hero.is-light .tabs a { color: #363636; opacity: 0.9; } .hero.is-light .tabs a:hover { opacity: 1; } .hero.is-light .tabs li.is-active a { opacity: 1; } .hero.is-light .tabs.is-boxed a, .hero.is-light .tabs.is-toggle a { color: #363636; } .hero.is-light .tabs.is-boxed a:hover, .hero.is-light .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-light .tabs.is-boxed li.is-active a, .hero.is-light .tabs.is-boxed li.is-active a:hover, .hero.is-light .tabs.is-toggle li.is-active a, .hero.is-light .tabs.is-toggle li.is-active a:hover { background-color: #363636; border-color: #363636; color: whitesmoke; } .hero.is-light.is-bold { background-image: -webkit-linear-gradient(309deg, #dfd8d8 0%, whitesmoke 71%, white 100%); background-image: linear-gradient(141deg, #dfd8d8 0%, whitesmoke 71%, white 100%); } @media screen and (max-width: 768px) { .hero.is-light .nav-toggle span { background-color: #363636; } .hero.is-light .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-light .nav-toggle.is-active span { background-color: #363636; } .hero.is-light .nav-menu .nav-item { border-top-color: rgba(54, 54, 54, 0.2); } } .hero.is-dark { background-color: #363636; color: whitesmoke; } .hero.is-dark .title { color: whitesmoke; } .hero.is-dark .title a, .hero.is-dark .title strong { color: inherit; } .hero.is-dark .subtitle { color: rgba(245, 245, 245, 0.9); } .hero.is-dark .subtitle a, .hero.is-dark .subtitle strong { color: whitesmoke; } .hero.is-dark .nav { box-shadow: 0 1px 0 rgba(245, 245, 245, 0.2); } @media screen and (max-width: 768px) { .hero.is-dark .nav-menu { background-color: #363636; } } .hero.is-dark a.nav-item, .hero.is-dark .nav-item a:not(.button) { color: rgba(245, 245, 245, 0.7); } .hero.is-dark a.nav-item:hover, .hero.is-dark a.nav-item.is-active, .hero.is-dark .nav-item a:not(.button):hover, .hero.is-dark .nav-item a:not(.button).is-active { color: whitesmoke; } .hero.is-dark .tabs a { color: whitesmoke; opacity: 0.9; } .hero.is-dark .tabs a:hover { opacity: 1; } .hero.is-dark .tabs li.is-active a { opacity: 1; } .hero.is-dark .tabs.is-boxed a, .hero.is-dark .tabs.is-toggle a { color: whitesmoke; } .hero.is-dark .tabs.is-boxed a:hover, .hero.is-dark .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-dark .tabs.is-boxed li.is-active a, .hero.is-dark .tabs.is-boxed li.is-active a:hover, .hero.is-dark .tabs.is-toggle li.is-active a, .hero.is-dark .tabs.is-toggle li.is-active a:hover { background-color: whitesmoke; border-color: whitesmoke; color: #363636; } .hero.is-dark.is-bold { background-image: -webkit-linear-gradient(309deg, #1f1919 0%, #363636 71%, #463f3f 100%); background-image: linear-gradient(141deg, #1f1919 0%, #363636 71%, #463f3f 100%); } @media screen and (max-width: 768px) { .hero.is-dark .nav-toggle span { background-color: whitesmoke; } .hero.is-dark .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-dark .nav-toggle.is-active span { background-color: whitesmoke; } .hero.is-dark .nav-menu .nav-item { border-top-color: rgba(245, 245, 245, 0.2); } } .hero.is-primary { background-color: #00d1b2; color: white; } .hero.is-primary .title { color: white; } .hero.is-primary .title a, .hero.is-primary .title strong { color: inherit; } .hero.is-primary .subtitle { color: rgba(255, 255, 255, 0.9); } .hero.is-primary .subtitle a, .hero.is-primary .subtitle strong { color: white; } .hero.is-primary .nav { box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2); } @media screen and (max-width: 768px) { .hero.is-primary .nav-menu { background-color: #00d1b2; } } .hero.is-primary a.nav-item, .hero.is-primary .nav-item a:not(.button) { color: rgba(255, 255, 255, 0.7); } .hero.is-primary a.nav-item:hover, .hero.is-primary a.nav-item.is-active, .hero.is-primary .nav-item a:not(.button):hover, .hero.is-primary .nav-item a:not(.button).is-active { color: white; } .hero.is-primary .tabs a { color: white; opacity: 0.9; } .hero.is-primary .tabs a:hover { opacity: 1; } .hero.is-primary .tabs li.is-active a { opacity: 1; } .hero.is-primary .tabs.is-boxed a, .hero.is-primary .tabs.is-toggle a { color: white; } .hero.is-primary .tabs.is-boxed a:hover, .hero.is-primary .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-primary .tabs.is-boxed li.is-active a, .hero.is-primary .tabs.is-boxed li.is-active a:hover, .hero.is-primary .tabs.is-toggle li.is-active a, .hero.is-primary .tabs.is-toggle li.is-active a:hover { background-color: white; border-color: white; color: #00d1b2; } .hero.is-primary.is-bold { background-image: -webkit-linear-gradient(309deg, #009e6c 0%, #00d1b2 71%, #00e7eb 100%); background-image: linear-gradient(141deg, #009e6c 0%, #00d1b2 71%, #00e7eb 100%); } @media screen and (max-width: 768px) { .hero.is-primary .nav-toggle span { background-color: white; } .hero.is-primary .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-primary .nav-toggle.is-active span { background-color: white; } .hero.is-primary .nav-menu .nav-item { border-top-color: rgba(255, 255, 255, 0.2); } } .hero.is-info { background-color: #3273dc; color: white; } .hero.is-info .title { color: white; } .hero.is-info .title a, .hero.is-info .title strong { color: inherit; } .hero.is-info .subtitle { color: rgba(255, 255, 255, 0.9); } .hero.is-info .subtitle a, .hero.is-info .subtitle strong { color: white; } .hero.is-info .nav { box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2); } @media screen and (max-width: 768px) { .hero.is-info .nav-menu { background-color: #3273dc; } } .hero.is-info a.nav-item, .hero.is-info .nav-item a:not(.button) { color: rgba(255, 255, 255, 0.7); } .hero.is-info a.nav-item:hover, .hero.is-info a.nav-item.is-active, .hero.is-info .nav-item a:not(.button):hover, .hero.is-info .nav-item a:not(.button).is-active { color: white; } .hero.is-info .tabs a { color: white; opacity: 0.9; } .hero.is-info .tabs a:hover { opacity: 1; } .hero.is-info .tabs li.is-active a { opacity: 1; } .hero.is-info .tabs.is-boxed a, .hero.is-info .tabs.is-toggle a { color: white; } .hero.is-info .tabs.is-boxed a:hover, .hero.is-info .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-info .tabs.is-boxed li.is-active a, .hero.is-info .tabs.is-boxed li.is-active a:hover, .hero.is-info .tabs.is-toggle li.is-active a, .hero.is-info .tabs.is-toggle li.is-active a:hover { background-color: white; border-color: white; color: #3273dc; } .hero.is-info.is-bold { background-image: -webkit-linear-gradient(309deg, #1577c6 0%, #3273dc 71%, #4366e5 100%); background-image: linear-gradient(141deg, #1577c6 0%, #3273dc 71%, #4366e5 100%); } @media screen and (max-width: 768px) { .hero.is-info .nav-toggle span { background-color: white; } .hero.is-info .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-info .nav-toggle.is-active span { background-color: white; } .hero.is-info .nav-menu .nav-item { border-top-color: rgba(255, 255, 255, 0.2); } } .hero.is-success { background-color: #23d160; color: white; } .hero.is-success .title { color: white; } .hero.is-success .title a, .hero.is-success .title strong { color: inherit; } .hero.is-success .subtitle { color: rgba(255, 255, 255, 0.9); } .hero.is-success .subtitle a, .hero.is-success .subtitle strong { color: white; } .hero.is-success .nav { box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2); } @media screen and (max-width: 768px) { .hero.is-success .nav-menu { background-color: #23d160; } } .hero.is-success a.nav-item, .hero.is-success .nav-item a:not(.button) { color: rgba(255, 255, 255, 0.7); } .hero.is-success a.nav-item:hover, .hero.is-success a.nav-item.is-active, .hero.is-success .nav-item a:not(.button):hover, .hero.is-success .nav-item a:not(.button).is-active { color: white; } .hero.is-success .tabs a { color: white; opacity: 0.9; } .hero.is-success .tabs a:hover { opacity: 1; } .hero.is-success .tabs li.is-active a { opacity: 1; } .hero.is-success .tabs.is-boxed a, .hero.is-success .tabs.is-toggle a { color: white; } .hero.is-success .tabs.is-boxed a:hover, .hero.is-success .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-success .tabs.is-boxed li.is-active a, .hero.is-success .tabs.is-boxed li.is-active a:hover, .hero.is-success .tabs.is-toggle li.is-active a, .hero.is-success .tabs.is-toggle li.is-active a:hover { background-color: white; border-color: white; color: #23d160; } .hero.is-success.is-bold { background-image: -webkit-linear-gradient(309deg, #12af2f 0%, #23d160 71%, #2ce28a 100%); background-image: linear-gradient(141deg, #12af2f 0%, #23d160 71%, #2ce28a 100%); } @media screen and (max-width: 768px) { .hero.is-success .nav-toggle span { background-color: white; } .hero.is-success .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-success .nav-toggle.is-active span { background-color: white; } .hero.is-success .nav-menu .nav-item { border-top-color: rgba(255, 255, 255, 0.2); } } .hero.is-warning { background-color: #ffdd57; color: rgba(0, 0, 0, 0.7); } .hero.is-warning .title { color: rgba(0, 0, 0, 0.7); } .hero.is-warning .title a, .hero.is-warning .title strong { color: inherit; } .hero.is-warning .subtitle { color: rgba(0, 0, 0, 0.9); } .hero.is-warning .subtitle a, .hero.is-warning .subtitle strong { color: rgba(0, 0, 0, 0.7); } .hero.is-warning .nav { box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2); } @media screen and (max-width: 768px) { .hero.is-warning .nav-menu { background-color: #ffdd57; } } .hero.is-warning a.nav-item, .hero.is-warning .nav-item a:not(.button) { color: rgba(0, 0, 0, 0.7); } .hero.is-warning a.nav-item:hover, .hero.is-warning a.nav-item.is-active, .hero.is-warning .nav-item a:not(.button):hover, .hero.is-warning .nav-item a:not(.button).is-active { color: rgba(0, 0, 0, 0.7); } .hero.is-warning .tabs a { color: rgba(0, 0, 0, 0.7); opacity: 0.9; } .hero.is-warning .tabs a:hover { opacity: 1; } .hero.is-warning .tabs li.is-active a { opacity: 1; } .hero.is-warning .tabs.is-boxed a, .hero.is-warning .tabs.is-toggle a { color: rgba(0, 0, 0, 0.7); } .hero.is-warning .tabs.is-boxed a:hover, .hero.is-warning .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-warning .tabs.is-boxed li.is-active a, .hero.is-warning .tabs.is-boxed li.is-active a:hover, .hero.is-warning .tabs.is-toggle li.is-active a, .hero.is-warning .tabs.is-toggle li.is-active a:hover { background-color: rgba(0, 0, 0, 0.7); border-color: rgba(0, 0, 0, 0.7); color: #ffdd57; } .hero.is-warning.is-bold { background-image: -webkit-linear-gradient(309deg, #ffaf24 0%, #ffdd57 71%, #fffa70 100%); background-image: linear-gradient(141deg, #ffaf24 0%, #ffdd57 71%, #fffa70 100%); } @media screen and (max-width: 768px) { .hero.is-warning .nav-toggle span { background-color: rgba(0, 0, 0, 0.7); } .hero.is-warning .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-warning .nav-toggle.is-active span { background-color: rgba(0, 0, 0, 0.7); } .hero.is-warning .nav-menu .nav-item { border-top-color: rgba(0, 0, 0, 0.2); } } .hero.is-danger { background-color: #ff3860; color: white; } .hero.is-danger .title { color: white; } .hero.is-danger .title a, .hero.is-danger .title strong { color: inherit; } .hero.is-danger .subtitle { color: rgba(255, 255, 255, 0.9); } .hero.is-danger .subtitle a, .hero.is-danger .subtitle strong { color: white; } .hero.is-danger .nav { box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2); } @media screen and (max-width: 768px) { .hero.is-danger .nav-menu { background-color: #ff3860; } } .hero.is-danger a.nav-item, .hero.is-danger .nav-item a:not(.button) { color: rgba(255, 255, 255, 0.7); } .hero.is-danger a.nav-item:hover, .hero.is-danger a.nav-item.is-active, .hero.is-danger .nav-item a:not(.button):hover, .hero.is-danger .nav-item a:not(.button).is-active { color: white; } .hero.is-danger .tabs a { color: white; opacity: 0.9; } .hero.is-danger .tabs a:hover { opacity: 1; } .hero.is-danger .tabs li.is-active a { opacity: 1; } .hero.is-danger .tabs.is-boxed a, .hero.is-danger .tabs.is-toggle a { color: white; } .hero.is-danger .tabs.is-boxed a:hover, .hero.is-danger .tabs.is-toggle a:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-danger .tabs.is-boxed li.is-active a, .hero.is-danger .tabs.is-boxed li.is-active a:hover, .hero.is-danger .tabs.is-toggle li.is-active a, .hero.is-danger .tabs.is-toggle li.is-active a:hover { background-color: white; border-color: white; color: #ff3860; } .hero.is-danger.is-bold { background-image: -webkit-linear-gradient(309deg, #ff0561 0%, #ff3860 71%, #ff5257 100%); background-image: linear-gradient(141deg, #ff0561 0%, #ff3860 71%, #ff5257 100%); } @media screen and (max-width: 768px) { .hero.is-danger .nav-toggle span { background-color: white; } .hero.is-danger .nav-toggle:hover { background-color: rgba(10, 10, 10, 0.1); } .hero.is-danger .nav-toggle.is-active span { background-color: white; } .hero.is-danger .nav-menu .nav-item { border-top-color: rgba(255, 255, 255, 0.2); } } @media screen and (min-width: 769px) { .hero.is-medium .hero-body { padding-bottom: 120px; padding-top: 120px; } } @media screen and (min-width: 769px) { .hero.is-large .hero-body { padding-bottom: 240px; padding-top: 240px; } } .hero.is-fullheight { min-height: 100vh; } .hero.is-fullheight .hero-body { -webkit-box-align: center; -ms-flex-align: center; align-items: center; display: -webkit-box; display: -ms-flexbox; display: flex; } .hero.is-fullheight .hero-body > .container { -webkit-box-flex: 1; -ms-flex-positive: 1; flex-grow: 1; -ms-flex-negative: 1; flex-shrink: 1; } .section { background-color: white; padding: 40px 20px; } @media screen and (min-width: 980px) { .section.is-medium { padding: 120px 20px; } .section.is-large { padding: 240px 20px; } } .footer { background-color: whitesmoke; padding: 40px 20px 80px; } .footer a, .footer a:visited { color: #4a4a4a; } .footer a:hover, .footer a:visited:hover { color: #363636; } .footer a:not(.icon), .footer a:visited:not(.icon) { border-bottom: 1px solid #dbdbdb; } .footer a:not(.icon):hover, .footer a:visited:not(.icon):hover { border-bottom-color: #00d1b2; }', '', function(opts) {
		(function (self) {
			var page;

			var load_tag =	function (tag, args) {
								var time = new Date ();
									if (! page || page .root .getAttribute ('data-is') !== tag) {
										if (page)
											page .unmount ();
										var page_root = document .createElement (tag);
										self .root .insertBefore (page_root, null);
										page = riot .mount (page_root, tag) [0];
									}

									page .emit ('input', args);
								log ('update page time ' + (new Date () - time) + 'ms', arguments);
								return tag;
							};

			var reload =	function () {
								load_tag (tag_name (page_name (window .location .hash)), page_arguments (window .location .hash));
							};
								var tag_name =	function (page_name) {
													return 'page-' + replace_all ('/', '-') (trim_trailing_slash (page_name));
												};
													var trim_trailing_slash =	function (path) {
																					if (path [path .length - 1] === '/')
																						return path .slice (0, -1);
																					else
																						return path;
																				};

								var page_name =	function (path) {
													return path .slice (path .indexOf ('#') + 1, path .indexOf ('/#') === -1 ? undefined : path .indexOf ('/#'));
												};
								var page_arguments =	function (path) {
															return (path .indexOf ('/#') !== -1 ? path .slice (path .indexOf ('/#') + 2) .split ('/') : []);
														};

			if (! window .location .hash)
				window .location .hash = '#home';

			most .fromEvent ('hashchange', window)
				.observe (reload);
			reload ();

		})(this);
});
riot.tag2('component-loginner', '<p class="control has-addons has-addons-centered"> <input type="text" placeholder="Username" faux_ref="{self_ref_expression (self, \'__username\')}"> </p> <p class="control has-addons has-addons-centered"> <input type="password" placeholder="Password" faux_ref="{self_ref_expression (self, \'__password\')}"> </p>', '', '', function(opts) {
	    (function (self) {
	        connects ({
	            __username: each_ref ('__username'),
	            __password: each_ref ('__password')
	        }) (self);
	        self .on ('__username', function (username) {
	            username .addEventListener ('input', function () {
	                self .emit (opts .username__from, username .value);
	            });
	        });
	        self .on ('__password', function (password) {
	            password .addEventListener ('input', function () {
	                self .emit (opts .password__from, password .value);
	            });
	        });
	    })(this);
});
riot.tag2('component-uploader', '<input onchange="{emit .bind (self, \'up\')}" type="file">', '', '', function(opts) {
	var self = this;

	    self .remembers ('up');
	    self .on ('up', function () {
	        var uploader = self .root .querySelector ('input');
	        var files = uploader .files;
	        window .alert ('Uploading');
	        files && upload (opts .destination, opts .return__from, self) (files [0]);
	    })
});
riot.tag2('content-footer', '<footer class="footer"> <div class="container"> <div class="content has-text-centered"> <p> <strong>Staff Development Platform by AB Credit. </strong><br> This website is designed by V for Vendetta Inc. </p> <p> </p> </div> </div> </footer>', '', '', function(opts) {
});
riot.tag2('content-menu', '<aside class="menu"> <p class="menu-label"> General </p> <ul class="menu-list"> <li><a href="#service/participant">Participant</a></li> <li><a href="#service/instructor">Instructor</a></li> </ul> <p class="menu-label"> Administration </p> <ul class="menu-list"> <li> <a href="#service/administrator">Manage Your Team</a> </li> </ul> <p class="menu-label"> User </p> <ul class="menu-list"> <li><a href="#home">Home</a></li> <li><a href="#service">Services</a></li> </ul> </aside>', '', '', function(opts) {
});
riot.tag2('content-nav', '<nav class="nav"> <div class="nav-left"> <a class="nav-item is-brand" href="#home"> AB Credit </a> </div> <span class="nav-toggle"> <span></span> <span></span> <span></span> </span> <div class="nav-right nav-menu"> <span class="nav-item"> <a class="button" onclick="{aasdf}"> <span class="icon"> <i class="fa fa-sign-out"></i> </span> <span>Logout</span> </a> </span> </div> </nav>', 'content-nav nav.nav { background-color: #6a9f95; } content-nav nav.nav .nav-item:not(:hover) { color: white; }', '', function(opts) {
		this.aasdf = function (){
	        most .just ()
	            .thru (util .logout)
	            .until (lifecycle (this))
	            .observe (function (login) {
	                if (login === undefined)
	                    window .location .hash = '#home';
	            });
		}.bind(this)
});
riot.tag2('layout-default', '<content-nav></content-nav> <section class="section is-fullheight"> <div class="container"> <div class="columns"> <div class="column is-3 shali-color"> <content-menu></content-menu> </div> <div class="column "> <yield></yield> </div> </div> </div> </section> <section> <content-footer></content-footer> </section>', '.shali-color { background-color: #36363d; overflow: hidden; margin-left: -20px; margin-right: 20px; } .shali-color * { background-color: #36363d !important; color: white !important; } .menu{ background-color: white; border-radius: 4px 4px 4px 4px; position: relative; top: 8px; left: 4px; } .menu-list .is-active { background: #6a9f95; } .menu-label{ position: relative; top: 5px; right: -7px; } .footer{ background-color: #6a9f95; }', '', function(opts) {
});
riot.tag2('layout-primary', '<content-nav></content-nav> <yield></yield>', '', '', function(opts) {
});
riot.tag2('page-home', '<layout-primary> <header class="hero is-fullheight is-info"> <div class="hero-body"> <div class="container has-text-centered"> <h1 class="title is-1 dark-title">Staff Development Program</h1> <p class="subtitle dark-title">Bring out the inner potential in all of your employees.</p> <a href="#login" class="button is-info is-large">Login</a> </div> </div> </header> <section class="hero"> <div class="hero-body"> <div class="container"> <div class="columns is-vcentered"> <div class="column is-half "> <figure class="image "><img src="https://blog.usertesting.com/wp-content/uploads/2016/05/participants_2-01.png" alt=""></figure> </div> <div class="column is-half "> <h1 class="title is-1">Participants</h1> <h2 class="subtitle">SDP provides an easy and intuitive interface for accessing engaging courses to further the development of interested employees. This easy to use app allows participants to take courses while also tracking their progress.</h2> </div> </div> </div> </div> </section> <section class="hero is-dark"> <div class="hero-body"> <div class="container"> <div class="columns is-vcentered"> <div class="column is-half "> <h1 class="title is-1">Instructrors</h1> <h2 class="subtitle">SDP provides a simple platform for instructors to create, modify and release courses for participants to take.</h2> </div> <div class="column is-half "> <figure class="image "><img src="https://www.natcom.org/uploadedImages/CommunicationCurrents_Articles/Volume_8/instructorscorner.jpg" alt=""></figure> </div> </div> </div> </div> </section> <section class="hero is-admin"> <div class="hero-body"> <div class="container"> <div class="columns is-vcentered"> <div class="column is-half "> <figure class="image "><img src="https://s-media-cache-ak0.pinimg.com/originals/78/2f/9b/782f9bdff45375b948fe056cce03cdd3.jpg" alt=""></figure> </div> <div class="column is-half "> <h1 class="title is-1">Administrator</h1> <h2 class="subtitle">SDP provides a simple user interface for administrative purposes such as tracking users and assigning instructors.</h2> </div> </div> </div> </div> </section> <section class="hero"> <div class="hero-body"> </div> </section> </layout-primary>', '.button.is-info { background-color: #6a9f95; border-width: 0; color: white; } .button.is-info:hover, .button.is-info:focus, .button.is-info.is-active { background-color: white; border-color: #6a9f95; color: #6a9f95; } .is-admin { background-color: #fefefe; } .dark-title { color: #696969 !important; } html, body { width: 100%; height: 100%; font-family: \'Open Sans\',\'Helvetica Neue\',Arial,sans-serif; margin: 0; } a { color: yellowgreen; -webkit-transition: all .35s; -moz-transition: all .35s; transition: all .35s; } a:hover, a:focus { color: forestgreen; } p { font-size: 16px; line-height: 1.5; } header { position: relative; width: 100%; min-height: auto; text-align: center; color: #fff; background-image: url(\'header.jpg\'); background-position: center; -webkit-background-size: cover; -moz-background-size: cover; background-size: cover; -o-background-size: cover; } header .header-content { position: relative; width: 100%; padding: 0; text-align: center; } header .header-content .header-content-inner h1 { margin-top: 0; margin-bottom: 20px; font-size: 50px; font-weight: 300; } header .header-content .header-content-inner p { margin-bottom: 50px; font-size: 16px; font-weight: 300; color: rgba(255,255,255,.7); } @media(min-width:768px) { header { min-height: 100%; } header .header-content { position: absolute; top: 50%; -webkit-transform: translateY(-50%); -ms-transform: translateY(-50%); transform: translateY(-50%); } header .header-content .header-content-inner { margin-right: auto; margin-left: auto; max-width: 1000px; } header .header-content .header-content-inner h1 { font-size: 100px; } header .header-content .header-content-inner p { margin-right: auto; margin-left: auto; max-width: 80%; font-size: 18px; } } .section-heading { margin-top: 0; margin-bottom: 20px; } .intro { color: #fff; background-color: yellowgreen; padding: 70px 0; text-align: center; } .content { padding: 100px 0; } .content-2 { color: #fff; background-color: #222; } .content-3 { padding: 20px 0 40px; text-align: center; } .promo, .promo h3, .promo a:link, .promo a:visited, .promo a:hover, .promo a:active { color: white; text-shadow: 0px 0px 40px black; text-decoration: none; } .promo-item { height: 200px; line-height: 180px; text-align: center; } .promo-item:hover { background-size: 110%; border: 10px solid rgba(255,255,255,0.3); line-height: 160px; } .promo-item h3 { font-size: 40px; display: inline-block; vertical-align: middle; } .item-1 { background: url(\'writing.jpg\'); } .item-2 { background: url(\'concert.jpg\'); } .item-3 { background: url(\'pencil_sharpener.jpg\'); } .item-1, .item-2, .item-3 { background-size: cover; background-position: 50% 50%; } .page-footer { text-align: center; } .page-footer .contact { padding: 100px 0; background-color: yellowgreen; color: #fff; } .page-footer .contact p { font-size: 22px; font-weight: 300; } .content-3 .glyphicon, .page-footer .contact .glyphicon { font-size: 32px; font-weight: 700; } .page-footer .small-print { padding: 50px 0 40px; font-weight: 300; } .text-light { color: rgba(255,255,255,.7); } .navbar-default { border-color: rgba(34,34,34,.05); background-color: #6a9f95; -webkit-transition: all .35s; -moz-transition: all .35s; transition: all .35s; } .navbar-default .navbar-header .navbar-brand { color: yellowgreen; } .navbar-default .navbar-header .navbar-brand:hover, .navbar-default .navbar-header .navbar-brand:focus { color: #eb3812; } .navbar-default .nav > li>a, .navbar-default .nav>li>a:focus { color: #222; } .navbar-default .nav > li>a:hover, .navbar-default .nav>li>a:focus:hover { color: yellowgreen; } .navbar-default .nav > li.active>a, .navbar-default .nav>li.active>a:focus { color: yellowgreen!important; background-color: transparent; } .navbar-default .nav > li.active>a:hover, .navbar-default .nav>li.active>a:focus:hover { background-color: transparent; } @media(min-width:768px) { .navbar-default { border-color: rgba(255,255,255,.3); background-color: transparent; } .navbar-default .navbar-header .navbar-brand { color: rgba(255,255,255,.7); letter-spacing: 0.5em; } .navbar-default .navbar-header .navbar-brand:hover, .navbar-default .navbar-header .navbar-brand:focus { color: #fff; } .navbar-default .nav > li>a, .navbar-default .nav>li>a:focus { color: rgba(255,255,255,.7); } .navbar-default .nav > li>a:hover, .navbar-default .nav>li>a:focus:hover { color: #fff; } .navbar-default.affix { border-color: #fff; background-color: #fff; box-shadow: 0px 7px 20px 0px rgba(0,0,0,0.1); } .navbar-default.affix .navbar-header .navbar-brand { letter-spacing: 0; color: yellowgreen; } .navbar-default.affix .navbar-header .navbar-brand:hover, .navbar-default.affix .navbar-header .navbar-brand:focus { color: #eb3812; } .navbar-default.affix .nav > li>a, .navbar-default.affix .nav>li>a:focus { color: #222; } .navbar-default.affix .nav > li>a:hover, .navbar-default.affix .nav>li>a:focus:hover { color: yellowgreen; } } .btn-default { border-color: #fff; color: #222; background-color: #fff; -webkit-transition: all .35s; -moz-transition: all .35s; transition: all .35s; } .btn-default:hover, .btn-default:focus, .btn-default.focus, .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default { border-color: #eee; color: #222; background-color: #eee; } .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default { background-image: none; } .btn-default.disabled, .btn-default[disabled], fieldset[disabled] .btn-default, .btn-default.disabled:hover, .btn-default[disabled]:hover, fieldset[disabled] .btn-default:hover, .btn-default.disabled:focus, .btn-default[disabled]:focus, fieldset[disabled] .btn-default:focus, .btn-default.disabled.focus, .btn-default[disabled].focus, fieldset[disabled] .btn-default.focus, .btn-default.disabled:active, .btn-default[disabled]:active, fieldset[disabled] .btn-default:active, .btn-default.disabled.active, .btn-default[disabled].active, fieldset[disabled] .btn-default.active { border-color: #fff; background-color: #fff; } .btn-default .badge { color: #fff; background-color: #222; } .btn-primary { border-color: yellowgreen; color: #fff; background-color: yellowgreen; -webkit-transition: all .35s; -moz-transition: all .35s; transition: all .35s; } .btn-primary:hover, .btn-primary:focus, .btn-primary.focus, .btn-primary:active, .btn-primary.active, .open > .dropdown-toggle.btn-primary { border-color: limegreen; color: #fff; background-color: limegreen; } .btn-primary:active, .btn-primary.active, .open > .dropdown-toggle.btn-primary { background-image: none; } .btn-primary.disabled, .btn-primary[disabled], fieldset[disabled] .btn-primary, .btn-primary.disabled:hover, .btn-primary[disabled]:hover, fieldset[disabled] .btn-primary:hover, .btn-primary.disabled:focus, .btn-primary[disabled]:focus, fieldset[disabled] .btn-primary:focus, .btn-primary.disabled.focus, .btn-primary[disabled].focus, fieldset[disabled] .btn-primary.focus, .btn-primary.disabled:active, .btn-primary[disabled]:active, fieldset[disabled] .btn-primary:active, .btn-primary.disabled.active, .btn-primary[disabled].active, fieldset[disabled] .btn-primary.active { border-color: yellowgreen; background-color: yellowgreen; } .btn-primary .badge { color: yellowgreen; background-color: #fff; } .btn { border-radius: 300px; text-transform: uppercase; } .btn-lg { padding: 15px 30px; } ::-moz-selection { text-shadow: none; color: #fff; background: #222; } ::selection { text-shadow: none; color: #fff; background: #222; } img::selection { color: #fff; background: 0 0; } img::-moz-selection { color: #fff; background: 0 0; } .text-primary { color: yellowgreen; } .bg-primary { background-color: yellowgreen; }', '', function(opts) {
});
riot.tag2('page-login', '<layout-primary> <section class="hero is-fullheight"> <div class="hero-body"> <div class="container has-text-centered"> <h1 class="title is-1">Log in.</h1> <component-loginner username__from="username" password__from="password"></component-loginner> <section class="section"></section> <button class="button is-large is-info" type="submit" faux_ref="{self_ref_expression (self, \'login\')}"> Login </button> <button class="button is-large" type="submit" faux_ref="{self_ref_expression (self, \'register\')}"> Register </button> </div> </div> </section> </layout-primary>', '', '', function(opts) {
		(function (self) {
			if (get_cache (backend_path + '/login') && ! get_cache (backend_path + '/login') .error) {
				window .location .hash = '#service'
			}

			check_out (backend_path + '/cats', { method: 'GET' }, ' { response } ');

			remembers ({
				username: undefined,
				password: undefined
			}) (self);

			connects ({
				login: each_ref ('login'),
				register: each_ref ('register')
			}) (self);
			self .on ('login',  function (login) {
				most .fromEvent ('click', login)
					.map (function () {
						return	{
									username: self .my ('username'),
									password: self .my ('password')
								}
					})
					.thru (util .login)
					.tap (display_errors)
					.observe (function (response) {
						if (response && ! response .error) {
							window .location .hash = '#service'
						}
					});
			});
			self .on ('register',  function (register) {
				most .fromEvent ('click', register)
					.map (function () {
						return	{
									username: self .my ('username'),
									password: self .my ('password')
								}
					})
					.thru (util .register)
					.tap (display_errors)
					.observe (function (response) {
						if (response && ! response .error) {
							alert ('Successfully registered!');
						}
					});
			});
		})(this);
});
riot.tag2('page-new', '<layout-loggined-in></layout-loggined-in>', '', '', function(opts) {
});
riot.tag2('page-service-administrator', '<layout-default> <img class="admin-image" src="https://cdn1.iconfinder.com/data/icons/client-management/512/key-512.png" alt="Exercise control over the system."> <h1 class="title">Administrator Services</h1> <h2 class="subtitle1">Please select what you desire to do.</h2> <table class="table"> <tr><th>All Users</th><th></th><th></th></tr> <tr each="{user, piece in piece (my (\'all_users\', \'.users\'))}"><td if="{user .instructor & user .administrator}"><mark><strong>{user .username}</strong></mark></td ><td if="{! user .instructor & user .administrator}"><mark>{user .username}</mark></td ><td if="{user .instructor & ! user .administrator}"><strong>{user .username}</strong></td ><td if="{! user .administrator && ! user .instructor}">{user .username}</td ><td if="{! user .administrator}"><button class="localbutton1 button is-outlined is-info" type="submit" user="{user .id}" faux_ref="{self_ref_expression (self, \'make_administrator\')}">Make Admin</button></td ><td if="{user .administrator}"><button class="localbutton1 button is-outlined is-info" user="{user .id}" faux_ref="{self_ref_expression (self, \'revoke_administrator\')}">Revoke Admin</button></td ><td if="{! user .instructor}"><button class="localbutton1 button is-outlined is-info" type="submit" user="{user .id}" faux_ref="{self_ref_expression (self, \'make_instructor\')}">Make Instructor</button></td ><td if="{user .instructor}"><button class="localbutton1 button is-outlined is-info" user="{user .id}" faux_ref="{self_ref_expression (self, \'unmake_instructor\')}">Unmake Instructor</button></td ></tr> </table> </layout-default>', ':scope .localbutton1 { color: #6a9f95 !important; border-color: #6a9f95 !important; border-radius: 0px 0px 0px 0px !important; display: inline; width: 150px; } :scope .localbutton1:hover { color: #ffffff !important; background: #6a9f95 !important; } .admin-image { height: 300px; position: relative; left: 30%; }', '', function(opts) {
	(function (self) {

		connects ({
			all_users: content .users
		}) (self);
		self .on ('all_users', function () {
			self .update ();
		});

		connects ({
			make_administrator: each_ref ('make_administrator'),
			revoke_administrator: each_ref ('revoke_administrator'),
			make_instructor: each_ref ('make_instructor'),
			unmake_instructor: each_ref ('unmake_instructor')
		}) (self);
		self .on ('make_administrator', function (make_administrator) {
			var user = make_administrator .getAttribute ('user');

			most .fromEvent ('click', make_administrator)
				.map (function () {
					return	{
								edit_type: 'administrator-add',
								edit_content: 'add'
							};
				}) .thru (util .user_edit (user))

				.observe (rehash);
		});
		self .on ('revoke_administrator', function (revoke_administrator) {
			var user = revoke_administrator .getAttribute ('user');

			most .fromEvent ('click', revoke_administrator)
				.map (function () {
					return	{
								edit_type: 'administrator-remove',
								edit_content: 'remove'
							};
				}) .thru (util .user_edit (user))

				.observe (rehash);
		});
		self .on ('make_instructor', function (make_instructor) {
			var user = make_instructor .getAttribute ('user');

			most .fromEvent ('click', make_instructor)
				.map (function () {
					return	{
								edit_type: 'instructor-add',
								edit_content: 'add'
							};
				}) .thru (util .user_edit (user))

				.observe (rehash);
		});
		self .on ('unmake_instructor', function (unmake_instructor) {
			var user = unmake_instructor .getAttribute ('user');

			most .fromEvent ('click', unmake_instructor)
				.map (function () {
					return	{
								edit_type: 'instructor-remove',
								edit_content: 'remove'
							};
				}) .thru (util .user_edit (user))

				.observe (rehash);
		});
	})(this);
});
riot.tag2('page-service-instructor-component-add', '<layout-default> <h1 class="title">Add Component</h1> <label>Component name: </label><br> <input type="text" style="width:400px; margin:20px" x="component_name"> <br><br> <label>Component content: </label><br> <textarea rows="3" style="width:400px; margin:20px" x="component_content"></textarea> <br> <button type="submit" class="localbutton button is-outlined is-info" onclick="{emit.bind(self,\'add\')}"> Add component </button> </layout-default>', '', '', function(opts) {
		(function (self) {
			self .remembers ('input');
			self .on ('input', function (args) {
				var course_id = args [0];
				var module_order = args [1];

				self .remembers ('add')
				self .on ('add', function () {
					most .just ({
						component_name: self .root .querySelector ('[x="component_name"]') .value,
						component_content: self .root .querySelector ('[x="component_content"]') .value,
						component_files: JSON.stringify([]),
						component_videos: JSON.stringify([])
					}) .thru (util .component_new (course_id, module_order))
					.tap (display_errors)
					.observe (function (response) {
						if (! response .error) {

							window .location .hash = '#service/instructor/module/#' + course_id + '/' + module_order
						}
					});
				});
			});

		})(this);
});
riot.tag2('page-service-instructor-component', '<layout-default> <h1 class="title">{value (my (\'component_order\'), \'.name\') ( 										assemble ( 											value (my (\'module_order\'), \'.component_set\') ( 												logged(assemble (my (\'course\', \'.course .module_set\'))) 											) 										) 									)}</h1> <h2 class="subtitle1">{value (my (\'component_order\'), \'.content\') ( 										assemble ( 											value (my (\'module_order\'), \'.component_set\') ( 												assemble (my (\'course\', \'.course .module_set\')) 											) 										) 									)}</h2> <span each="{url, key in 								((parse ((value (my (\'component_order\'), \'.files\') ( 									assemble ( 										value (my (\'module_order\'), \'.component_set\') ( 											assemble (my (\'course\', \'.course .module_set\')) 										) 									) 								))) || [] ).filter) (is_picture)}"><img riot-src="{url}"> <br></span> <span each="{url, key in 								((parse ((value (my (\'component_order\'), \'.files\') ( 									assemble ( 										value (my (\'module_order\'), \'.component_set\') ( 											assemble (my (\'course\', \'.course .module_set\')) 										) 									) 								))) || [] ).filter) (not_picture)}"><a href="{url}">{filename (url)}</a ><br></span> <span each="{video, key in 								((parse ((value (my (\'component_order\'), \'.videos\') ( 									assemble ( 										value (my (\'module_order\'), \'.component_set\') ( 											assemble (my (\'course\', \'.course .module_set\')) 										) 									) 								))) || [] ))}"><iframe width="420" height="315" riot-src="https://www.youtube.com/embed/{video}"> </iframe><br></span> <component-uploader destination="longeradlfkjas" return__from="file"></component-uploader> <input type="text" placeholder="Video"> <button to="add" onclick="{emit .bind (self, \'video\')}">Add Youtube URL</button> </layout-default>', '', '', function(opts) {
		(function (self) {
			self .remembers ('course');
			self .remembers ('module_order');
			self .remembers ('component_order');
			self .on ('course', function () { self .update (); });
			self .on ('module_order', function () { self .update (); });
			self .on ('component_order', function () { self .update (); });

			self .remembers ('input');
			self .on ('input', function (args) {
				var course_id = args [0];
				var module_order = args [1];
				var component_order = args [2];

				self .emit ('module_order', module_order);
				self .emit ('component_order', component_order);

				most .just ()
					.thru (content .course (course_id) )
					.observe (function (course) {
						self .emit ('course', course);
					});

						self .emit ('course', content .course (course_id).filter.__outgoing_memory_filter());

	var youtube_parser =function (url){
	    var regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
	    var match = url.match(regExp);
	    return (match&&match[7].length==11)? match[7] : false;
	};
				self .remembers ('video')
				most .fromEvent ('video', self)
					.take (1)
					.map (function () {
						return	{
									component_name: value (self .my ('component_order'), '.name') (
														assemble (
															value (self .my ('module_order'), '.component_set') (
																assemble (self .my ('course', '.course .module_set'))
															)
														)
													),
									component_content:	value (self .my ('component_order'), '.content') (
															assemble (
																value (self .my ('module_order'), '.component_set') (
																	assemble (self .my ('course', '.course .module_set'))
																)
															)
														),
									component_files:	value (self .my ('component_order'), '.files') (
															assemble (
																value (self .my ('module_order'), '.component_set') (
																	assemble (self .my ('course', '.course .module_set'))
																)
															)
														),
									component_videos:	JSON .stringify (array_push (youtube_parser(self .root .querySelector('input[type="text"]') .value)) (
															parse (value (self .my ('component_order'), '.videos') (
															assemble (
																value (self .my ('module_order'), '.component_set') (
																	assemble (self .my ('course', '.course .module_set'))
																)
															)
														)))),

								};
					})
					.thru (util .component_edit (course_id, module_order, component_order))
					.tap (display_errors)
					.observe (function (x) {
						setTimeout (rehash, 1500);
					});

				self .remembers ('file');
				most .fromEvent ('file', self)
					.take (1)
					.map (function (url) {
						return	{
									component_name: value (self .my ('component_order'), '.name') (
														assemble (
															value (self .my ('module_order'), '.component_set') (
																assemble (self .my ('course', '.course .module_set'))
															)
														)
													),
									component_content:	value (self .my ('component_order'), '.content') (
															assemble (
																value (self .my ('module_order'), '.component_set') (
																	assemble (self .my ('course', '.course .module_set'))
																)
															)
														),
									component_files:	JSON .stringify (array_push (url) (
															parse (value (self .my ('component_order'), '.files') (
																assemble (
																	value (self .my ('module_order'), '.component_set') (
																		assemble (self .my ('course', '.course .module_set'))
																	)
																)
															))
														)),
									component_videos:	value (self .my ('component_order'), '.videos') (
															assemble (
																value (self .my ('module_order'), '.component_set') (
																	assemble (self .my ('course', '.course .module_set'))
																)
															)
														),

								};
					})
					.thru (util .component_edit (course_id, module_order, component_order))
					.tap (display_errors)
					.observe (function (x) {
						rehash ();
					});
			});
		})(this);
});
riot.tag2('page-service-instructor-course-add', '<layout-default> <h1 class="title">Add Course</h2><br> <label>Course name: </label><br> <input type="text" style="width:400px; margin:20px" faux_ref="{self_ref_expression (self, \'__course_name\')}"> <br><br> <label>Course description: </label><br> <textarea rows="4" style="width:400px; margin:20px" faux_ref="{self_ref_expression (self, \'__course_description\')}"></textarea> <br> <br> <label style- margin:20px>Course category: </label><br> <select style="margin:20px" faux_ref="{self_ref_expression (self, \'__course_category\')}"> <option value="{cat}" each="{cat, dog in (get_cache(backend_path + \'/cats\')).split (\',\')}">{cat}</option> </select><br><br> <button class="localbutton button is-outlined is-info" type="submit" onclick="{emit .bind (self, \'asd\')}"> Add course </button> </layout-default>', '', '', function(opts) {
		(function (self) {
			self .remembers ('course_name');
			self .remembers ('course_description');
			self .remembers ('course_category');
			connects ({
				__course_name: each_ref ('__course_name'),
				__course_description: each_ref ('__course_description'),
				__course_category: each_ref ('__course_category'),
				add_course: each_ref ('add_course')
			}) (self);
			self .on ('__course_name', function (course_name) {
				course_name .addEventListener ('input', function () {
					self .emit ('course_name', course_name .value);
				});
			});
			self .on ('__course_description', function (course_description) {
				course_description .addEventListener ('input', function () {
					self .emit ('course_description', course_description .value);
				});
			});
			var c;
			self .on ('__course_category', function (course_category) {
				c = course_category;
				course_category .addEventListener ('input', function () {
					self .emit ('course_category', course_category .value);
				});
			});
			self .remembers('asd');
			self .on ('asd', function () {
				most .just ({
	                course_name: self .my ('course_name'),
	                course_description: self .my ('course_description'),
	                course_category: self .my ('course_category') || (!!c && c.value.trim())
	            })
				.thru (util .course_new)
				.observe (function (response) {
					if (! response .error) {
						window .location .hash = '#service/instructor/'
					}
				});
			});
		})(this);
});
riot.tag2('page-service-instructor-course', '<layout-default> <h1 class="title">{my (\'course\', \'.course .name\')}<h2 class="subtitle1" if="{my (\'course\', \'.course .published\')}">(published)</h2></h1> <p>{my (\'course\', \'.course .description\')}</p> <table class="table"> <tr><th>Modules</th><th></th><th></th> </tr> <tr each="{assemble (my (\'course\', \'.course .module_set\'))}"><td><a href="#service/instructor/module/#{my (\'course_id\')}/{order}">{name}</a></td ><td><button class="localbutton button is-outlined is-info" order="{order}" faux_ref="{self_ref_expression (self, \'delete_module\')}">x</button></td ><td><button class="localbutton button is-outlined is-info" order="{order}" onclick="{emit.bind(self,\'gasd\',+order)}">shift</button></td ></tr> </table> <button class="localbutton button is-outlined is-info" type="submit" faux_ref="{self_ref_expression (self, \'add_module\')}"> Add module </button> <button class="localbutton button is-outlined is-info" type="submit" if="{! my (\'course\', \'.course .published\')}" faux_ref="{self_ref_expression (self, \'publish_course\')}"> Publish course </button> </layout-default>', '', '', function(opts) {
		(function (self) {
			self .remembers ('input');
			self .on ('input', function (args) {
				var course_id = args [0];

				self .emit ('course_id', course_id);
				most .periodic (500)
					.until (lifecycle (self))
					.thru (content .course (course_id))
					.observe (function (course) {
						self .emit ('course', course);
					});

				connects ({
					delete: util .module_delete (course_id),
					reorder: util .module_reorder (course_id),
					publish: util .course_publish
				}) (self);
			});

			self .remembers ('course');
			self .remembers ('course_id');
			most .mergeArray ([
				most .fromEvent ('course', self),
				most .fromEvent ('course_id', self)
			])
				.tap (display_errors)
				.observe (function () {
					self .update ();
				});

			connects ({
				add_module: each_ref ('add_module'),
				delete_module: each_ref ('delete_module'),
				shift_module: each_ref ('shift_module'),
				publish_course: each_ref ('publish_course')
			}) (self);
			self .on ('add_module', function (add_module) {
				add_module .addEventListener ('click', function () {
					window .location .hash = '#service/instructor/module/add/#' + self .my ('course_id')
				});
			});
			self .on ('delete_module', function (delete_module) {
				var order = delete_module .getAttribute ('order');
				delete_module .addEventListener ('click', function () {
					self .emit ('delete', {
						module_order: +order
					});
				});
			});
			self .remembers ('gasd');
			self .on ('gasd', function (order) {
						self .emit ('reorder', {
							module_1_order: +order,
							module_2_order: (+order + 1) % assemble (self .my ('course', '.course .module_set')) .length
						});
			});
			self .on ('publish_course', function (publish_course) {
				publish_course .addEventListener ('click', function () {
					self .emit ('publish', {
						course_id: self .my ('course_id')
					});
				});
			});

			most .mergeArray ([
				most .fromEvent ('delete', self),
				most .fromEvent ('reorder', self),
				most .fromEvent ('publish', self)
			]) .observe (display_errors);
		})(this);
});
riot.tag2('page-service-instructor-module-add', '<layout-default> <h1 class="title">Add Module</h1><br> <label style="margin:20px">Module name: </label><br> <input type="text" style="width:400px; margin:20px" faux_ref="{self_ref_expression (self, \'__module_name\')}"> <br> <button class="localbutton button is-outlined is-info" type="submit" faux_ref="{self_ref_expression (self, \'add_module\')}"> Add module </button> </layout-default>', '#content{ height:70%; }', '', function(opts) {
	    (function (self) {
	        self .remembers ('module_name');
			connects ({
				__module_name: each_ref ('__module_name')
			}) (self);
			self .on ('__module_name', function (module_name) {
			    module_name .addEventListener ('input', function () {
			        self .emit ('module_name', module_name .value);
			    });
			});

			connects ({
				add_module: each_ref ('add_module')
			}) (self);
			self .on ('add_module', function (add_module) {
			    add_module .addEventListener ('input', function () {
			        self .emit ('add_module', module_name .value);
			    });
			});

			self .remembers ('input');
			self .on ('input', function (args) {
	    		var course_id = args [0];

	    		most .fromEvent ('click', self .my ('add_module'))
	    			.map (function () {
	    				return	{
	                                module_name: self .my ('module_name')
	    						};
	    			})
	    			.thru (util .module_new (course_id))
	    			.tap (display_errors)
	    			.observe (function (response) {
	    				if (! response .error) {

	    					window .location .hash = '#service/instructor/module/#' + course_id + '/' + response .order
	    				}
	    			});
	    	});
	    })(this);
});
riot.tag2('page-service-instructor-module', '<layout-default> <h1 class="title">{value (my (\'module_order\'), \'.name\') (assemble (my (\'course\', \'.course .module_set\')))}</h1> <table class="table"> <tr><th>Components</th><th></th><th></th></tr> <tr each="{assemble(value (my (\'module_order\'), \'.component_set\') (assemble (my (\'course\', \'.course .module_set\'))))}"><td><a href="#service/instructor/component/#{recalls (\'course_id\')}/{recalls (\'module_order\')}/{order}">{name}</a></td ><td><button class="localbutton button is-outlined is-info" order="{order}" faux_ref="{self_ref_expression (self, \'delete_component\')}">x</button></td ><td><button class="localbutton button is-outlined is-info" order="{order}" onclick="{emit.bind(self,\'fk\',+order)}">shift down</button></td ></tr> </table> <a class="localbutton button is-outlined is-info" type="submit" href="{\'#service/instructor/component/add/#\' + self .my (\'course_id\') + \'/\' + self .my (\'module_order\')}"> Add component </a> </layout-default>', '', '', function(opts) {
		(function (self) {
			remembers ({
				course: undefined,
				course_id: undefined,
				module_order: undefined
			}) (self);
			most .mergeArray ([
				most .fromEvent ('course', self),
				most .fromEvent ('course_id', self),
				most .fromEvent ('module_order', self)
			]) .observe (function () {
				self .update ();
			});

			connects ({
				add_component: each_ref ('add_component'),
				delete_component: each_ref ('delete_component'),
				shift_component: each_ref ('shift_component')
			}) (self);
			self .on ('delete_component', function (delete_component) {
				delete_component .addEventListener ('click', function () {
					var order = delete_component .getAttribute ('order');
					self .emit ('delete', {
						component_order: +order
					});
				});
			});

			self .remembers ('fk');
			self .on ('fk', function (order) {
				self .emit ('reorder', {
					component_1_order: +order,
					component_2_order: (+order + 1) % assemble (value (self .my ('module_order'), '.component_set') (assemble (self .my ('course', '.course .module_set')))) .length
				});
			});

			remembers ({
				delete: undefined,
				reorder: undefined
			}) (self);
			most .mergeArray ([
				most .fromEvent ('delete', self),
				most .fromEvent ('reorder', self)
			]) .observe (display_errors);

			self .remembers ('input');
			self .on ('input', function (args) {
				var course_id = args [0];
				var module_order = args [1];

				most .periodic (300)
					.thru (content .course (course_id))
					.tap (display_errors)
					.observe (function (course) {
						self .emit ('course', course);
					});
				self .emit ('course_id', course_id);
				self .emit ('module_order', module_order);

				connects ({
					delete: util .component_delete (course_id, module_order),
					reorder: util .component_reorder (course_id, module_order)
				}) (self);
			});
		})(this);
});
riot.tag2('page-service-instructor', '<layout-default> <h1 class="title">Instructor Services</h1> <img class="instructor-image" src="http://3.bp.blogspot.com/-huiOhtTMGes/VNPH7A_vVNI/AAAAAAAAFf0/-6LwfESemFY/s1600/linklab-graphic.png" improve the knowledge of your fellow employees> <h2 class="subtitle1">Please select what you desire to do.</h2> <table class="table"> <tr><th>Courses created by me</th><th></th><th></th></th></tr> <tr each="{my (\'my_courses\', \'.as_instructor\')}"><td><a href="#service/instructor/course/#{id}">{name}</a></td ><td><button class="localbutton button is-outlined is-info" course="{id}" faux_ref="{self_ref_expression (self, \'delete_course\')}">x</button></td ></tr> </table> <button class="localbutton button is-outlined is-info is-large" type="submit" style="margin:20px" faux_ref="{self_ref_expression (self, \'add_course\')}"> Add course </button> </layout-default>', ':scope .localbutton { color: #6a9f95 !important; border-color: #6a9f95 !important; border-radius: 0px 0px 0px 0px !important; display: inline; } :scope .localbutton:hover { color: #ffffff !important; background: #6a9f95 !important; } :scope .instructor-image { height: 300px; position: relative; left: 30%; text-align: center; }', '', function(opts) {
	(function (self) {
		most .periodic (500)
	        .until (lifecycle (self))
			.thru (content .my_courses)
			.tap (display_errors)
			.observe (function (my_courses) {
				self .emit ('my_courses', my_courses);
			});

		remembers ({
			my_courses: undefined
		}) (self);
		self .on ('my_courses', function () {
			self .update ();
		});

		connects ({
			add_course: each_ref ('add_course'),
			delete_course: each_ref ('delete_course')
		}) (self);
		self .on ('add_course', function (add_course) {
			add_course .addEventListener ('click', function () {
				window .location .hash = '#service/instructor/course/add'
			});
		})
		self .on ('delete_course', function (delete_course) {
			var course_id = delete_course .getAttribute ('course');
			most .fromEvent ('click', delete_course)
				.map (function () {
					return	{
								course_id: course_id
							};
				})
				.thru (util .course_delete)
				.observe (display_errors);
		})
	})(this);
});
riot.tag2('page-service-participant-course', '<layout-default> <h1 class="title">View Course</h1> <h2 class="subtitle1" if="{(piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\']}"><mark>{((recalls (\'course\') || {}) .course || {}) .name}</mark></h2> <h2 class="subtitle1" if="{! (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\'] && (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .completed_courses) || {}) [recalls (\'course_id\') || \'\']}"><strike>{((recalls (\'course\') || {}) .course || {}) .name}</strike></h2> <h2 class="subtitle1" if="{! (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\'] && ! (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .completed_courses) || {}) [recalls (\'course_id\') || \'\']}">{((recalls (\'course\') || {}) .course || {}) .name}</h2> <p>{((recalls (\'course\') || {}) .course || {}) .description}</p> <button class="localbutton button is-outlined is-info" disabled if="{(piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\']}"> You are already enrolled in this course </button> <button class="localbutton button is-outlined is-info" disabled if="{(get_cache (backend_path + \'/login\') || {}) .enroll_restricted && Object .keys (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) .length}"> You are restricted to take one course at a time </button> <button class="localbutton button is-outlined is-info" type="submit" name="enroll_course" if="{! logged_with(\'enrolled?\')(logged_with(\'enrolled courses\')(piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\']) && logged_with(\'unrestricted\')( ! (get_cache (backend_path + \'/login\') || {}) .enroll_restricted || ! Object .keys (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) .length )}"> Enroll </button> </layout-default>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var enroll_course = self .root .querySelector ('button[name="enroll_course"]');

	        enroll_course && enroll_course .addEventListener ('click', function () {
	            self .one ('enroll', function () {
	                window .location .hash = '#service/participant'
	            });
	            self .emit ('enroll');
	        }, false);
	    });
	    self .on ('updated', function () {
	        var enroll_course = self .root .querySelector ('button[name="enroll_course"]');

	        enroll_course && enroll_course .addEventListener ('click', function () {
	            self .one ('enroll', function () {
	                window .location .hash = '#service/participant'
	            });
	            self .emit ('enroll');
	        }, false);
	    });

	    self .on ('course', function () {
	        self .update ();
	    });
	    self .on ('course_id', function () {
	        self .update ();
	    });

	    self .remembers ('input');
	    self .on ('input', function (course_id) {

	        connects ({
	            course: content .course (course_id),
	            enroll: util .course_enroll (course_id)
	        }) (self);

	        remembers ({
	            course_id: course_id
	        }) (self);
	    });
	})(this);
});
riot.tag2('page-service-participant-my-component', '<layout-default> <h1 class="title">Components</h1> <h2 class="subtitle1" if="{value (my (\'component_order\'), \'.done\' ) ( 						assemble ( 							value (my (\'module_order\'), \'.component_set\') ( 								assemble (my (\'course\', \'.course .module_set\')) 							) 						) 					)}"><strike>{value (my (\'component_order\'), \'.name\' ) ( 						assemble ( 							value (my (\'module_order\'), \'.component_set\') ( 								assemble (my (\'course\', \'.course .module_set\')) 							) 						) 					)}</strike ></h2> <h2 class="subtitle1" if="{! value (my (\'component_order\'), \'.done\' ) ( 						assemble ( 							value (my (\'module_order\'), \'.component_set\') ( 								assemble (my (\'course\', \'.course .module_set\')) 							) 						) 					)}">{value (my (\'component_order\'), \'.name\' ) ( 						assemble ( 							value (my (\'module_order\'), \'.component_set\') ( 								assemble (my (\'course\', \'.course .module_set\')) 							) 						) 					)}</h2> <p>{value (my (\'component_order\'), \'.content\' ) ( 						assemble ( 							value (my (\'module_order\'), \'.component_set\') ( 								assemble (my (\'course\', \'.course .module_set\')) 							) 						) 					)}</p> <button class="localbutton button is-outlined is-info" disabled if="{value (my (\'component_order\'), \'.done\' ) ( 									assemble ( 										value (my (\'module_order\'), \'.component_set\') ( 											assemble (my (\'course\', \'.course .module_set\')) 										) 									) 								)}"> Already done </button> <button class="localbutton button is-outlined is-info" type="submit" if="{! value (my (\'component_order\'), \'.done\' ) ( 																assemble ( 																	value (my (\'module_order\'), \'.component_set\') ( 																		assemble (my (\'course\', \'.course .module_set\')) 																	) 																) 															)}" faux_ref="{self_ref_expression (self, \'done_component\')}"> I am done </button> </layout-default>', '', '', function(opts) {
		(function (self) {
			remembers ({
				course: undefined,
				module_order: undefined,
				component_order: undefined
			}) (self);

			most .mergeArray ([
				most .fromEvent ('course', self),
				most .fromEvent ('module_order', self),
				most .fromEvent ('component_order', self)
			])
			.tap (display_errors)
			.observe (function () {
				self .update ();
			});

			connects ({
				done_component:	each_ref ('done_component')
			}) (self);

			self .remembers ('input');
			self .on ('input', function (args) {
				var course_id = args [0];
				var module_order = args [1];
				var component_order = args [2];

				most .periodic (50000)
					.until (lifecycle (self))
					.thru (content .course (course_id))
					.tap (display_errors)
					.observe (function (course) {
						self .emit ('course', course)
					});

				self .emit ('module_order', module_order);
				self .emit ('component_order', component_order);

				self .on ('done_component',	function (done_component) {
					most .fromEvent ('click', done_component)
						.thru (util .component_done (course_id, module_order, component_order))
						.tap (display_errors)
						.observe (rehash);
				});
			});
	})(this);
});
riot.tag2('page-service-participant-my-course', '<layout-default> <h1 class="title">{my (\'course\', \'.course .name\')}</h1> <h2 class="subtitle1">{my (\'course\', \'.course .description\')}</h2> <table class="table"> <tr><th>Modules</th></tr> <tr each="{assemble ( 							my (\'course\', \'.course .module_set\') 							&& assemble (my (\'course\', \'.course .module_set\')) 								.slice (0, assemble (my (\'course\', \'.course .module_set\')) .filter (has_done) .length + 1) 						)}"><td><a href="#service/participant/my/module/#{my (\'course_id\')}/{order}" if="{done}"><strike>{name}</strike></a ><a href="#service/participant/my/module/#{my (\'course_id\')}/{order}" if="{! done}">{name}</a ></td ></tr> <tr if="{assemble (my (\'course\', \'.course .module_set\')) 						&& (1 < assemble (my (\'course\', \'.course .module_set\')) .filter (has_not_done) .length)}"><td><i>find out later......</i></td></tr> </table> </layout-default>', '', '', function(opts) {
		(function (self) {
			remembers ({
				course: undefined,
				course_id: undefined
			}) (self);
			most .mergeArray ([
				most .fromEvent ('course', self),
				most .fromEvent ('course_id', self),
			]) .observe (function () {
				self .update ();
			});

			self .remembers ('input');
			self .on ('input', function (args) {
				var course_id = args [0];

				most .periodic (500)
					.until (lifecycle (self))
					.thru (content .course (course_id))
					.tap (display_errors)
					.observe (function (course) {
						self .emit ('course', course)
					});

				self .emit ('course_id', course_id);
			});
		}) (this);
});
riot.tag2('page-service-participant-my-module', '<layout-default> <h2 class="subtitle1" if="{value (my (\'module_order\'), \'.done\') (assemble (my (\'course\', \'.course .module_set\')))}"><strike>{value (my (\'module_order\'), \'.name\') (assemble (my (\'course\', \'.course .module_set\')))}</strike ></h2> <h2 class="subtitle1" if="{! value (my (\'module_order\'), \'.done\') (assemble (my (\'course\', \'.course .module_set\')))}">{value (my (\'module_order\'), \'.name\') (assemble (my (\'course\', \'.course .module_set\')))}</h2 > <table class="table"> <tr><th>Components</th><th></th></tr> <tr each="{assemble (value (my (\'module_order\'), \'.component_set\') (assemble (my (\'course\', \'.course .module_set\'))))}"><td><a href="#service/participant/my/component/#{my (\'course_id\')}/{my (\'module_order\')}/{order}" if="{done}"><strike>{name}</strike></a ><a href="#service/participant/my/component/#{my (\'course_id\')}/{my (\'module_order\')}/{order}" if="{! done}">{name}</a ></td ></tr> </table> </layout-default>', '', '', function(opts) {
	(function (self) {
		remembers ({
			course: undefined,
			course_id: undefined,
			module_order: undefined
		}) (self);
		most .mergeArray ([
			most .fromEvent ('course', self),
			most .fromEvent ('course_id', self),
			most .fromEvent ('module_order', self)
		]) .observe (function () {
			self .update ();
		});

		self .remembers ('input');
		self .on ('input', function (args) {
			var course_id = args [0];
			var module_order = args [1];

			most .periodic (500)
				.until (lifecycle (self))
				.thru (content .course (course_id))
				.tap (display_errors)
				.observe (function (course) {
					self .emit ('course', course);
				});

			self .emit ('course_id', course_id);
			self .emit ('module_order', module_order);
		});
	})(this);
});
riot.tag2('page-service-participant', '<layout-default> <h1 class="title">Participant Services</h1> <img class="participant-image" src="https://cdn4.iconfinder.com/data/icons/proglyphs-science-and-medicine/512/Education-512.png" alt="Let\'s get learning!"> <h2 class="subtitle1">Please select what you desire to do.</h2> <table class="table"> <tr><th>Courses I am enrolled in</th></tr> <tr each="{my (\'my_courses\', \'.as_participant .enrolled_courses\')}"><td><a href="#service/participant/my/course/#{id}"><mark>{name}</mark></a></td ></tr> </table> <table class="table"> <tr><th>Courses I have completed</th></tr> <tr each="{my (\'my_courses\', \'.as_participant .completed_courses\')}"><td><a href="#service/participant/my/course/#{id}"><strike>{name}</strike></a></td ></tr> </table> <table class="table"> <tr><th>Courses catalogue</th></tr> <tr each="{my (\'all_courses\', \'.courses\')}"><td><a href="#service/participant/course/#{id}" if="{value (id) (piece (my (\'my_courses\', \'.as_participant .enrolled_courses\')))}"><mark>{name}</mark></a ><a href="#service/participant/course/#{id}" if="{! value (id) (piece (my (\'my_courses\', \'.as_participant .enrolled_courses\'))) && value (id) (piece (my (\'my_courses\', \'.as_participant .completed_courses\')))}"><strike>{name}</strike></a ><a href="#service/participant/course/#{id}" if="{! value (id) (piece (my (\'my_courses\', \'.as_participant .enrolled_courses\'))) && ! value (id) (piece (my (\'my_courses\', \'.as_participant .completed_courses\')))}">{name}</a ></td></tr> </table> </layout-default>', '.participant-image { height: 300px; position: relative; left: 32.5%; }', '', function(opts) {
	(function (self) {
	    most .periodic (500)
	        .until (lifecycle (self))
	        .thru (content .courses)
	        .tap (display_errors)
	        .observe (function (courses) {
	            self .emit ('all_courses', courses);
	        });
	    most .periodic (500)
	        .until (lifecycle (self))
	        .thru (content .my_courses)
	        .tap (display_errors)
	        .observe (function (courses) {
	            self .emit ('my_courses', courses);
	        });

		remembers ({
		    all_courses: undefined,
		    my_courses: undefined
		}) (self);
		most .mergeArray ([
		    most .fromEvent ('all_courses', self),
		    most .fromEvent ('my_courses', self)
		]) .observe (function () {
	        self .update ();
	    });
	})(this);
});
riot.tag2('page-service', '<layout-default> <h1 class="title">Welcome to the AB Credit Staff Development Platform!</h1> <img src="https://www.gnugroup.org/images/service1.png" alt="Select the service you would like to use!"><br> <p class="subtitle1">Please select the service you would like to use</p><br> <div class="buttons"> <button class="localbutton button is-outlined is-info is-large level" type="submit" faux_ref="{self_ref_expression (self, \'as_participant\')}"> Participant services </button> <button class="localbutton button is-outlined is-info is-large level" type="submit" if="{value (\'.as_instructor\') (get_cache (backend_path + \'/login\'))}" faux_ref="{self_ref_expression (self, \'as_instructor\')}"> Instructor services </button> <button class="localbutton button is-outlined is-info is-large level" type="submit" if="{value (\'.as_administrator\') (get_cache (backend_path + \'/login\'))}" faux_ref="{self_ref_expression (self, \'as_administrator\')}"> Administrator services </button> </div> </layout-default>', ':scope .localbutton { color: #6a9f95 !important; border-color: #6a9f95 !important; border-radius: 0px 0px 0px 0px !important; display: inline-block; text-align: center; } :scope .localbutton:hover { color: #ffffff !important; background: #6a9f95 !important; } :scope ul li { display: inline; margin: 12px; } :scope .buttons { margin: 0 auto; text-align: center; }', '', function(opts) {
	    (function (self) {
	        if (! value ('.id') (get_cache (backend_path + '/login')) )
	            window .location .hash = '#login';

	        connects ({
	            as_participant: each_ref ('as_participant'),
	            as_instructor: each_ref ('as_instructor'),
	            as_administrator: each_ref ('as_administrator')
	        }) (self);
	        self .on ('as_participant', function (as_participant) {
	            as_participant .addEventListener ('click', function () {
	                window .location .hash = '#service/participant';
	            });
	        });
	        self .on ('as_instructor', function (as_instructor) {
	            as_instructor .addEventListener ('click', function () {
	                window .location .hash = '#service/instructor';
	            });
	        });
	        self .on ('as_administrator', function (as_administrator) {
	            as_administrator .addEventListener ('click', function () {
	                window .location .hash = '#service/administrator';
	            });
	        });
	    })(this);
});
</script>