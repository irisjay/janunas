<!DOCTYPE html>
<html>
	<head>
		<script>var debug = false;
var alert_log =	function () {
					function safeJSONStringify (input, maxDepth, indent)
					{
					
					    var output,
					        refs = [],
					        refsPaths = [];
					        
					    maxDepth = maxDepth || 5;
					    
					    function recursion (input, path, depth)
					    {
					        var output = {},
					            pPath,
					            refIdx;
					        
					        path  = path  || "";
					        depth = depth || 0;
					        depth++;
					        
					        if (maxDepth && depth > maxDepth)
					        {
					            return "{depth over " + maxDepth + "}";
					        }
					        
					        for (var p in input)
					        {
					            pPath = (path ? (path+".") : "") + p;
					            if (typeof input[p] === "function")
					            {
					                output[p] = "{function}";
					            }
					            else if (typeof input[p] === "object")
					            {
					                refIdx = refs.indexOf(input[p]);
					                
					                if (-1 !== refIdx)
					                {
					                    output[p] = "{reference to " + refsPaths[refIdx]  + "}";
					                }
					                else
					                {
					                    refs.push(input[p]);
					                    refsPaths.push(pPath);
					                    output[p] = recursion(input[p], pPath, depth);
					                }
					            }
					            else
					            {
					                output[p] = input[p];
					            }
					        }
					        
					        return output;
					    }
					        
					    if (typeof input === "object")
					    {
					        output = recursion(input);
					    }
					    else
					    {
					        output = input;
					    }
					    
					    return JSON.stringify(output, null, indent);
					}
					var stringifyOnce = function(obj, replacer, indent){
						var printedObjects = [];
						var printedObjectKeys = [];
				
						function printOnceReplacer(key, value){
							if ( printedObjects.length > 2000){ // browsers will not print more than 20K, I don't see the point to allow 2K.. algorithm will not be fast anyway if we have too many objects
								return 'object too long';
							}
							var printedObjIndex = false;
							printedObjects.forEach(function(obj, index){
								if(obj===value){
										printedObjIndex = index;
								}
							});
				
							if ( key == ''){ //root element
								 printedObjects.push(obj);
								printedObjectKeys.push("root");
								 return value;
							}
				
							else if(printedObjIndex+"" != "false" && typeof(value)=="object"){
								if ( printedObjectKeys[printedObjIndex] == "root"){
										return "(pointer to root)";
								}else{
										return "(see " + ((!!value && !!value.constructor) ? value.constructor.name.toLowerCase()  : typeof(value)) + " with key " + printedObjectKeys[printedObjIndex] + ")";
								}
							}else{
								var qualifiedKey = key || "(empty key)";
								printedObjects.push(value);
								printedObjectKeys.push(qualifiedKey);
								if(replacer){
										return replacer(key, value);
								}else{
										return value;
								}
							}
						}
						return JSON.stringify(obj, printOnceReplacer, indent);
					};
					
					var msg = '';
					for (var key in arguments) {
						var value = arguments [key];
						//alert (value +'\n'+ safeJSONStringify (value, 3, 2));
						msg = (msg ? msg + '\n\n......\n\n' : '') + value +'\n'+ safeJSONStringify (value, 4, 2);
					}
					alert (msg);
					//debugger;
				};
			
var log_alert =	function () {
					if (window .log !== alert_log)
						window .log .apply (this, arguments);
					alert_log .apply (this, arguments);
				};
			
if (debug)
	log = alert_log;
else
	log = console .log .bind (console);</script>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<the-app></the-app>

		<!-- your app's js -->
		<script>!function(t){function e(){}function n(t,e){return function(){t.apply(e,arguments)}}function o(t){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],s(t,this)}function r(t,e){for(;3===t._state;)t=t._value;return 0===t._state?void t._deferreds.push(e):(t._handled=!0,void a(function(){var n=1===t._state?e.onFulfilled:e.onRejected;if(null===n)return void(1===t._state?i:f)(e.promise,t._value);var o;try{o=n(t._value)}catch(r){return void f(e.promise,r)}i(e.promise,o)}))}function i(t,e){try{if(e===t)throw new TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var r=e.then;if(e instanceof o)return t._state=3,t._value=e,void u(t);if("function"==typeof r)return void s(n(r,e),t)}t._state=1,t._value=e,u(t)}catch(i){f(t,i)}}function f(t,e){t._state=2,t._value=e,u(t)}function u(t){2===t._state&&0===t._deferreds.length&&a(function(){t._handled||d(t._value)});for(var e=0,n=t._deferreds.length;n>e;e++)r(t,t._deferreds[e]);t._deferreds=null}function c(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n}function s(t,e){var n=!1;try{t(function(t){n||(n=!0,i(e,t))},function(t){n||(n=!0,f(e,t))})}catch(o){if(n)return;n=!0,f(e,o)}}var l=setTimeout,a="function"==typeof setImmediate&&setImmediate||function(t){l(t,0)},d=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t)};o.prototype["catch"]=function(t){return this.then(null,t)},o.prototype.then=function(t,n){var o=new this.constructor(e);return r(this,new c(t,n,o)),o},o.all=function(t){var e=Array.prototype.slice.call(t);return new o(function(t,n){function o(i,f){try{if(f&&("object"==typeof f||"function"==typeof f)){var u=f.then;if("function"==typeof u)return void u.call(f,function(t){o(i,t)},n)}e[i]=f,0===--r&&t(e)}catch(c){n(c)}}if(0===e.length)return t([]);for(var r=e.length,i=0;i<e.length;i++)o(i,e[i])})},o.resolve=function(t){return t&&"object"==typeof t&&t.constructor===o?t:new o(function(e){e(t)})},o.reject=function(t){return new o(function(e,n){n(t)})},o.race=function(t){return new o(function(e,n){for(var o=0,r=t.length;r>o;o++)t[o].then(e,n)})},o._setImmediateFn=function(t){a=t},o._setUnhandledRejectionFn=function(t){d=t},"undefined"!=typeof module&&module.exports?module.exports=o:t.Promise||(t.Promise=o)}(this);</script>
		<script>(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/mi.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);
</script>
		<script>/* Riot v3.0.0-alpha.10, @license MIT */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.riot=t.riot||{})}(this,function(t){"use strict";function e(t){return Pt.test(t)}function n(t){return Ht.test(t)}function r(t){return typeof t===jt||!1}function i(t){return t&&typeof t===Et}function o(t){return typeof t===Lt}function a(t){return typeof t===Tt}function s(t){return o(t)||null===t||""===t}function u(t){return Array.isArray(t)||t instanceof Array}function l(t,e){var n=Object.getOwnPropertyDescriptor(t,e);return o(t[e])||n&&n.writable}function c(t){return It.test(t)}function p(t,e){return(e||document).querySelectorAll(t)}function f(t,e){return(e||document).querySelector(t)}function h(){return document.createDocumentFragment()}function d(){return document.createTextNode("")}function g(t,e){return e?document.createElementNS("http://www.w3.org/2000/svg","svg"):document.createElement(t)}function m(t){if(t.outerHTML)return t.outerHTML;var e=g("div");return e.appendChild(t.cloneNode(!0)),e.innerHTML}function v(t,e){if(o(t.innerHTML)){var n=(new DOMParser).parseFromString(e,"application/xml"),r=t.ownerDocument.importNode(n.documentElement,!0);t.appendChild(r)}else t.innerHTML=e}function y(t,e){t.removeAttribute(e)}function b(t,e){return t.getAttribute(e)}function x(t,e,n){var r=At.exec(e);r&&r[1]?t.setAttributeNS(Mt,r[1],n):t.setAttribute(e,n)}function w(t,e,n){t.insertBefore(e,n.parentNode&&n)}function _(t,e){if(t)for(var n;n=$t.exec(t);)e(n[1].toLowerCase(),n[2]||n[3]||n[4])}function C(t,e,n){if(t){var r,i=e(t,n);if(i===!1)return;for(t=t.firstChild;t;)r=t.nextSibling,C(t,e,i),t=r}}function N(t){return Object.assign?Object.assign({},t):M({},t)}function O(t,e){for(var n,r=t?t.length:0,i=0;i<r;++i)n=t[i],e(n,i)===!1&&i--;return t}function T(t,e){return~t.indexOf(e)}function E(t){return t.replace(/-(\w)/g,function(t,e){return e.toUpperCase()})}function L(t,e){return t.slice(0,e.length)===e}function j(t,e,n,r){return Object.defineProperty(t,e,M({value:n,enumerable:!1,writable:!1,configurable:!0},r)),t}function M(t){for(var e,n=arguments,r=1;r<n.length;++r)if(e=n[r])for(var i in e)l(t,i)&&(t[i]=e[i]);return t}function A(t,e,n){var r=this._parent,i=this._item;if(!i)for(;r&&!i;)i=r._item,r=r._parent;l(n,"currentTarget")&&(n.currentTarget=t),l(n,"target")&&(n.target=n.srcElement),l(n,"which")&&(n.which=n.charCode||n.keyCode),n.item=i,e.call(this,n),n.preventUpdate||ut(this).update()}function S(t,e,n,r){var i,o=A.bind(r,n,e);return n.addEventListener?(i=t.replace(Wt,""),n._riotEvents||(n._riotEvents={}),n._riotEvents[t]&&n.removeEventListener(i,n._riotEvents[t]),n._riotEvents[t]=o,void n.addEventListener(i,o,!1)):void(n[t]=o)}function R(t,e){var n,r=qt(t.value,e);if(t.tag&&t.tagName===r)return void t.tag.update();if(t.tag){var i=t.tag.opts.dataIs,o=t.tag._parent.tags;ht(o,i,t.tag)}t.impl=_t[r],n={root:t.dom,parent:e,hasImpl:!0,tagName:r},t.tag=st(t.impl,n,t.dom.innerHTML,e),t.tagName=r,t.tag.mount(),t.tag.update(),e.on("unmount",function(){var e=t.tag.opts.dataIs,n=t.tag.parent.tags,r=t.tag._parent.tags;ht(n,e,t.tag),ht(r,e,t.tag),t.tag.unmount()})}function k(t){var e,n=t.dom,i=t.attr,a=qt(t.expr,this),s="value"===i,u=t.root&&"VIRTUAL"===t.root.tagName,l=n&&(t.parent||n.parentNode);if(t.bool?a=!!a&&i:(o(a)||null===a)&&(a=""),t._riot_id){if(t.isMounted)t.update();else if(t.mount(),u){var c=document.createDocumentFragment();mt.call(t,c),t.root.parentElement.replaceChild(c,t.root)}}else{if(e=t.value,t.value=a,t.update)return void t.update();if(e!==a){if(t.isRtag&&a)return R(t,this);if(!s||n.value!==a){if(!i)return a+="",void(l&&(t.parent=l,"TEXTAREA"===l.tagName?(l.value=a,Bt||(n.nodeValue=a)):n.nodeValue=a));if(y(n,i),r(a))S(i,a,n,this);else if(/^(show|hide)$/.test(i))"hide"===i&&(a=!a),n.style.display=a?"":"none";else if(s)n.value=a;else if(L(i,Nt)&&i!==Ot)a&&x(n,i.slice(Nt.length),a);else{if("selected"===i&&l&&/^(SELECT|OPTGROUP)$/.test(l.nodeName)&&a&&(l.value=n.value),t.bool&&(n[i]=a,!a))return;(0===a||a&&typeof a!==Et)&&x(n,i,a)}}}}}function I(t){O(t,k.bind(this))}function P(t,e,n,r){var i=r?Object.create(r):{};return i[t.key]=e,t.pos&&(i[t.pos]=n),i}function $(t,e,n,r){for(var i,o=e.length,a=t.length;o>a;)i=e[--o],e.splice(o,1),i.unmount(),ht(r.tags,n,i,!0)}function H(t){var e=this;O(Object.keys(this.tags),function(n){var r=e.tags[n];u(r)?O(r,function(e){at.apply(e,[n,t])}):at.apply(r,[n,t])})}function B(t,e,n){n?vt.apply(this,[t,e]):w(t,this.root,e.root)}function F(t,e,n){n?mt.apply(this,[t,e]):w(t,this.root,e.root)}function D(t,e){e?mt.call(this,t):t.appendChild(this.root)}function V(t){for(var e=0;e<t.length;e++)if(t[e].__riot1374){t.selectedIndex=e,delete t[e].__riot1374;break}}function U(t,e,n){y(t,"each");var r,i=typeof b(t,"no-reorder")!==Tt||y(t,"no-reorder"),o=ct(t),a=_t[o]||{tmpl:m(t)},s=Rt.test(o),l=t.parentNode,c=d(),p=it(t),f=b(t,"if"),g="option"===o.toLowerCase(),v=[],x=[],w=!0,_=!_t[o],C="VIRTUAL"===t.tagName;return n=qt.loopKeys(n),n.isLoop=!0,f&&y(t,"if"),l.insertBefore(c,t),l.removeChild(t),n.update=function(){var m,y,b,N=qt(n.val,e);l=c.parentNode,m?(b=d(""),m.insertBefore(b,l),m.removeChild(l)):y=h(),u(N)||(r=N||!1,N=r?Object.keys(N).map(function(t){return P(n,t,N[t])}):[]),f&&(N=N.filter(function(t,r){var i=P(n,t,r,e);return!!qt(f,i)})),O(N,function(u,c){var f=i&&typeof u===Et&&!r,h=x.indexOf(u),d=~h&&f?h:c,g=v[d];if(u=!r&&n.key?P(n,u,c):u,!f&&!g||f&&!~h||!g){var m=c===v.length;g=new rt(a,{parent:e,isLoop:w,isAnonymous:_,root:s?l:t.cloneNode(),item:u},t.innerHTML),g.mount(),m?D.apply(g,[y||l,C]):F.apply(g,[l,v[c],C]),m||x.splice(c,0,u),v.splice(c,0,g),p&&ft(e.tags,o,g,!0),d=c}else g.update(u);d!==c&&f&&(B.apply(g,[l,v[c],C]),n.pos&&(g[n.pos]=c),v.splice(c,0,v.splice(d,1)[0]),x.splice(c,0,x.splice(d,1)[0]),!p&&g.tags&&H.call(g,c)),g._item=u,j(g,"_parent",e)}),$(N,v,o,e),g&&Ft&&!l.multiple&&V(l),x=N.slice(),y?l.insertBefore(y,c):(m.insertBefore(l,b),m.removeChild(b))},n.unmount=function(){O(v,function(t){t.unmount()})},n}function z(t,e,n){var r=this,i={parent:{children:e}};C(t,function(e,i){var o,a,s,u=e.nodeType,l=i.parent;if(!n&&e===t)return{parent:l};if(3===u&&"STYLE"!==e.parentNode.tagName&&qt.hasExpr(e.nodeValue)&&l.children.push({dom:e,expr:e.nodeValue}),1!==u)return i;if(o=b(e,"each"))return l.children.push(U(e,r,o)),!1;if(o=b(e,"if"))return l.children.push(Object.create(Xt).init(e,r,o)),!1;if((a=b(e,Ot))&&qt.hasExpr(a))return l.children.push({isRtag:!0,expr:a,dom:e}),!1;if(s=it(e),s&&(e!==t||n)){var c={root:e,parent:r,hasImpl:!0};return l.children.push(st(s,c,e.innerHTML,r)),!1}return G.apply(r,[e,e.attributes,function(t,e){e&&l.children.push(e)}]),{parent:l}},i)}function G(t,e,r){var i=this;O(e,function(e){var o,a=e.name,s=n(a);~["ref","data-ref"].indexOf(a)?o=Object.create(Yt).init(t,a,e.value,i):qt.hasExpr(e.value)&&(o={dom:t,expr:e.value,attr:e.name,bool:s}),r(e,o)})}function K(t,e,n){var r="o"===n[0],i=r?"select>":"table>";if(t.innerHTML="<"+i+e.trim()+"</"+i,i=t.firstChild,r)i.selectedIndex=-1;else{var o=re[n];o&&1===i.childElementCount&&(i=f(o,i))}return i}function q(t,e){if(!Jt.test(t))return t;var n={};return e=e&&e.replace(ee,function(t,e,r){return n[e]=n[e]||r,""}).trim(),t.replace(ne,function(t,e,r){return n[e]||r||""}).replace(te,function(t,n){return e||n||""})}function Z(t,n){var r=t&&t.match(/^\s*<([-\w]+)/),i=r&&r[1].toLowerCase(),o=g(oe,e(i));return t=q(t,n),ie.test(i)?o=K(o,t,i):v(o,t),o.stub=!0,o}function Q(t,e){var n=this,r=n.name,i=n.tmpl,o=n.css,a=n.attrs,s=n.onCreate;return _t[r]||(W(r,i,o,a,s),_t[r].class=this.constructor),gt(t,r,e,this),this}function W(t,e,n,i,o){return r(i)&&(o=i,/^[\w\-]+\s?=/.test(n)?(i=n,n=""):i=""),n&&(r(n)?o=n:Gt.add(n)),t=t.toLowerCase(),_t[t]={name:t,tmpl:e,attrs:i,fn:o},t}function X(t,e,n,r,i){n&&Gt.add(n,t);var o=!!_t[t];return _t[t]={name:t,tmpl:e,attrs:r,fn:i},o&&riot.util.hotReloader&&riot.util.hotReloader(t),t}function Y(t,e,n){function r(t){if(t.tagName){var i=b(t,Ot);e&&i!==e&&(i=e,x(t,Ot,e));var a=gt(t,i||t.tagName.toLowerCase(),n);a&&o.push(a)}else t.length&&O(t,r)}var o=[];Gt.inject(),i(e)&&(n=e,e=0);var s,u;if(a(t)?(t="*"===t?u=yt():t+yt(t.split(/, */)),s=t?p(t):[]):s=t,"*"===e){if(e=u||yt(),s.tagName)s=p(e,s);else{var l=[];O(s,function(t){return l.push(p(e,t))}),s=l}e=0}return r(s),o}function J(t,e,n){if(i(t))return void J("__unnamed_"+ue++,t,!0);var a=n?se:ae;if(!e){if(o(a[t]))throw new Error("Unregistered mixin: "+t);return a[t]}a[t]=r(e)?M(e.prototype,a[t]||{})&&e:M(a[t]||{},e)}function tt(){return O(wt,function(t){return t.update()})}function et(t){delete _t[t]}function nt(t,e,n,r,i){if(!t||!n){var o=!n&&t?this:e||this;O(i,function(t){t.expr&&I.call(o,[t.expr]),r[E(t.name)]=t.expr?t.expr.value:t.value})}}function rt(t,e,n){var i,o=N(e.opts),s=e.parent,u=e.isLoop,l=e.isAnonymous,c=pt(e.item),p=[],f=[],h=[],d=e.root,g=e.tagName||d.tagName.toLowerCase(),m=[];Qt(this),t.name&&d._tag&&d._tag.unmount(!0),this.isMounted=!1,d.isLoop=u,j(this,"_internal",{isAnonymous:l,instAttrs:p,innerHTML:n,virts:[],tail:null,head:null}),j(this,"_riot_id",++le),M(this,{parent:s,root:d,opts:o},c),j(this,"tags",{}),j(this,"refs",{}),i=Z(t.tmpl,n),j(this,"update",function(t){if(!r(this.shouldUpdate)||this.shouldUpdate())return t=pt(t),u&&l&&ot.apply(this,[this.parent,m]),M(this,t),nt.apply(this,[u,s,l,o,p]),this.isMounted&&this.trigger("update",t),I.call(this,h),this.isMounted&&this.trigger("updated"),this}),j(this,"mixin",function(){var t=this;return O(arguments,function(e){var n,i,o=[];e=a(e)?J(e):e,n=r(e)?new e:e;var s=Object.getPrototypeOf(n);do o=o.concat(Object.getOwnPropertyNames(i||n));while(i=Object.getPrototypeOf(i||n));O(o,function(e){if("init"!==e){var i=Object.getOwnPropertyDescriptor(n,e)||Object.getOwnPropertyDescriptor(s,e),o=i&&(i.get||i.set);!t.hasOwnProperty(e)&&o?Object.defineProperty(t,e,i):t[e]=r(n[e])?n[e].bind(t):n[e]}}),n.init&&n.init.bind(t)()}),this}),j(this,"mount",function(){var e=this;d._tag=this;var n=J(Ct);if(n)for(var r in n)n.hasOwnProperty(r)&&e.mixin(n[r]);if(G.apply(s,[d,d.attributes,function(t,n){!l&&Yt.isPrototypeOf(n)&&(n.tag=e),t.expr=n,p.push(t)}]),this._parent&&l&&ot.apply(this,[this._parent,m]),nt.apply(this,[u,s,l,o,p]),t.fn&&t.fn.call(this,o),this.trigger("before-mount"),f=[],_(t.attrs,function(t,e){f.push({name:t,value:e})}),G.apply(this,[d,f,function(t,e){e?h.push(e):x(d,t.name,t.value)}]),z.apply(this,[i,h,!1]),this.update(c),u&&l)this.root=d=i.firstChild;else{for(;i.firstChild;)d.appendChild(i.firstChild);d.stub&&(d=s.root)}j(this,"root",d),this.isMounted=!0,!this.parent||this.parent.isMounted?this.trigger("mount"):this.parent.one("mount",function(){e.trigger("mount")})}),j(this,"unmount",function(t){var e,n=this.root,r=n.parentNode,i=wt.indexOf(this);if(this.trigger("before-unmount"),~i&&wt.splice(i,1),r){if(s)e=ut(s),ht(e.tags,g,this);else for(;n.firstChild;)n.removeChild(n.firstChild);t?y(r,Ot):r.removeChild(n)}this._internal.virts&&O(this._internal.virts,function(t){t.parentNode&&t.parentNode.removeChild(t)}),lt(h),O(p,function(t){return t.expr&&t.expr.unmount&&t.expr.unmount()}),this.trigger("unmount"),this.off("*"),this.isMounted=!1,delete this.root._tag})}function it(t){return t.tagName&&_t[b(t,Ot)||b(t,Ot)||t.tagName.toLowerCase()]}function ot(t,e){var n=this;O(Object.keys(t),function(r){var i=!c(r)&&T(e,r);(o(n[r])||i)&&(i||e.push(r),n[r]=t[r])})}function at(t,e){var n,r=this.parent;r&&(n=r.tags[t],u(n)?n.splice(e,0,n.splice(n.indexOf(this),1)[0]):ft(r.tags,t,this))}function st(t,e,n,r){var i=new rt(t,e,n),o=e.tagName||ct(e.root,!0),a=ut(r);return i.parent=a,i._parent=r,ft(a.tags,o,i),a!==r&&ft(r.tags,o,i),e.root.innerHTML="",i}function ut(t){for(var e=t;e._internal.isAnonymous&&e.parent;)e=e.parent;return e}function lt(t){O(t,function(t){t instanceof rt?t.unmount(!0):t.unmount&&t.unmount()})}function ct(t,e){var n=it(t),r=!e&&b(t,"name"),i=r&&!qt.hasExpr(r)?r:n?n.name:t.tagName.toLowerCase();return i}function pt(t){if(!(t instanceof rt||t&&typeof t.trigger===jt))return t;var e={};for(var n in t)It.test(n)||(e[n]=t[n]);return e}function ft(t,e,n,r){var i=t[e],o=u(i);i&&i===n||(!i&&r?t[e]=[n]:i?(!o||o&&!T(i,n))&&(o?i.push(n):t[e]=[i,n]):t[e]=n)}function ht(t,e,n,r){u(t[e])?(O(t[e],function(r,i){r===n&&t[e].splice(i,1)}),t[e].length?1!==t[e].length||r||(t[e]=t[e][0]):delete t[e]):delete t[e]}function dt(t){for(;t;){if(t.inStub)return!0;t=t.parentNode}return!1}function gt(t,e,n,r){var i=_t[e],o=_t[e].class,a=r||(o?Object.create(o.prototype):{}),s=t._innerHTML=t._innerHTML||t.innerHTML;t.innerHTML="";var u={root:t,opts:n};return n&&n.parent&&(u.parent=n.parent),i&&t&&rt.apply(a,[i,u,s]),a&&a.mount&&(a.mount(!0),T(wt,a)||wt.push(a)),a}function mt(t,e){var n,r,i=this,o=d(),a=d(),s=h();for(this._internal.head=this.root.insertBefore(o,this.root.firstChild),this._internal.tail=this.root.appendChild(a),r=this._internal.head;r;)n=r.nextSibling,s.appendChild(r),i._internal.virts.push(r),r=n;e?t.insertBefore(s,e._internal.head):t.appendChild(s)}function vt(t,e){for(var n,r=this,i=this._internal.head,o=h();i;)if(n=i.nextSibling,o.appendChild(i),i=n,i===r._internal.tail){o.appendChild(i),t.insertBefore(o,e._internal.head);break}}function yt(t){if(!t){var e=Object.keys(_t);return e+yt(e)}return t.filter(function(t){return!/[^-\w]/.test(t)}).reduce(function(t,e){var n=e.trim().toLowerCase();return t+",["+Ot+'="'+n+'"]'},"")}var bt,xt,wt=[],_t={},Ct="__global_mixin",Nt="riot-",Ot="data-is",Tt="string",Et="object",Lt="undefined",jt="function",Mt="http://www.w3.org/1999/xlink",At=/^xlink:(\w+)/,St=typeof window===Lt?void 0:window,Rt=/^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,kt=/^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,It=/^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|parent|opts|trigger|o(?:n|ff|ne))$/,Pt=/^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/,$t=/([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g,Ht=/^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,Bt=0|(St&&St.document||{}).documentMode,Ft=St&&!!St.InstallTrigger,Dt=Object.freeze({isSVGTag:e,isBoolAttr:n,isFunction:r,isObject:i,isUndefined:o,isString:a,isBlank:s,isArray:u,isWritable:l,isReservedName:c}),Vt=Object.freeze({$$:p,$:f,createFrag:h,createDOMPlaceholder:d,mkEl:g,getOuterHTML:m,setInnerHTML:v,remAttr:y,getAttr:b,setAttr:x,safeInsert:w,walkAttrs:_,walkNodes:C}),Ut={},zt=[];St&&(bt=function(){var t=g("style");x(t,"type","text/css");var e=f("style[type=riot]");return e?(e.id&&(t.id=e.id),e.parentNode.replaceChild(t,e)):document.getElementsByTagName("head")[0].appendChild(t),t}(),xt=bt.styleSheet);var Gt={styleNode:bt,add:function(t,e){e?Ut[e]=t:zt.push(t)},inject:function(){if(St){var t=Object.keys(Ut).map(function(t){return Ut[t]}).concat(zt).join("\n");xt?xt.cssText=t:bt.innerHTML=t}}},Kt=function(t){function e(t){return t}function n(t,e){return e||(e=b),new RegExp(t.source.replace(/{/g,e[2]).replace(/}/g,e[3]),t.global?l:"")}function r(t){if(t===m)return v;var e=t.split(" ");if(2!==e.length||h.test(t))throw new Error('Unsupported brackets "'+t+'"');return e=e.concat(t.replace(d,"\\").split(" ")),e[4]=n(e[1].length>1?/{[\S\s]*?}/:v[4],e),e[5]=n(t.length>3?/\\({|})/g:v[5],e),e[6]=n(v[6],e),e[7]=RegExp("\\\\("+e[3]+")|([[({])|("+e[3]+")|"+f,l),e[8]=t,e}function i(t){return t instanceof RegExp?s(t):b[t]}function o(t){(t||(t=m))!==b[8]&&(b=r(t),s=t===m?e:n,b[9]=s(v[9])),y=t}function a(t){var e;t=t||{},e=t.brackets,Object.defineProperty(t,"brackets",{set:o,get:function(){return y},enumerable:!0}),u=t,o(e)}var s,u,l="g",c=/\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g,p=/"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'/g,f=p.source+"|"+/(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source+"|"+/\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?(\/)[gim]*/.source,h=RegExp("[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]"),d=/(?=[[\]()*+?.^$|])/g,g={"(":RegExp("([()])|"+f,l),"[":RegExp("([[\\]])|"+f,l),"{":RegExp("([{}])|"+f,l)},m="{ }",v=["{","}","{","}",/{[^}]*}/,/\\([{}])/g,/\\({)|{/g,RegExp("\\\\(})|([[({])|(})|"+f,l),m,/^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/,/(^|[^\\]){=[\S\s]*?}/],y=t,b=[];return i.split=function(t,e,n){function r(t){e||a?l.push(t&&t.replace(n[5],"$1")):l.push(t)}function i(t,e,n){var r,i=g[e];for(i.lastIndex=n,n=1;(r=i.exec(t))&&(!r[1]||(r[1]===e?++n:--n)););return n?t.length:i.lastIndex}n||(n=b);var o,a,s,u,l=[],c=n[6];for(a=s=c.lastIndex=0;o=c.exec(t);){if(u=o.index,a){if(o[2]){c.lastIndex=i(t,o[2],c.lastIndex);continue}if(!o[3])continue}o[1]||(r(t.slice(s,u)),s=c.lastIndex,c=n[6+(a^=1)],c.lastIndex=s)}return t&&s<t.length&&r(t.slice(s)),l},i.hasExpr=function(t){return b[4].test(t)},i.loopKeys=function(t){var e=t.match(b[9]);return e?{key:e[1],pos:e[2],val:b[0]+e[3].trim()+b[1]}:{val:t.trim()}},i.array=function(t){return t?r(t):b},Object.defineProperty(i,"settings",{set:a,get:function(){return u}}),i.settings="undefined"!=typeof riot&&riot.settings||{},i.set=o,i.R_STRINGS=p,i.R_MLCOMMS=c,i.S_QBLOCKS=f,i}(),qt=function(){function t(t,r){return t?(a[t]||(a[t]=n(t))).call(r,e):t}function e(e,n){t.errorHandler&&(e.riotData={tagName:n&&n.root&&n.root.tagName,_riot_id:n&&n._riot_id},t.errorHandler(e))}function n(t){var e=r(t);return"try{return "!==e.slice(0,11)&&(e="return "+e),new Function("E",e+";")}function r(t){var e,n=[],r=Kt.split(t.replace(c,'"'),1);if(r.length>2||r[0]){var o,a,s=[];for(o=a=0;o<r.length;++o)e=r[o],e&&(e=1&o?i(e,1,n):'"'+e.replace(/\\/g,"\\\\").replace(/\r\n?|\n/g,"\\n").replace(/"/g,'\\"')+'"')&&(s[a++]=e);e=a<2?s[0]:"["+s.join(",")+'].join("")'}else e=i(r[1],0,n);return n[0]&&(e=e.replace(p,function(t,e){return n[e].replace(/\r/g,"\\r").replace(/\n/g,"\\n")})),e}function i(t,e,n){function r(e,n){var r,i=1,o=f[e];for(o.lastIndex=n.lastIndex;r=o.exec(t);)if(r[0]===e)++i;else if(!--i)break;n.lastIndex=i?t.length:o.lastIndex}if(t=t.replace(l,function(t,e){return t.length>2&&!e?s+(n.push(t)-1)+"~":t}).replace(/\s+/g," ").trim().replace(/\ ?([[\({},?\.:])\ ?/g,"$1")){for(var i,a=[],c=0;t&&(i=t.match(u))&&!i.index;){var p,h,d=/,|([[{(])|$/g;for(t=RegExp.rightContext,p=i[2]?n[i[2]].slice(1,-1).trim().replace(/\s+/g," "):i[1];h=(i=d.exec(t))[1];)r(h,d);h=t.slice(0,i.index),t=RegExp.rightContext,a[c++]=o(h,1,p)}t=c?c>1?"["+a.join(",")+'].join(" ").trim()':a[0]:o(t,e)}return t}function o(t,e,n){var r;return t=t.replace(d,function(t,e,n,i,o){return n&&(i=r?0:i+t.length,"this"!==n&&"global"!==n&&"window"!==n?(t=e+'("'+n+h+n,i&&(r="."===(o=o[i])||"("===o||"["===o)):i&&(r=!g.test(o.slice(i)))),t}),r&&(t="try{return "+t+"}catch(e){E(e,this)}"),n?t=(r?"function(){"+t+"}.call(this)":"("+t+")")+'?"'+n+'":""':e&&(t="function(v){"+(r?t.replace("return ","v="):"v=("+t+")")+';return v||v===0?v:""}.call(this)'),t}var a={};t.haveRaw=Kt.hasRaw,t.hasExpr=Kt.hasExpr,t.loopKeys=Kt.loopKeys,t.clearCache=function(){a={}},t.errorHandler=null;var s="‚Åó",u=/^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\u2057(\d+)~):/,l=RegExp(Kt.S_QBLOCKS,"g"),c=/\u2057/g,p=/\u2057(\d+)~/g,f={"(":/[()]/g,"[":/[[\]]/g,"{":/[{}]/g},h='"in this?this:'+("object"!=typeof window?"global":"window")+").",d=/[,{][$\w]+(?=:)|(^ *|[^$\w\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g,g=/^(?=(\.[$\w]+))\1(?:[^.[(]|$)/;return t.version=Kt.version="v2.4.1",t}(),Zt=Object.freeze({inherit:N,each:O,contains:T,toCamel:E,startsWith:L,defineProperty:j,extend:M}),Qt=function(t){t=t||{};var e={},n=Array.prototype.slice;return Object.defineProperties(t,{on:{value:function(n,r){return"function"==typeof r&&(e[n]=e[n]||[]).push(r),t},enumerable:!1,writable:!1,configurable:!1},off:{value:function(n,r){if("*"!=n||r)if(r)for(var i,o=e[n],a=0;i=o&&o[a];++a)i==r&&o.splice(a--,1);else delete e[n];else e={};return t},enumerable:!1,writable:!1,configurable:!1},one:{value:function(e,n){function r(){t.off(e,r),n.apply(t,arguments)}return t.on(e,r)},enumerable:!1,writable:!1,configurable:!1},trigger:{value:function(r){var i,o,a,s=arguments,u=arguments.length-1,l=new Array(u);for(a=0;a<u;a++)l[a]=s[a+1];for(i=n.call(e[r]||[],0),a=0;o=i[a];++a)o.apply(t,l),i[a]!==o&&a--;return e["*"]&&"*"!=r&&t.trigger.apply(t,["*",r].concat(l)),t},enumerable:!1,writable:!1,configurable:!1}}),t},Wt=/^on/,Xt={init:function(t,e,n){y(t,"if"),this.parentTag=e,this.expr=n,this.stub=document.createTextNode(""),this.pristine=t;var r=t.parentNode;return r.insertBefore(this.stub,t),r.removeChild(t),this},update:function(){var t=qt(this.expr,this.parentTag);t&&!this.current?(this.current=this.pristine.cloneNode(!0),this.stub.parentNode.insertBefore(this.current,this.stub),this.expressions=[],z.apply(this.parentTag,[this.current,this.expressions,!0])):!t&&this.current&&(lt(this.expressions),this.current.parentNode.removeChild(this.current),this.current=null,this.expressions=[]),t&&I.call(this.parentTag,this.expressions)},unmount:function(){lt(this.expressions||[]),delete this.pristine,delete this.parentNode,delete this.stub}},Yt={init:function(t,e,n,r){return this.dom=t,this.attr=e,this.rawValue=n,this.parent=r,this.hasExp=qt.hasExpr(n),this.firstRun=!0,this},update:function(){var t=this.rawValue;if(this.hasExp&&(t=qt(this.rawValue,this.parent)),this.firstRun||t!==this.value){var e=this.parent&&ut(this.parent),n=this.tag||this.dom;!s(this.value)&&e&&ht(e.refs,this.value,n),s(t)?y(this.dom,this.attr):(e&&ft(e.refs,t,n),x(this.dom,this.attr,t)),this.value=t,this.firstRun=!1}},unmount:function(){var t=this.tag||this.dom,e=this.parent&&ut(this.parent);!s(this.value)&&e&&ht(e.refs,this.value,t),delete this.dom,delete this.parent}},Jt=/<yield\b/i,te=/<yield\s*(?:\/>|>([\S\s]*?)<\/yield\s*>|>)/gi,ee=/<yield\s+to=['"]([^'">]*)['"]\s*>([\S\s]*?)<\/yield\s*>/gi,ne=/<yield\s+from=['"]?([-\w]+)['"]?\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/gi,re={tr:"tbody",th:"tr",td:"tr",col:"colgroup"},ie=Bt&&Bt<10?Rt:kt,oe="div",ae={},se=ae[Ct]={},ue=0,le=0,ce=Object.freeze({getTag:it,inheritFrom:ot,moveChildTag:at,initChildTag:st,getImmediateCustomParentTag:ut,unmountAll:lt,getTagName:ct,cleanUpData:pt,arrayishAdd:ft,arrayishRemove:ht,isInStub:dt,mountTo:gt,makeVirtual:mt,moveVirtual:vt,selectTags:yt}),pe=Object.create(Kt.settings),fe={tmpl:qt,brackets:Kt,styleManager:Gt,vdom:wt,styleNode:Gt.styleNode,dom:Vt,check:Dt,misc:Zt,tags:ce};t.settings=pe,t.util=fe,t.observable=Qt,t.Tag=Q,t.tag=W,t.tag2=X,t.mount=Y,t.mixin=J,t.update=tt,t.unregister=et,Object.defineProperty(t,"__esModule",{value:!0})});
</script>
		<script>/*
global log
global riot
global localStorage
global fetch
*/		
				
	var remembers =	function (data) {
						return	function (self) {
									for (var name in data) {
										self .remembers (name);
										self .stuff .trigger (name, data [name]);
									}
								};
					};
					
					
	var trim_trailing_slash =	function (path) {
									if (path [path .length - 1] === '/')
										return path .slice (0, -1);
									else
										return path;
								};
	var replace_all =	function (search, replacement) {
							return	function (string) {
									    var target = string;
									    return target .split (search) .join (replacement);
									};
						};
	
				
				
									var repeat =	function (times) {
														return	function (what) {
																	var array = [];
																	for (var key = 0; key < times; key ++) {
																		array .push (what);
																	};
																	return array;
																};
													};
									var range =	function (range) {
													var the_range = [];
													for (var key = range .from; key <= range .to; key ++) {
														the_range .push (key);
													};
													Object .defineProperty (the_range, 'from', { value: range .from });
													Object .defineProperty (the_range, 'to', { value: range .to });
													return the_range;
												};
									var spread =	function (amount) {
														var front_spread = Math .floor (amount / 2);
														var rear_spread = Math .floor (amount / 2);
														return	function (position) {
																	/*var the_spread = [];
																	for (var key = position .at - front_spread; key <= position .at + rear_spread; key ++) {
																		the_spread .push (key);
																	};
																	Object .defineProperty (the_spread, 'from', { value: position .at - front_spread });
																	Object .defineProperty (the_spread, 'to', { value: position .at + rear_spread });
																	Object .defineProperty (the_spread, 'at', { value: position .at });*/
																	return	{
																				from: position .at - front_spread,
																				to: position .at + rear_spread,
																				at: position .at
																			};
																};
													};
									var as =	function (key) {
													return	function (value) {
																var item = {};
																item [key] = value;
																return item;
															};
												};
									var pluck =	function (key) {
													return	function (item) {
																return item [key];
															};
												};
									var having =	function (key) {
														return	function (value) {
																	return	function (item) {
																				item [key] = value;
																				return item;
																			};
																};
													};
										var if_positive =	function (num) {
																return (num > 0 ? num : 0);
															};
										var count =	function (range) {
														return range .to - range .from + 1;
													};
																	var range_intersection =	function (/*args*/) {
																									var args = [] .slice .call (arguments);
																									/*log (range_one, range_two,	{
																																	from: Math .max (range_one .from, range_two .from),
																																	to: Math .min (range_one .to, range_two .to)
																																});*/
																									
																									var positions = args
																														.map (function (range) { return range .at; })
																														.filter (function (at) { return at != null; });
																									
																									var position = 0;
																									if (positions .length) {
																										position =	positions
																														.reduce (function(sum, position) {
																															return sum + position;
																														}, 0)
																													/ positions .length;
																									}
																									
																									//log ('positions', positions, position);
																									
																									
																									return	{
																												from: Math .max .apply (Math, args .map (pluck ('from'))),
																												to: Math .min .apply (Math, args .map (pluck ('to'))),
																												at: Math .floor (position)
																											};
																								};
								var same =	function (place_one, place_two) {
												return place_one && place_two && place_one ['to'] === place_two ['to'] && place_one ['from'] === place_two ['from'];
											};
								var included_in =	function (bigger, smaller) {
														return same (
																	range_intersection (bigger, smaller),
																	smaller);
													};
								var position_diff =	function (position_one, position_two) {
														return Math .abs (position_one .at - position_two .at);
													};
									
			var on_next_tick =	function (action) {
									requestAnimationFrame (action);
								};
								
								
			var logged =	function (/* args */) {
								log .apply (this, arguments);
								return arguments [arguments .length - 1];
							};
			var logged_with =	function (/* args */) {
									var args = [] .slice .call (arguments);
									return	function (item) {
												log .apply (null, args .concat (item));
												return item;
											};
								};
								

var display_errors =	function (event, self) {
							self .stuff .on (event, function (data) {
								(data || {}) .error && alert ((data || {}) .error);
							});
						};

			var tag_name =	function (page_name) {
								return 'screen-page-' + replace_all ('/', '-') (trim_trailing_slash (page_name));
							};
								
			var page_name =	function (path) {
								return path .slice (path .indexOf ('#') + 1, path .indexOf ('/#') === -1 ? undefined : path .indexOf ('/#'));
							};
			var page_arguments =	function (path) {
										return (path .indexOf ('/#') ? path .slice (path .indexOf ('/#') + 2) : '') .split ('/');
									};

								
								
										var diff =	function (to_where, here) {

														var diff =	{
																		front:	{
																					from: to_where .from,
																					to: here .from - 1
																				},
																		back:	{
																					from: here .to + 1,
																					to: to_where .to
																				}
																	};
																	
														if ( opposite (diff .front, diff .back) ) {
															var positive_front = positive (diff .front);
															var positive_back = positive (diff .back);
															diff =	//logged ('ex diff',
																		{
																			front: add_sign (sign (diff .front)) (minus (positive_front, positive_back)),
																			back: add_sign (sign (diff .back)) (minus (positive_back, positive_front))
																		}
																	/*)*/;
															//if ( inclusive ) ...
														}			
														
														diff .map = function (mapper) {
																		var self = this;
																		return	{
																					front:	function (array) {
																								var diff_count = if_positive ( - count (self .front) );
																								array .splice .apply (
																									array,
																									[
																										0,
																										diff_count
																									] .concat (
																										range (self .front) .map (mapper)
																									)
																								);
																								return array;
																							},
																					back:	function (array) {
																								var diff_count = if_positive ( - count (self .back) );
																								array .splice .apply (
																									array,
																									[
																										array .length - diff_count,
																										diff_count
																									] .concat (
																										range (self .back) .map (mapper)
																									)
																								);
																								return array;
																							}
																				};
																	};
														return diff;
													};
													
										var sign = count;
										var add_sign =	function (sign) {
															return	function (range) {
																		if (sign >= 0)
																			return range;
																		else
																			return range_invert (range);
																	};
														};
										var positive =	function (range) {
															return add_sign (sign (range)) (range);
														};
										var opposite =	function (range_one, range_two) {
															var sign_one = sign (range_one);
															var sign_two = sign (range_two);
															return	(sign_one > 0 && sign_two < 0)
																	|| (sign_one < 0 && sign_two > 0);
														};
										var minus =	function (range_one, range_two) {
														var intersection = range_intersection (range_one, range_two);
														if (sign (intersection) <= 0)
															return range_one;
														else if (intersection .from === range_one .from)
															return	{
																		from: intersection . to + 1,
																		to: range_one .to
																	};
														else
															return	{
																		from: range_one .from,
																		to: intersection .from - 1
																	};
													};
													
										var do_diffs =	function (diff_map, original) {
															return diff_map .front (diff_map .back (original));
														};
														
										var range_invert =	function (range) {
																return	{
																			from: range .to + 1,
																			to: range .from - 1
																		};
															};
										var range_add =	function (range_one, range_two) {
															if (range_one .to + 1 === range_two .from)
																return	{
																			from: range_one .from,
																			to: range_two .to
																		};
															else
																throw 'unaddable';
														};	
														
			
			var throttle =	function (callback, limit) {
							    var wait = false;                  // Initially, we're not waiting
							    return	function () {               // We return a throttled function
									        if (! wait) {                   // If we're not waiting
									            callback .apply (this, arguments);           // Execute users function
									            wait = true;               // Prevent future invocations
									            setTimeout (function () {   // After a period of time
									                wait = false;          // And allow future invocations
									            }, limit);
									        }
									    }
							};
			var adthrottle =	function (callback, limit) {
									var ad = false;
								    var wait = false;                  // Initially, we're not waiting
								    var adthrottled =	function () {               // We return a throttled function
													        if (! wait) {                   // If we're not waiting
													            callback .apply (this, arguments);           // Execute users function
													            wait = true;               // Prevent future invocations
													            setTimeout (function () {   // After a period of time
													                wait = false;          // And allow future invocations
													                if (ad) {
													                	ad = false;
													                	adthrottled ();
													                }
													            }, limit);
													        }
													        else {
													        	ad = true;
													        }
													    };
									return adthrottled;
								};
			var debounce =	function(func, wait, immediate) {
								var timeout;
								immediate = immediate ();
								return	function () {
											var context = this, args = arguments;
											var later =	function () {
															timeout = null;
															if (! immediate) func.apply(context, args);
														};
											var callNow = immediate && ! timeout;
											clearTimeout (timeout);
											timeout = setTimeout (later, wait);
											if (callNow) func .apply (context, args);
										};
							};
			/*var bounce =	function(func, wait) {
								var timeout;
								var queue = [];
								
								var run_queue =	function () {
													if (queue .length) {
														if ( ! timeout ) {
															var func = queue .shift ();
															func ();
															timeout =	setTimeout (function () {
																			timeout = null;
																			run_queue ();
																		}, wait);	
														}
													}
												};
								
								return	function () {
											var context = this, args = arguments;
											var later =	function () {
															func .apply (context, args);
														};
											queue .push (later);
											
											run_queue ();
										};
							};*/
			var prebounce =	function (func, initial_wait, wait) {
								var timeout =	setTimeout (function () {
													timeout = null;
													run_queue ();
												}, initial_wait);
								var on_queue = false;
								
								var run_queue =	function () {
													if (on_queue) {
														if ( ! timeout ) {
															on_queue = false;
															func ();
															timeout =	setTimeout (function () {
																			timeout = null;
																			run_queue ();
																		}, wait);	
														}
													}
												};
								
								return	function () {
											/*var context = this, args = arguments;
											var later =	function () {
															func .apply (context, args);
														};
											queue .push (later);*/
											//debugger;
											on_queue = true;
											
											run_queue ();
										};
							};//*/
			
			var one_at_a_time =	function (get_thing_to_do/* return promise */) {
									var doing;
									return	function () {
												if (! doing) {
													doing = get_thing_to_do .apply (this, arguments);
													doing .then (function () {
														doing = undefined;
													});
												}
											};
								};
			
							
			var i_promise =	function (what) {
								return new Promise (what);
							};
							
			var stars_text =	function (how_many_stars) {
									var text = '';
									var star = 0;
									for (; star < how_many_stars; star ++) {
										text += '\uF2FC';
									}
									if (how_many_stars % 1) {
										text += '\uF3AD';
										star ++;
									}
									for (; star < 5; star ++) {
										text += '\uF3AE';
									}
									return text;
								};
								
								
								
			var is_positive_integer =	function (string) {
										    var n = ~~Number (string);
										    return String (n) === string && n >= 0;
										};
										
										
			var without =	function (you) {
								return	function (baby) {
											var i = {};
											for (var key in baby) {
												i [key] = baby [key];
											}
											delete i [you];
											return i;
										};
							};
			var with_ =	function (you, heart) {
							return	function (baby) {
										var i = {};
										for (var key in baby) {
											i [key] = baby [key];
										}
										i [you] = heart;
										return i;
									};
						};
										
				
					
		var assemble =	function (module_set) {
			                if (module_set) {
	    						var modules = {};
	    						modules .length = 0;
	    						for (var module of module_set) {
	    							modules [module .order] = module;
	    							modules .length ++;
	    						}
	    						return [] .slice .call (modules);
			                }
						};
		var piece =	function (course_set) {
						if (course_set) {
							var courses = {};
							for (var course of course_set) {
								courses [course .id] = course;
							}
							return courses;
						}
					};
					
var cache =	function (uncached) {
				var cached = false;
				var cache;
				return	function () {
							if (! cached) {
								cached = true;
								cache = uncached ();
							}
							return cache;
						};
			};
			
			
var index =	function (test) {
				return	function (array) {
							for (var x = 0; x < array .length; x ++) {
							    if (test (array [x])) return x;
							}
							// not found, return fail value
							return -1;
						};
			};
			
			
/*var connect =	function (upstream) {
					return	function (downstream) {
								return	function (self) {
											pipe_through (upstream) (downstream) (self);
											var state;
											if (state = self .recalls (upstream))
												self .stuff .trigger (downstream, state);
										};
							};
				};*/
		
var pipe_through =	function (upstream) {
						return	function (downstream) {
									return	function (self) {
												var really = {};
											
												self .stuff .on (upstream, function (value, from_downstream) {
													if (really === from_downstream)
														self .stuff .trigger (downstream, value);
												});
												self .stuff .on (downstream, function (value) {
													self .stuff .trigger (upstream, value, really);
												});
											};
								};
					};
			
var push_fork =	function (upstream) {
					return	function (downstreams) {
								return	function (self) {
											var really = {};
									
											self .stuff .on (upstream, function (value, from_downstream) {
												if (really === from_downstream)
													for (var key in downstreams) {
														self .stuff .trigger (downstreams [key], value [key]);														
													}
											});
											
											for (var key in downstreams) {
												(function (key) {
													self .stuff .on (downstreams [key], function (value) {//log (downstreams [key], key, value);
														self .stuff .trigger (upstream, with_ (key, value) (self .recalls (upstream)), really);
													});			
												})(key);
											}
										};
							};
				};
				
					
					
					
var event_next =	function (event) {
						return	function (observable) {
									return	new Promise (function (resolve, reject) {
												/*try {*/
													observable .one (event, resolve);
												/*}
												catch (error) {
													reject (error);
												}*/
											});
								};
					};
				
				
				
				
				
var get_cache =	function (key) {
						var data = localStorage .getItem (key);
						return data && (data === 'undefined' ? undefined : JSON .parse (data));
					};
var set_cache =	function (key, value) {
					localStorage .setItem (key, JSON .stringify (value));
				};
					var set_path =	function (path, value) {//debugger;//log ('setpath', path, value);debugger;
							        	set_cache (path, value);
							        	setTimeout (cacher .trigger .bind (cacher, path, value), 0); //hack
									};
				
				
				
var cacher = riot .observable ();
var cache_path =	function (path) {
						return	function (request, response) {
							return	query (path, {
										method: request .method,
										headers: request .headers,
										body: request .body && JSON .stringify (request .body)
									}) .then (function (response_data) {
										var value = eval_response (response, { data: response_data, response: response_data });
								        if (JSON .stringify (value) !== JSON .stringify (get_cache (path))) {
								        	set_path (path, value);
								        	return value;
								        }
									})/* .catch (function (error) {
										log (error);
									})*/;
						};
					};
						var eval_response =	function (response, data) {
												return riot .util .tmpl (response, data);
											};
						var query =	function (path, request) {
										if (request .method === 'local') {
											log ('queryied local', path, request, request .body && (request .body === 'undefined' ? undefined : JSON .parse (request .body)));
											return	Promise .resolve (request .body && (request .body === 'undefined' ? undefined : JSON .parse (request .body)));
										}
										else {
											return	fetch (path, request)
														.then (function (response) {//log (response);
														    return response .json ();
														})
														.then (function (response) {
															log ('queryied network', path, request, response);
															return response;
														});
										}
									};
					
				

var check_out =	function (path, request, response) {
					add_temp (path, request, response);
					resolve_temps ();
				};
					var add_temp =	function (path, request, response) {
											var temps = get_cache (temp_key) || {};
											if (! temps [path]) {
												temps [path] = { request: request, response: response };
												set_cache (temp_key, temps);
											}
										};
					var resolve_temps =	function () {
											var temps = get_cache (temp_key) || {};
											for (var path in temps) {
												if (! resolutions [path]) {
													var request = temps [path] .request;
													var response = temps [path] .response;
													resolutions [path] =	cache_path (path) (request, response) .then (
																				remove_temp .bind (this, path)
																			);
												}
											};
										};
					var remove_temp =	function (path) {
												var temps = get_cache (temp_key) || {};
												if (temps [path]) {
													delete temps [path];
													delete resolutions [path];
													set_cache (temp_key, temps);
												}
											};
					var temp_key = '__temp__';
					var resolutions = {};

				
				
var read_path =	function (path) {
						return	function (request, response) {
									return	function () {
												check_out (path, eval_request (request), response);
												return get_cache (path);
											};
								};
					};
var edit_path =	function (path) {
					return	function (request, response, predicter) {
								return	function (data) {
											var value =	predicter (data);
											if (value && JSON .stringify (value) !== JSON .stringify (get_cache (path)))
									        	set_path (path, value);
												
											check_out (path, eval_request (request, { data: data }), response);
										};
							};
				};
var write_path =	function (path) {
						return	function (request, response) {
									return	function (data) {
												check_out (path, eval_request (request, { data: data }), response);
											};
								};
					};
					var eval_request =	function (request, data) {
											return	{
														method: request .method && riot .util .tmpl (request .method, data),
														headers: request .headers && riot .util .tmpl (request .headers, data),
														body: request .body && riot .util .tmpl (request .body, data)
													};
										};
				
				
				
var pipe_read =	function (name, path, request, response) {
					request = request || {};
					response = response || '{ data }';
					
					var read = read_path (path) (request .read || {}, response);
					
					return	function (self) {
								var self_recalls = self .recalls;
								self .recalls =	function (event) {
													if (event === name) {
														return read ();
													}
													else {
														return self_recalls .apply (this, arguments);
													}
												};
								
								var cache_listener;
								self .understands (name);//log ('cacher subscribe once', path);
								cacher .on (path, cache_listener = function (data) {
									self .stuff .trigger (name, data, cacher);
								});
								self .on ('unmount', function () {
									cacher .off (path, cache_listener);
								});
							};
				};
var pipe_edit =	function (name, path, request, response, predicter) {
					request = request || {};
					response = response || '{ data }';
					
					var read = read_path (path) (request .read || {}, response);
					var edit = edit_path (path) (request .edit || {}, response, predicter || function (data) { return undefined; });
					
					return	function (self) {
								var self_recalls = self .recalls;
								self .recalls =	function (event) {
													if (event === name) {
														return read ();
													}
													else {
														return self_recalls .apply (this, arguments);
													}
												};
								
								var cache_listener;
								self .understands (name);//log ('cacher subscribe once', path);
								cacher .on (path, cache_listener = function (data) {
									self .stuff .trigger (name, data, cacher);
								});
								self .on ('unmount', function () {
									cacher .off (path, cache_listener);
								});
								self .stuff .on (name, function (data, from_cacher) {
									if (! from_cacher) {
										edit (data);
									}
								});
							};
				};
var pipe_write =	function (name, path, request, response) {
						request = request || {};
	
						var write = write_path (path) (request .write || {}, response);
						
						return	function (self) {
									var cache_listener;
									self .understands (name);//log ('cacher subscribe once', path);
									self .stuff .on (name, function (data, from_cacher) {
										if (! from_cacher) {
											cacher .one (path, function (data) {//console.log('cacher says hi');
												set_cache (path, undefined);
												self .stuff .trigger (name, data, cacher);
											});
											write (data);
										}
									});
								};
					};
				

				
	
				


var logged_in_header =	function () {
							var login_value = get_cache (backend_path + '/login');
							return login_value && { 'x-user': login_value .id };
						};
/*var login_body =	function () {
						var login_secrets = get_cache ('login_secrets');
						return login_secrets && {
							access_token: login_secrets .access_token,
							device_id: login_secrets .device_id,
							device_type: login_secrets .device_type
						};
					};*/
var login_using =	function (secrets) {
						//set_cache ('login_secrets', secrets);
						return secrets;
					};


var frontend_path = 'https://indiniga-mumenrider.c9users.io/app';
var backend_path = 'https://indiniga-mumenrider.c9users.io/api';
				
				
var util = {};
var content = {};


util .register =	pipe_write ('register', backend_path + '/register', {
						write:	{
									method: 'GET',
									headers: '{ { "x-username": data .username, "x-password": data .password } }'
								}
					}, '{ response }');
util .login =	pipe_edit ('login', backend_path + '/login', {
					edit:	{
								method: 'GET',
								headers: '{ { "x-username": data .username, "x-password": data .password } }'
							}
				}, '{ response }');
util .logout =	pipe_write ('logout', backend_path + '/login', {
					write:	{
								method: 'local',
								body: '{ undefined }'
							}
				}, '{ response }');
util .course_enroll =	function (course_id) {
							return	pipe_write ('enroll', backend_path + '/course/' + course_id + '/enroll', {
										write:	{
													method: 'GET',
													headers: '{ logged_in_header () }'
												}
									}, '{ response }')
						};
util .component_done =	function (course_id, module_order, component_order) {
							return	pipe_write ('done', backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/' + component_order + '/done', {
										write:	{
													method: 'GET',
													headers: '{ logged_in_header () }'
												}
									}, '{ response }');
						};
						
						
util .course_new =	pipe_write ('new', backend_path + '/my/course/new', {
						write:	{
									method: 'GET',
									headers: '{ with_ ("x-course-name", data .course_name) (logged_in_header ()) }'
								}
					}, '{ response }');
util .course_delete =	pipe_write ('delete', backend_path + '/my/course/delete', {
							write:	{
										method: 'GET',
										headers: '{ with_ ("x-course", data .course_id) (logged_in_header ()) }'
									}
						}, '{ response }');
util .course_publish =	pipe_write ('publish', backend_path + '/my/course/publish', {
							write:	{
										method: 'GET',
										headers: '{ with_ ("x-course", data .course_id) (logged_in_header ()) }'
									}
						}, '{ response }');
						
util .module_new =	function (course_id) {
						return	pipe_write ('new', backend_path + '/my/course/' + course_id + '/module/new', {
									write:	{
												method: 'GET',
												headers: '{ with_ ("x-module-name", data .module_name) (logged_in_header ()) }'
											}
								}, '{ response }');
					};	
util .module_reorder =	function (course_id) {
							return	pipe_write ('reorder', backend_path + '/my/course/' + course_id + '/module/reorder', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-module-1", data .module_1_order) (with_ ("x-module-2", data .module_2_order) (logged_in_header ())) }'
												}
									}, '{ response }');
						};
util .module_delete =	function (course_id) {
							return	pipe_write ('delete', backend_path + '/my/course/' + course_id + '/module/delete', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-module", data .module_order) (logged_in_header ()) }'
												}
									}, '{ response }');
						};
						
util .component_new =	function (course_id, module_order) {
							return	pipe_write ('new', backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/new', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-component-name", data .component_name) (with_ ("x-component-content", data .component_content) (logged_in_header ())) }'
												}
									}, '{ response }');
						};	
util .component_reorder =	function (course_id, module_order) {
								return	pipe_write ('reorder', backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/reorder', {
											write:	{
														method: 'GET',
														headers: '{ with_ ("x-component-1", data .component_1_order) (with_ ("x-component-2", data .component_2_order) (logged_in_header ())) }'
													}
										}, '{ response }');
							};
util .component_delete =	function (course_id, module_order) {
								return	pipe_write ('delete', backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/delete', {
											write:	{
														method: 'GET',
														headers: '{ with_ ("x-component", data .component_order) (logged_in_header ()) }'
													}
										}, '{ response }');
							};
util .component_edit =	function (course_id, module_order, component_order) {
							return	pipe_write ('edit', backend_path + '/my/course/' + course_id + '/module/' + module_order + '/component/' + component_order + '/edit', {
										write:	{
													method: 'GET',
													headers: '{ with_ ("x-component-name", data .component_name) (with_ ("x-component-content", data .component_content) (logged_in_header ())) }'
												}
									}, '{ response }');
						};	
						
util .user_edit =	function (user_id) {
						return	pipe_write ('edit', backend_path + '/user/' + user_id + '/edit', {
									write:	{
												method: 'GET',
												headers: '{ with_ ("x-" + data .edit_type, data .edit_content) (logged_in_header ()) }'
											}
								}, '{ response }');
					};	
						
						
						
						
						
						
content .courses =	pipe_read ('all-courses', backend_path + '/courses', {
						read:	{
									method: 'GET',
									headers: '{ logged_in_header () }'
								}
							
					}, '{ response }');
content .course =	function (course_id) {
						return	pipe_read ('course', backend_path + '/course/' + course_id, {
									read:	{
												method: 'GET',
												headers: '{ logged_in_header () }'
											}
										
								}, '{ response }');
					};
content .my_courses =	pipe_read ('my-courses', backend_path + '/my/courses', {
							read:	{
										method: 'GET',
										headers: '{ logged_in_header () }'
									}
								
						}, '{ response }');
						
content .users =	pipe_read ('all-users', backend_path + '/users', {
						read:	{
									method: 'GET',
									headers: '{ logged_in_header () }'
								}
							
					}, '{ response }');
content .user =	function (user_id) {
					return	pipe_read ('user', backend_path + '/user/' + user_id, {
								read:	{
											method: 'GET',
											headers: '{ logged_in_header () }'
										}
									
							}, '{ response }');
				};
						
						
						
						




var screens = {};

/*-me
    -login
    -user
    -matches
    -todos
    -teams
    
-match
-team*/</script>
		<script>riot.tag2('content-login', '<model-themer> <model-loginner></model-loginner> <button type="submit" name="login"> Login! </button> <button type="submit" name="register"> Register! </button> </model-themer>', '', '', function(opts) {
(function (self) {
	    remembers ({
	        username: undefined,
	        password: undefined
	    }) (self);

	    self .on ('mount', function () {
	        var login = self .root .querySelector ('button[name="login"]');
	        var register = self .root .querySelector ('button[name="register"]');

	        login .addEventListener ('click', function () {
	            self .stuff .trigger ('login', {
	                username: self .recalls ('username'),
	                password: self .recalls ('password')
	            });
	            self .stuff .one ('login', function (response) {
	                if (! response .error) {
	                    window .location .hash = '#service'
	                }
	            });
	        });
	        register .addEventListener ('click', function () {
	            self .stuff .trigger ('register', {
	                username: self .recalls ('username'),
	                password: self .recalls ('password')
	            });
	            self .stuff .one ('register', function (response) {
	                if (! response .error) {
	                    alert ('Successfully registered!');
	                }
	            });
	        });
	    });

	})(this);
});
riot.tag2('content-service-administrator', '<model-themer> <h1>MASTER SUPER SECRET ADMINISTRATOR BOARD</h1> <table> <tr><th>All Users</th><th></th><th></th></tr> <tr each="{id, user in piece ((recalls (\'all-users\') || {}) .users || {})}" riot-script="{(new Function (‚Åóself‚Åó,‚Åóuser‚Åó,‚Åó\\n\\t\\t\\t\\tvar buttons_work =\\tfunction () {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tutil .user_edit (user .id) (self);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar make_administrator = self .root .querySelector (\'button[to=\\‚Åómake_administrator\\‚Åó]\');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmake_administrator && make_administrator .addEventListener (\'click\', function () {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tself .stuff .trigger (\'edit\', {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_type: \'administrator-add\',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_content: \'add\'\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}, false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar revoke_administrator = self .root .querySelector (\'button[to=\\‚Åórevoke_administrator\\‚Åó]\');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\trevoke_administrator && revoke_administrator .addEventListener (\'click\', function () {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tself .stuff .trigger (\'edit\', {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_type: \'administrator-remove\',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_content: \'remove\'\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}, false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar make_instructor = self .root .querySelector (\'button[to=\\‚Åómake_instructor\\‚Åó]\');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmake_instructor && make_instructor .addEventListener (\'click\', function () {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tself .stuff .trigger (\'edit\', {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_type: \'instructor-add\',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_content: \'add\'\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}, false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar unmake_instructor = self .root .querySelector (\'button[to=\\‚Åóunmake_instructor\\‚Åó]\');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tunmake_instructor && unmake_instructor .addEventListener (\'click\', function () {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tself .stuff .trigger (\'edit\', {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_type: \'instructor-remove\',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_content: \'remove\'\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}, false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar restrict_enrolling = self .root .querySelector (\'button[to=\\‚Åórestrict_enrolling\\‚Åó]\');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\trestrict_enrolling && restrict_enrolling .addEventListener (\'click\', function () {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tself .stuff .trigger (\'edit\', {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_type: \'restrict-add\',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_content: \'add\'\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}, false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvar unrestrict_enrolling = self .root .querySelector (\'button[to=\\‚Åóunrestrict_enrolling\\‚Åó]\');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tunrestrict_enrolling && unrestrict_enrolling .addEventListener (\'click\', function () {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tself .stuff .trigger (\'edit\', {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_type: \'restrict-remove\',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedit_content: \'remove\'\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}, false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\tself .on (\'mount\', buttons_work);\\n\\t\\t\\t\\tself .on (\'updated\', buttons_work);\\n\\t\\t\\t‚Åó))(this, user)}"><td if="{user .instructor & user .administrator}"><mark><strong>{user .username}</strong></mark></td ><td if="{! user .instructor & user .administrator}"><mark>{user .username}</mark></td ><td if="{user .instructor & ! user .administrator}"><strong>{user .username}</strong></td ><td if="{! user .administrator && ! user .instructor}">{user .username}</td ><td if="{! user .administrator}"><button type="submit" to="make_administrator">Make Admin</button></td ><td if="{user .administrator}"><button to="revoke_administrator">Revoke Admin</button></td ><td if="{! user .instructor}"><button type="submit" to="make_instructor">Make Instructor</button></td ><td if="{user .instructor}"><button to="unmake_instructor">Unmake Instructor</button></td ><td if="{! user .enroll_restricted}"><button to="restrict_enrolling">Restrict Enrolling</button></td ><td if="{user .enroll_restricted}"><button type="submit" to="unrestrict_enrolling">Unrestrict Enrolling</button></td ></tr> </table> </model-themer>', '', '', function(opts) {
	(function (self) {
		self .stuff .on ('all-users', function () {
			self .update ();
		});
	})(this);
});
riot.tag2('content-service-instructor-component-add', '<model-themer> <fieldset> <label>Component name:<input name="component_name" type="text" placeholder="Wow. Such sp."></label> <label>Component content:<textarea name="component_content" cols="40" rows="3" placeholder="So component"></textarea></label> </fieldset> <button type="submit" name="add_component"> Add component! </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var component_name = self .root .querySelector ('input[name="component_name"]');
	        var component_content = self .root .querySelector ('textarea[name="component_content"]');
	        var add_component = self .root .querySelector ('button[name="add_component"]');

	        add_component .addEventListener ('click', function () {
	            self .stuff .one ('new', function (response) {
	                if (! response .error) {

	                    window .location .hash = '#service/instructor/module/#' + self .recalls ('course_id') + '/' + self .recalls ('module_order')
	                }
	            })
	            self .stuff .trigger ('new', {
	                component_name: component_name .value,
	                component_content: component_content .value
	            });
	        });
	    });
	})(this);
});
riot.tag2('content-service-instructor-component', '<model-themer> <h2>{((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .name}</h2> <p>{((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .content}</p> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .stuff .on ('course', function () {
	        self .update ();
	    });
	    self .stuff .on ('course_id', function () {
	        self .update ();
	    });
	    self .stuff .on ('module_order', function () {
	        self .update ();
	    });
	    self .stuff .on ('component_order', function () {
	        self .update ();
	    });
	})(this);
});
riot.tag2('content-service-instructor-course-add', '<model-themer> <fieldset> <label>Course name:<input name="course_name" type="text" placeholder="Wow. Such course."></label> </fieldset> <button type="submit" name="add_course"> Add course! </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var course_name = self .root .querySelector ('input[name="course_name"]');
	        var add_course = self .root .querySelector ('button[name="add_course"]');

	        add_course .addEventListener ('click', function () {
	            self .stuff .one ('new', function (response) {
	                if (! response .error) {
	                    window .location .hash = '#service/instructor/'
	                }
	            })
	            self .stuff .trigger ('new', {
	                course_name: course_name .value
	            });
	        });
	    });
	})(this);
});
riot.tag2('content-service-instructor-course', '<model-themer> <h2>{((recalls (\'course\') || {}) .course || {}) .name}<h3 if="{((recalls (\'course\') || {}) .course || {}) .published}">(published)</h3></h2> <table> <tr><th>Modules</th></tr> <tr each="{assemble (((recalls (\'course\') || {}) .course || {}) .module_set)}"><td><a href="#service/instructor/module/#{recalls (\'course_id\')}/{order}">{name}</a></td ><td><button to="delete" order="{order}">x</button></td ><td><button to="shift" order="{order}">shift</button></td ></tr> </table> <button type="submit" name="add_module"> Add module </button> <button type="submit" name="publish_course" if="{! ((recalls (\'course\') || {}) .course || {}) .published}"> Publish course! </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var add_module = self .root .querySelector ('button[name="add_module"]');

	        add_module .addEventListener ('click', function () {
	            window .location .hash = '#service/instructor/module/add/#' + self .recalls ('course_id')
	        });
	    });
	    self .on ('updated', function () {
	        [] .forEach .call (self .root .querySelectorAll ('button[to="delete"]'), function (delete_module) {
	            delete_module .addEventListener ('click', function () {
	                var order = delete_module .getAttribute ('order');
	                self .stuff .trigger ('delete', {
	                    module_order: +order
	                });
	            }, false);
	        });
	        [] .forEach .call (self .root .querySelectorAll ('button[to="shift"]'), function (shift_module) {
	            shift_module .addEventListener ('click', function () {
	                var order = shift_module .getAttribute ('order');
	                self .stuff .trigger ('reorder', {
	                    module_1_order: +order,
	                    module_2_order: (+order + 1) % assemble (((self .recalls ('course') || {}) .course || {}) .module_set) .length
	                });
	            }, false);
	        });

	        var publish_course = self .root .querySelector ('button[name="publish_course"]');

	        publish_course && publish_course .addEventListener ('click', function () {
	            self .stuff .trigger ('publish', {
	                course_id: self .recalls ('course_id')
	            });
	        }, false);
	    });

	    self .stuff .on ('course', function () {
	        self .update ();
	    });
	    self .stuff .on ('course_id', function () {
	        self .update ();
	    });

	})(this);
});
riot.tag2('content-service-instructor-module-add', '<model-themer> <fieldset> <label>Module name:<input name="module_name" type="text" placeholder="Wow. Such module."></label> </fieldset> <button type="submit" name="add_module"> Add module! </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var module_name = self .root .querySelector ('input[name="module_name"]');
	        var add_module = self .root .querySelector ('button[name="add_module"]');

	        add_module .addEventListener ('click', function () {
	            self .stuff .one ('new', function (response) {
	                if (! response .error) {

	                    window .location .hash = '#service/instructor/course/#' + self .recalls ('course_id')
	                }
	            })
	            self .stuff .trigger ('new', {
	                module_name: module_name .value
	            });
	        });
	    });
	})(this);
});
riot.tag2('content-service-instructor-module', '<model-themer> <h2>{((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .name}</h2> <table> <tr><th>Components</th><th></th></tr> <tr each="{assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set)}"><td><a href="#service/instructor/component/#{recalls (\'course_id\')}/{recalls (\'module_order\')}/{order}">{name}</a></td ><td><button to="delete" order="{order}">x</button></td ><td><button to="shift" order="{order}">shift</button></td ></tr> </table> <button type="submit" name="add_component"> Add component </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var add_component = self .root .querySelector ('button[name="add_component"]');

	        add_component .addEventListener ('click', function () {
	            window .location .hash = '#service/instructor/component/add/#' + self .recalls ('course_id') + '/' + self .recalls ('module_order')
	        });
	    });
	    self .on ('updated', function () {
	        [] .forEach .call (self .root .querySelectorAll ('button[to="delete"]'), function (delete_component) {
	            delete_component .addEventListener ('click', function () {
	                var order = delete_component .getAttribute ('order');
	                self .stuff .trigger ('delete', {
	                    component_order: +order
	                });
	            }, false);
	        });
	        [] .forEach .call (self .root .querySelectorAll ('button[to="shift"]'), function (shift_component) {
	            shift_component .addEventListener ('click', function () {
	                var order = shift_component .getAttribute ('order');
	                self .stuff .trigger ('reorder', {
	                    component_1_order: +order,
	                    component_2_order: (+order + 1) % assemble (((assemble (((self .recalls ('course') || {}) .course || {}) .module_set) || {}) [self .recalls ('module_order')] || {}) .component_set) .length
	                });
	            }, false);
	        });
	    });

	    self .stuff .on ('course', function () {
	        self .update ();
	    });
	    self .stuff .on ('course_id', function () {
	        self .update ();
	    });
	    self .stuff .on ('module_order', function () {
	        self .update ();
	    });

	})(this);
});
riot.tag2('content-service-instructor', '<model-themer> <table> <tr><th>Courses created by me</th></tr> <tr each="{(recalls (\'my-courses\') || {}) .as_instructor}"><td><a href="#service/instructor/course/#{id}">{name}</a></td ><td><button to="delete" id="{id}">x</button></td ></tr> </table> <button type="submit" name="add_course"> Add course </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var add_course = self .root .querySelector ('button[name="add_course"]');

	        add_course .addEventListener ('click', function () {
	            window .location .hash = '#service/instructor/course/add'
	        });

	        [] .forEach .call (self .root .querySelectorAll ('button[to="delete"]'), function (delete_course) {
	            delete_course .addEventListener ('click', function () {
	                var id = delete_course .getAttribute ('id');
	                self .stuff .trigger ('delete', {
	                    course_id: id
	                });
	            }, false);
	        });
	    });
	    self .on ('updated', function () {
	        [] .forEach .call (self .root .querySelectorAll ('button[to="delete"]'), function (delete_course) {
	            delete_course .addEventListener ('click', function () {
	                var id = delete_course .getAttribute ('id');
	                self .stuff .trigger ('delete', {
	                    course_id: id
	                });
	            }, false);
	        });
	    });

	    self .stuff .on ('my-courses', function () {
	        self .update ();
	    });

	})(this);
});
riot.tag2('content-service-participant-course', '<model-themer> <h2 if="{(piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\']}"><mark>{((recalls (\'course\') || {}) .course || {}) .name}</mark></h2> <h2 if="{! (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\'] && (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .completed_courses) || {}) [recalls (\'course_id\') || \'\']}"><strike>{((recalls (\'course\') || {}) .course || {}) .name}</strike></h2> <h2 if="{! (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\'] && ! (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .completed_courses) || {}) [recalls (\'course_id\') || \'\']}">{((recalls (\'course\') || {}) .course || {}) .name}</h2> <button disabled if="{(piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\']}"> You are already enrolled in this course </button> <button disabled if="{(get_cache (backend_path + \'/login\') || {}) .enroll_restricted && Object .keys (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) .length}"> You are restricted to take one course at a time </button> <button type="submit" name="enroll_course" if="{! logged_with(\'enrolled?\')(logged_with(\'enrolled courses\')(piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [recalls (\'course_id\') || \'\']) && logged_with(\'unrestricted\')( ! (get_cache (backend_path + \'/login\') || {}) .enroll_restricted || ! Object .keys (piece (((get_cache (backend_path + \'/my/courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) .length )}"> Enroll! </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var enroll_course = self .root .querySelector ('button[name="enroll_course"]');

	        enroll_course && enroll_course .addEventListener ('click', function () {
	            self .stuff .one ('enroll', function () {
	                window .location .hash = '#service/participant'
	            });
	            self .stuff .trigger ('enroll');
	        }, false);
	    });
	    self .on ('updated', function () {
	        var enroll_course = self .root .querySelector ('button[name="enroll_course"]');

	        enroll_course && enroll_course .addEventListener ('click', function () {
	            self .stuff .one ('enroll', function () {
	                window .location .hash = '#service/participant'
	            });
	            self .stuff .trigger ('enroll');
	        }, false);
	    });

	    self .stuff .on ('course', function () {
	        self .update ();
	    });
	    self .stuff .on ('course_id', function () {
	        self .update ();
	    });

	})(this);
});
riot.tag2('content-service-participant-my-component', '<model-themer> <h2 if="{((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .done}"><strike>{((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .name}</strike></h2> <h2 if="{! ((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .done}">{((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .name}</h2> <p>{((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .content}</p> <button disabled if="{((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .done}"> Already done! </button> <button type="submit" name="done_component" if="{! ((assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set) || {}) [recalls (\'component_order\')] || {}) .done}"> I am done! </button> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var done_component = self .root .querySelector ('button[name="done_component"]');

	        done_component && done_component .addEventListener ('click', function () {
	            self .stuff .trigger ('done');
	        }, false);
	    });
	    self .on ('updated', function () {
	        var done_component = self .root .querySelector ('button[name="done_component"]');

	        done_component && done_component .addEventListener ('click', function () {
	            self .stuff .trigger ('done');
	        }, false);
	    });

	    self .stuff .on ('course', function () {
	        self .update ();
	    });
	    self .stuff .on ('course_id', function () {
	        self .update ();
	    });
	    self .stuff .on ('module_order', function () {
	        self .update ();
	    });
	    self .stuff .on ('component_order', function () {
	        self .update ();
	    });
	})(this);
});
riot.tag2('content-service-participant-my-course', '<model-themer> <h2>{((recalls (\'course\') || {}) .course || {}) .name}</h2> <table> <tr><th>Modules</th></tr> <tr each="{assemble (((recalls (\'course\') || {}) .course || {}) .module_set)}"><td><a href="#service/participant/my/module/#{recalls (\'course_id\')}/{order}" if="{done}"><strike>{name}</strike></a ><a href="#service/participant/my/module/#{recalls (\'course_id\')}/{order}" if="{! done}">{name}</a ></td ></tr> </table> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .stuff .on ('course', function () {
	        self .update ();
	    });
	    self .stuff .on ('course_id', function () {
	        self .update ();
	    });

	})(this);
});
riot.tag2('content-service-participant-my-module', '<model-themer> <h2 if="{((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .done}"><strike>{((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .name}</strike></h2> <h2 if="{! ((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .done}">{((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .name}</h2> <table> <tr><th>Components</th><th></th></tr> <tr each="{assemble (((assemble (((recalls (\'course\') || {}) .course || {}) .module_set) || {}) [recalls (\'module_order\')] || {}) .component_set)}"><td><a href="#service/participant/my/component/#{recalls (\'course_id\')}/{recalls (\'module_order\')}/{order}" if="{done}"><strike>{name}</strike></a ><a href="#service/participant/my/component/#{recalls (\'course_id\')}/{recalls (\'module_order\')}/{order}" if="{! done}">{name}</a ></td ></tr> </table> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .stuff .on ('course', function () {
	        self .update ();
	    });
	    self .stuff .on ('course_id', function () {
	        self .update ();
	    });
	    self .stuff .on ('module_order', function () {
	        self .update ();
	    });

	})(this);
});
riot.tag2('content-service-participant', '<model-themer> <table> <tr><th>Courses i am enrolled in</th></tr> <tr each="{((recalls (\'my-courses\') || {}) .as_participant || {}) .enrolled_courses}"><td><a href="#service/participant/my/course/#{id}"><mark>{name}</mark></a></td></tr> </table> <table> <tr><th>Courses completed</th></tr> <tr each="{((recalls (\'my-courses\') || {}) .as_participant || {}) .completed_courses}"><td><a href="#service/participant/my/course/#{id}"><strike>{name}</strike></a></td></tr> </table> <table> <tr><th>Courses catalogue</th></tr> <tr each="{(recalls (\'all-courses\') || {}) .courses}"><td><a href="#service/participant/course/#{id}" if="{(piece (((recalls (\'my-courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [id]}"><mark>{name}</mark></a ><a href="#service/participant/course/#{id}" if="{! (piece (((recalls (\'my-courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [id] && (piece (((recalls (\'my-courses\') || {}) .as_participant || {}) .completed_courses) || {}) [id]}"><strike>{name}</strike></a ><a href="#service/participant/course/#{id}" if="{! (piece (((recalls (\'my-courses\') || {}) .as_participant || {}) .enrolled_courses) || {}) [id] && ! (piece (((recalls (\'my-courses\') || {}) .as_participant || {}) .completed_courses) || {}) [id]}">{name}</a ></td></tr> </table> </model-themer>', '', '', function(opts) {
	(function (self) {
	    self .stuff .on ('all-courses', function () {
	        self .update ();
	    });
	    self .stuff .on ('my-courses', function () {
	        self .update ();
	    });
	})(this);
});
riot.tag2('content-service', '<model-themer> <button type="submit" name="as_participant"> Participant services </button> <button type="submit" name="as_instructor" if="{(get_cache (backend_path + \'/login\') || {}) .as_instructor}"> Instructor services </button> <button type="submit" name="as_administrator" if="{(get_cache (backend_path + \'/login\') || {}) .as_administrator}"> Administrator services </button> </model-themer>', '', '', function(opts) {
(function (self) {
	    if (! (get_cache (backend_path + '/login') || {}) .id)
	        window .location .hash = '#login';

	    self .on ('mount', function () {
	        var as_participant = self .root .querySelector ('button[name="as_participant"]');
	        var as_instructor = self .root .querySelector ('button[name="as_instructor"]');
	        var as_administrator = self .root .querySelector ('button[name="as_administrator"]');

	        as_participant .addEventListener ('click', function () {
	            window .location .hash = '#service/participant';
	        });
	        as_instructor && as_instructor .addEventListener ('click', function () {
	            window .location .hash = '#service/instructor';
	        });
	        as_administrator && as_administrator .addEventListener ('click', function () {
	            window .location .hash = '#service/administrator';
	        });
	    });

	})(this);
});
riot.tag2('model-loginner', '<fieldset> <label>Username:<input name="username" type="text" placeholder="admin"></label> <label>Password:<input name="password" type="password"></label> </fieldset>', '', '', function(opts) {
	(function (self) {
	    self .on ('mount', function () {
	        var username = self .root .querySelector ('input[name="username"]');
	        var password = self .root .querySelector ('input[name="password"]');

	        username .addEventListener ('input', function () {
	            self .stuff .trigger ('username', username .value);
	        });
	        password .addEventListener ('input', function () {
	            self .stuff .trigger ('password', password .value);
	        });
	    });
	})(this);
});
riot.tag2('model-themer', '<section> <article><yield></yield></article> <footer><button name="logout">Logout</button><button name="service">Services</button></footer> </section>', '', '', function(opts) {
	(function (self) {
	    util .logout (self);

	    self .on ('mount', function () {
	        var logout = self .root .querySelector ('button[name="logout"]');
	        var service = self .root .querySelector ('button[name="service"]');
	        logout .addEventListener ('click', function () {
	            self .stuff .one ('logout', function () {
	                window .location .hash = '#login';
	            });
	            self .stuff .trigger ('logout');
	        });
	        service .addEventListener ('click', function () {
	            window .location .hash = '#service';
	        });
	    });
	})(this);
});
riot.tag2('screen-page-login', '<content-login></content-login>', '', '', function(opts) {
	(function (self) {
		if (get_cache (backend_path + '/login')) {
			window .location .hash = '#service'
		}

		util .register (self);
		util .login (self);

		display_errors ('register', self);
		display_errors ('login', self);

	})(this);
});
riot.tag2('screen-page-service-administrator', '<content-service-administrator></content-service-administrator>', '', '', function(opts) {
	(function (self) {
	    var leak = undefined;

	    content .users (self);
	    leak = setInterval (self .recalls .bind (self, 'all-users'), 300);

	    display_errors ('all-users', self);

	    self .on ('unmount', function () {
	        leak && clearInterval (leak);
	    });
	})(this);
});
riot.tag2('screen-page-service-instructor-component-add', '<content-service-instructor-component-add></content-service-instructor-component-add>', '', '', function(opts) {
	(function (self) {
	    self .understands ('input');
	    self .stuff .on ('input', function (course_id, module_order) {
	        remembers ({
	            course_id: course_id,
	            module_order: module_order
	        }) (self);

	        util .component_new (course_id, module_order) (self);

		    display_errors ('new', self);
	    });
	})(this);
});
riot.tag2('screen-page-service-instructor-component', '<content-service-instructor-component></content-service-instructor-component>', '', '', function(opts) {
	(function (self) {
	    self .understands ('input');
	    self .stuff .on ('input', function (course_id, module_order, component_order) {
	        content .course (course_id) (self);
	        self .recalls ('course');

		    display_errors ('course', self);

	        remembers ({
	            course_id: course_id,
	            module_order: module_order,
	            component_order: component_order
	        }) (self);
	    });
	})(this);
});
riot.tag2('screen-page-service-instructor-course-add', '<content-service-instructor-course-add></content-service-instructor-course-add>', '', '', function(opts) {
	(function (self) {
	    util .course_new (self);

	    display_errors ('new', self);
	})(this);
});
riot.tag2('screen-page-service-instructor-course', '<content-service-instructor-course></content-service-instructor-course>', '', '', function(opts) {
	(function (self) {
	    var leak = undefined;

	    self .understands ('input');
	    self .stuff .on ('input', function (course_id) {
	        content .course (course_id) (self);
	        leak = setInterval (self .recalls .bind (self, 'course'), 300);
	        util .module_delete (course_id) (self);
	        util .module_reorder (course_id) (self);
	        util .course_publish (self);

		    display_errors ('course', self);
		    display_errors ('delete', self);
		    display_errors ('reorder', self);

	        remembers ({
	            course_id: course_id
	        }) (self);
	    });

	    self .on ('unmount', function () {
	        leak && clearInterval (leak);
	    });
	})(this);
});
riot.tag2('screen-page-service-instructor-module-add', '<content-service-instructor-module-add></content-service-instructor-module-add>', '', '', function(opts) {
	(function (self) {
	    self .understands ('input');
	    self .stuff .on ('input', function (course_id) {
	        remembers ({
	            course_id: course_id
	        }) (self);

	        util .module_new (course_id) (self);

		    display_errors ('new', self);
	    });
	})(this);
});
riot.tag2('screen-page-service-instructor-module', '<content-service-instructor-module></content-service-instructor-module>', '', '', function(opts) {
	(function (self) {
	    var leak = undefined;

	    self .understands ('input');
	    self .stuff .on ('input', function (course_id, module_order) {
	        content .course (course_id) (self);
	        leak = setInterval (self .recalls .bind (self, 'course'), 300);
	        util .component_delete (course_id, module_order) (self);
	        util .component_reorder (course_id, module_order) (self);

		    display_errors ('course', self);
		    display_errors ('delete', self);
		    display_errors ('reorder', self);

	        remembers ({
	            course_id: course_id,
	            module_order: module_order
	        }) (self);
	    });

	    self .on ('unmount', function () {
	        leak && clearInterval (leak);
	    });
	})(this);
});
riot.tag2('screen-page-service-instructor', '<content-service-instructor></content-service-instructor>', '', '', function(opts) {
	(function (self) {
	    var leak = undefined;

	    content .my_courses (self);
	    leak = setInterval (self .recalls .bind (self, 'my-courses'), 300);
	    util .course_delete (self);

		display_errors ('my-courses', self);
	    display_errors ('delete', self);

	    self .on ('unmount', function () {
	        leak && clearInterval (leak);
	    });
	})(this);
});
riot.tag2('screen-page-service-participant-course', '<content-service-participant-course></content-service-participant-course>', '', '', function(opts) {
	(function (self) {
	    self .understands ('input');
	    self .stuff .on ('input', function (course_id) {
	        content .course (course_id) (self);
	        util .course_enroll (course_id) (self);

		    display_errors ('course', self);

	        remembers ({
	            course_id: course_id
	        }) (self);
	    });
	})(this);
});
riot.tag2('screen-page-service-participant-my-component', '<content-service-participant-my-component></content-service-participant-my-component>', '', '', function(opts) {
	(function (self) {
	    var leak = undefined;

	    self .understands ('input');
	    self .stuff .on ('input', function (course_id, module_order, component_order) {
	        content .course (course_id) (self);
	        leak = setInterval (self .recalls .bind (self, 'course'), 300);
	        util .component_done (course_id, module_order, component_order) (self);

		    display_errors ('course', self);
		    display_errors ('done', self);

	        remembers ({
	            course_id: course_id,
	            module_order: module_order,
	            component_order: component_order
	        }) (self);
	    });

	    self .on ('unmount', function () {
	        leak && clearInterval (leak);
	    });
	})(this);
});
riot.tag2('screen-page-service-participant-my-course', '<content-service-participant-my-course></content-service-participant-my-course>', '', '', function(opts) {
	(function (self) {
	    var leak = undefined;

	    self .understands ('input');
	    self .stuff .on ('input', function (course_id) {
	        content .course (course_id) (self);
	        leak = setInterval (self .recalls .bind (self, 'course'), 300);

		    display_errors ('course', self);

	        remembers ({
	            course_id: course_id
	        }) (self);
	    });

	    self .on ('unmount', function () {
	        leak && clearInterval (leak);
	    });
	})(this);
});
riot.tag2('screen-page-service-participant-my-module', '<content-service-participant-my-module></content-service-participant-my-module>', '', '', function(opts) {
	(function (self) {
	    var leak = undefined;

	    self .understands ('input');
	    self .stuff .on ('input', function (course_id, module_order) {
	        content .course (course_id) (self);
	        leak = setInterval (self .recalls .bind (self, 'course'), 300);

		    display_errors ('course', self);

	        remembers ({
	            course_id: course_id,
	            module_order: module_order
	        }) (self);
	    });

	    self .on ('unmount', function () {
	        leak && clearInterval (leak);
	    });
	})(this);
});
riot.tag2('screen-page-service-participant', '<content-service-participant></content-service-participant>', '', '', function(opts) {
	(function (self) {
	    var leak1 = undefined;
	    var leak2 = undefined;

	    content .courses (self);
	    content .my_courses (self);
	    leak1 = setInterval (self .recalls .bind (self, 'all-courses'), 300);
	    leak2 = setInterval (self .recalls .bind (self, 'my-courses'), 300);

		display_errors ('all-courses', self);
		display_errors ('my-courses', self);

	    self .on ('unmount', function () {
	        leak1 && clearInterval (leak1);
	        leak2 && clearInterval (leak2);
	    });
	})(this);
});
riot.tag2('screen-page-service', '<content-service></content-service>', '', '', function(opts) {
});
riot.tag2('the-app', '', 'input,textarea,select,button,html,body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}input,textarea,select,button,html,body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}th{font-weight:600}td,th{border-bottom:1.08px solid #ccc;padding:14.85px 18px}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{display:block;max-width:100%;overflow-x:auto}input,textarea,select,button,html,body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}input,textarea,select,button{display:block;max-width:100%;padding:9.9px}label{display:block;margin-bottom:14.76px}input[type="submit"],input[type="reset"],button{background:#f2f2f2;border-radius:3.6px;color:#8c8c8c;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.525px 23.4px;text-align:center}input[type="submit"]:hover,input[type="reset"]:hover,button:hover{background:#d9d9d9;color:#000}input[type="submit"][disabled],input[type="reset"][disabled],button[disabled]{background:#e6e6e6;color:#b3b3b3;cursor:not-allowed}input[type="submit"],button[type="submit"]{background:#367ac3;color:#fff}input[type="submit"]:hover,button[type="submit"]:hover{background:#255587;color:#bfbfbf}input[type="text"],input[type="password"],input[type="email"],input[type="url"],input[type="phone"],input[type="tel"],input[type="number"],input[type="datetime"],input[type="date"],input[type="month"],input[type="week"],input[type="color"],input[type="time"],input[type="search"],input[type="range"],input[type="file"],input[type="datetime-local"],select,textarea{border:1px solid #ccc;margin-bottom:18px;padding:5.4px 6.3px}input[type="checkbox"],input[type="radio"]{float:left;line-height:36px;margin-right:9px;margin-top:8.1px}input,textarea,select,button,html,body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}pre,code,kbd,samp,var,output{font-family:Menlo,Monaco,Consolas,"Courier New",monospace;font-size:16.2px}pre{border-left:1.8px solid #96bbe2;line-height:25.2px;margin-top:29.7px;overflow:auto;padding-left:18px}pre code{background:none;border:0;line-height:29.7px;padding:0}code{background:#ededed;border:1.8px solid #ccc;border-radius:3.6px;display:inline-block;line-height:18px;padding:3px 6px 2px}input,textarea,select,button,html,body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}h1,h2,h3,h4,h5,h6{color:#000;margin-bottom:18px}h1{font-size:36px;font-weight:500;margin-top:36px}h2{font-size:25.2px;font-weight:400;margin-top:27px}h3{font-size:21.6px;margin-top:21.6px}h4{font-size:18px;margin-top:18px}h5{font-size:14.4px;font-weight:bold;margin-top:18px;text-transform:uppercase}h6{color:#ccc;font-size:14.4px;font-weight:bold;margin-top:18px;text-transform:uppercase}input,textarea,select,button,html,body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}a{color:#367ac3;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #ccc}small{font-size:15.3px}em,i{font-style:italic}strong,b{font-weight:600}*{border:0;border-collapse:separate;border-spacing:0;box-sizing:border-box;margin:0;outline:0;padding:0;text-align:left;vertical-align:baseline}html,body{height:100%;width:100%}body{background:#f5f5f5;color:#1a1a1a;padding:36px}p,ul,ol,dl,blockquote,hr,pre,table,form,fieldset,figure,address{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;max-width:100%;width:900px}article{background:#fff;border:1.8px solid #d9d9d9;border-radius:7.2px;padding:43.2px}header{margin-bottom:36px}footer{margin-top:36px}nav{text-align:center}nav ul{list-style:none;margin-left:0;text-align:center}nav ul li{display:inline;margin-left:9px;margin-right:9px}nav ul li:first-child{margin-left:0}nav ul li:last-child{margin-right:0}ol,ul{margin-left:29.7px}li ol,li ul{margin-bottom:0}@media (max-width: 767px){body{padding:18px}article{border-radius:0;margin:-18px;padding:18px}textarea,input,select{max-width:100%}fieldset{min-width:0}section{width:auto}fieldset,x:-moz-any-link{display:table-cell}} html { width: 100vw !important; height: 100vh !important; } body { width: 100% !important; height: 100% !important; position: relative; overflow: hidden; } .border { border: 2px solid black; } .cursor-pointer { cursor: pointer; } .scroll { overflow-x: hidden; overflow-y: scroll !important; } .scroll::-webkit-scrollbar { display: none; } .position-fixed { position: fixed !important; } .position-absolute { position: absolute !important; } .position-relative { position: relative !important; } .full-height { height: 100% !important; } .ninety-five-width { width: 95%; } .most-height { height: 80% !important; } .slider-box-height { height: 100px !important; } .little-height { height: 10% !important; } .most-width { width: 80% !important; } .full-width { width: 100% !important; } .no-frills { padding: 0 !important; } .no-shock { margin: 0 !important; } .match-edge { position: absolute; height: auto; width: auto; display: block; top: 0; bottom: 0; left: 0; right: 0; } .top-down { overflow: hidden; } .text-center { text-align: center; } .text-middle { vertical-align: middle; } .half-height { height: 50%; } .quarter-height { height: 25%; } .block-left { display: block; position: absolute; left: 0%; transform: translatex(0%); -webkit-transform: translatex(0%); } .block-center { display: block; position: absolute; left: 50%; transform: translatex(-50%); -webkit-transform: translatex(-50%); } .block-right { display: block; position: absolute; left: 100%; transform: translatex(-100%); -webkit-transform: translatex(-100%); } .block-top { display: block; position: absolute; top: 0%; transform: translatey(0%); -webkit-transform: translatey(0%); } .block-middle { display: block; position: absolute; top: 50% !important; transform: translatey(-50%); -webkit-transform: translatey(-50%); } .block-bottom { display: block; position: absolute; top: 100%; transform: translatey(-100%); -webkit-transform: translatey(-100%); } .block-left.block-top { top: 0%; left: 0%; transform: translatex(-0%) translatey(-0%); -webkit-transform: translatex(-0%) translatey(-0%); } .block-left.block-middle { top: 50%; left: 0%; transform: translatex(-0%) translatey(-50%); -webkit-transform: translatex(-0%) translatey(-50%); } .block-left.block-bottom { top: 100%; left: 0%; transform: translatex(-0%) translatey(-100%); -webkit-transform: translatex(-0%) translatey(-100%); } .block-center.block-top { top: 0%; left: 50%; transform: translatex(-50%) translatey(0%); -webkit-transform: translatex(-50%) translatey(0%); } .block-center.block-middle { top: 50%; left: 50%; transform: translatex(-50%) translatey(-50%); -webkit-transform: translatex(-50%) translatey(-50%); } .block-center.block-bottom { top: 100%; left: 50%; transform: translatex(-50%) translatey(-100%); -webkit-transform: translatex(-50%) translatey(-100%); } .block-right.block-top { top: 0%; left: 100%; transform: translatex(-100%) translatey(0%); -webkit-transform: translatex(-100%) translatey(0%); } .block-right.block-middle { top: 50%; left: 100%; transform: translatex(-100%) translatey(-50%); -webkit-transform: translatex(-100%) translatey(-50%); } .block-right.block-bottom { top: 100%; left: 100%; transform: translatex(-100%) translatey(-100%); -webkit-transform: translatex(-100%) translatey(-100%); } .nudge-up { padding-bottom: 20px; } .nudge-down { padding-top: 20px; } .nudge-left { padding-right: 20px; } .nudge-right { padding-left: 20px; } .nudge-up-more { padding-bottom: 40px; } .nudge-down-more { padding-top: 40px; } .nudge-left-more { padding-right: 40px; } .nudge-right-more { padding-left: 40px; } .under-half { top: 50%; } .under-bar-44 { top: 44px; } .under-bar-47 { top: 47px; } .above-bar-44 { bottom: 44px; } .above-bar-49 { bottom: 49px; } .under-bar-88 { top: 88px; } .match-me { position: relative !important; height: 100% !important; width: 100% !important; overflow: hidden; } .font-large,.font-large:before,.font-large:after { font-size: 2em !important; } .font-big,.font-big:before,.font-big:after { font-size: 1.5em !important; } .font-somewhat-big,.font-somewhat-big:before,.font-somewhat-big:after { font-size: 1.45em !important; } .font-more,.font-more:before,.font-more:after { font-size: 1.4em !important; } .font-regular,.font-regular:before,.font-regular:after { font-size: 1.2em !important; } .font-small,.font-small:before,.font-small:after { font-size: 0.8em !important; } .font-tiny,.font-tiny:before,font-tiny:after { font-size: 0.2em; line-height: 0.2em; } .neutral-color { color: white; } .sixty-height { height: 60px; } .eighty-height { height: 80px; } .hundred-fifty-height { height: 150px; } .hundred-height { height: 100px; } .prized-asset { min-height: 260px; max-height: 100%; } .free-icon { min-width: none !important; min-height: none !important; max-width: none !important; max-height: none !important; } .free-icon:before,.free-icon:after { width: auto !important; height: auto !important; } .inline { display: inline; } .inline-center { text-align: center; } .inline-left { text-align: left; } .inline-right { text-align: right; } .inline-justify { text-align: justify; } .header-text { white-space: nowrap; } .invisible { visibility: none; } .top-layer { z-index: 999; } .bottom-layer { z-index: -999; } .lax { overflow: visible !important; } .higher { z-index: 1000; } .push-up { margin-top: -10px; } .area-0to100x0to30 { position: absolute; width: 100%; height: 30%; top: 0; left: 0; } .area-0to100x30to60 { position: absolute; width: 100%; height: 30%; top: 30%; left: 0; } .area-0to100x60to100 { position: absolute; width: 100%; height: 40%; top: 60%; left: 0; } .area-0to30x0to100 { position: absolute; width: 30%; height: 100%; top: 0; left: 0; } .area-0to50x0to50 { position: absolute; width: 50%; height: 50%; top: 0; left: 0; } .area-50to85x0to50 { position: absolute; width: 35%; height: 50%; top: 0; left: 50%; } .area-0to60x50to100 { position: absolute; width: 60%; height: 50%; top: 50%; left: 0; } .area-0to20x0to100 { position: absolute; width: 20%; height: 100%; top: 0; left: 0; } .area-20to100x0to100 { position: absolute; width: 80%; height: 100%; top: 0; left: 20%; } .area-0to100x0to50 { position: absolute; width: 100%; height: 50%; top: 0; left: 0; } .area-0to100x50to100 { position: absolute; width: 100%; height: 50%; top: 50%; left: 0; } .area-0to35x0to100 { position: absolute; width: 35%; height: 100%; top: 0; left: 0; } .area-35to55x0to100 { position: absolute; width: 20%; height: 100%; top: 0; left: 35%; } .area-55to100x0to100 { position: absolute; width: 45%; height: 100%; top: 0; left: 55%; } .area-30to100x0to100 { position: absolute; width: 70%; height: 100%; top: 0; left: 30%; } .area-20to80x0to100 { position: absolute; width: 60%; height: 100%; top: 0; left: 20%; } .area-80to100x0to100 { position: absolute; width: 20%; height: 100%; top: 0; left: 80%; } .area-0to40x0to50 { position: absolute; width: 40%; height: 50%; top: 0; left: 0; } .area-40to60x0to50 { position: absolute; width: 20%; height: 50%; top: 0; left: 40%; } .area-60to100x0to50 { position: absolute; width: 40%; height: 50%; top: 0; left: 60%; } .area-0to100x50to100 { position: absolute; width: 100%; height: 50%; top: 50%; left: 0; } .area-0to50x0to100 { position: absolute; width: 50%; height: 100%; top: 0; left: 0; } .area-50to100x0to100 { position: absolute; width: 50%; height: 100%; top: 0; left: 50%; } .area-50to100x0to50 { position: absolute; width: 50%; height: 50%; top: 0; left: 50%; } .area-0to80x0to100 { position: absolute; width: 80%; height: 100%; top: 0; left: 0; } .area-0to25x0to100 { position: absolute; width: 25%; height: 100%; top: 0; left: 0; } .area-25to100x0to100 { position: absolute; width: 75%; height: 100%; top: 0; left: 25%; } .area-0to100x0to60 { position: absolute; width: 100%; height: 60%; top: 0; left: 0; } .area-0to100x60to100 { position: absolute; width: 100%; height: 40%; top: 60%; left: 0; } .area-0to12x50to100 { position: absolute; width: 12%; height: 50%; top: 50%; left: 0; } .area-12to100x50to100 { position: absolute; width: 88%; height: 50%; top: 50%; left: 12%; } .paragraph-text { white-space: normal !important; word-break: break-all !important; word-wrap: break-word !important; } .fitting-size { max-height: 100%; max-width: 100%; } .text-icons { font-family: Ionicons, icomoon !important; } .minify-slight { -ms-transform: scale(0.99, 0.99); -webkit-transform: scale(0.99, 0.99); transform: scale(0.99, 0.99); } .minify-some { -ms-transform: scale(0.9, 0.9); -webkit-transform: scale(0.9, 0.9); transform: scale(0.9, 0.9); } .inset-more { padding: 15px; } .inset-some { padding: 10px; } .inset-little { padding: 5px; } .inset-slight { padding: 2px; } .outset-quite { margin: 20px; } .outset-little { margin: 5px; } .outset-some { margin: 10px; } .seventy-five-height { height: 75px; } .no-border { border: none !important; } .bold { font-weight: bold; } .background-black { background: black; } .list { will-change: scroll-position; } .background-texture::after { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.1; z-index: -1; background: url(../imgs/3d_soccer15.gif); } .background-transparent { background: transparent; } .background-shadowed { background: rgba(0,0,0,0.1); } .background-double-shadowed { background: rgba(0,0,0,0.2); } .background-translucent { background: rgba(0,0,0,0.03); } .icon-size { width: 1em; height: 1em; text-align: center; } .black-to-gray { -webkit-filter: invert(50%); filter: invert(50%); } .a-block { display: block; } .a-inline-block { display: inline-block; } .square { padding-bottom: 100%; } .square > .match-edge { background-size: cover !important; } .page { margin: 0 !important; } .display-none { display: none; } .content { min-height: 100%; } .dashed { border: 1px #bbb dashed; border-radius: 5px; }', '', function(opts) {
	(function (self) {

		var screens_data = {};
		screens .add =	function (tag, args) {
							return add_screen_as .apply (self, [undefined] .concat ([] .slice .call (arguments)));
						};
		screens .add_as =	function (id) {
								return	function ( ) {
											return add_screen_as .apply (self, [id] .concat ([] .slice .call (arguments)));
										};
							};
							var add_screen_as =	function (id, tag_name ) {
												var time = new Date ();
													if (id && screens_data [id] && screens_data [id] .root .localName === tag_name)
														var tag = screens_data [id];
													else {
														screens .remove (id);

														var tag_root = document .createElement (tag_name);
														self .root .insertBefore (tag_root, null);
														var tag = riot .mount (tag_root, tag_name) [0];
													}
													var args = [] .slice .call (arguments, 2);
													tag .stuff .trigger .apply (null, ['input'] .concat (args));

													screens_data [id || tag ._riot_id] = tag;
												log ('update screen time ' + (new Date () - time) + 'ms', arguments);
													return tag;
												};
		screens .get =	function () {
							return screens_data;
						};
		screens .remove =	function (id) {
								if (id && screens_data [id]) {
									screens_data [id] .unmount ();
									delete screens_data [id];
								}
							};
	})(this);
});
</script>
		<script>
riot .util .tmpl .errorHandler = log_alert;

riot .mixin (
	{
		init:	function () {
					var self = this;
					
					var self_stuff;
					var parent_stuff = self .parent && self .parent .stuff;
					
					var stuff_i_understand = {};
					var stuff_i_remember = {};
					var things_i_remember = {};
					var stuff_emitter = riot .observable ();
					
					
					self .understands =	function (stuff) {
											stuff_i_understand [stuff] = true;
										};
					self .remembers =	function (stuff) {
											stuff_i_remember [stuff] = true;
										//log ('stuff_i_remember', stuff_i_remember, self);
											self .understands (stuff);
										};
					self .recalls =	function (something) {
										//log (stuff_i_remember [something], things_i_remember [something]);
										if (stuff_i_remember [something])
											return things_i_remember [something]
										else
											return self .parent && self .parent .recalls (something);
									};
										
					self .must_do =	function (something) {
										stuff_emitter .on ('must', function (args) {
											something .apply ({}, args);
										});
									};
					self .would_do =	function (something) {
											stuff_emitter .on ('would', function (args) {
												something .apply ({}, args);
											});
										};
					self .should_do =	function (something) {
											stuff_emitter .on ('should', function (args) {
												something .apply ({}, args);
											});
										};
										
					self .stuff =	with_redefined (
										'trigger',
										function (raw_stuff) {
											
											self_stuff = raw_stuff;
											
											return	trigger_for (
														{
															stuff_emitter: stuff_emitter,
															stuff_i_understand:	function (name_of_stuff) { return stuff_i_understand [name_of_stuff]; },
															self_stuff: self_stuff,
															parent_stuff: parent_stuff,
															self_root: self .root
														} );
										} ) (riot .observable ());
	
					self .would_do (function (name_of_thing, thing) {
						if (stuff_i_remember [name_of_thing])
							things_i_remember [name_of_thing] = thing;
					});

					//for event trickling
					if (parent_stuff)
						self .parent .would_do (
							trigger_for (
								{
									stuff_emitter: stuff_emitter,
									stuff_i_understand:	function (name_of_stuff) { return stuff_i_understand [name_of_stuff]; },
									self_stuff: self_stuff,
									parent_stuff: 'from parent',
									self_root: self .root
								}
							) );
					
					//for logging
					self .should_do (function (/*event_info*/) {
			            log (/*'event', */[self] . concat ([] .slice .call (arguments)) );
			        });
			        
			        //capturing bubbling self events
			        self .on ('mount', function () {
			        	self .root .addEventListener ('self', function (event) {
			        		self .stuff .trigger .apply (self .stuff, event .detail);
			        		event .stopPropagation ();
			        		return false;
			        	}, false);
			        });
				}
	} );
		var trigger_for =	function (stuff_info) {
								var stuff_emitter = stuff_info .stuff_emitter;
								var stuff_i_understand = stuff_info .stuff_i_understand;
								var self_stuff = stuff_info .self_stuff;
								var parent_stuff = stuff_info .parent_stuff;
								var self_root = stuff_info .self_root;
								
								var parent_node = self_root .parentNode;
								
								if (parent_stuff === 'from parent')
									return	function (name_of_thing, info_about_thing) {
												if (! stuff_i_understand (name_of_thing) /*i understand*/) {
													stuff_emitter .trigger ('would', arguments);
													
													stuff_emitter .trigger ('must', arguments);
													
													self_stuff .trigger .apply (
														self_stuff, arguments);
												}
											};
								else
									return	function (name_of_thing, info_about_thing) {
												if (stuff_i_understand (name_of_thing)) {
													stuff_emitter .trigger ('should', arguments);
													
													stuff_emitter .trigger ('would', arguments);
													
													stuff_emitter .trigger ('must', arguments);
													
													self_stuff .trigger .apply (
														self_stuff, arguments);
												}
												else if (parent_stuff /*exists*/) {
													stuff_emitter .trigger ('must', arguments);
													
													//event bubbling
													parent_stuff .trigger .apply ({}, arguments);
												}
												else if (parent_node /*exists*/) {
													//bubble as dom event
													send_event (parent_node) .apply (this, arguments);
												}
											};
							};	
		var with_redefined =	function (key, value_maker) {
									return	function (thing) {
												var redefined_thing = Object .create (thing);
												Object .defineProperty (redefined_thing, key,
													{
														enumerable: true,
														configurable: true,
														writable: true,
														value: value_maker (thing)
													}
												);
												return redefined_thing;
											};
								};

	
var send_event =	function (element) {
						return	function () {
									element .dispatchEvent (
										new CustomEvent ('self', { 'detail': arguments, bubbles: true } )
									);
								};
					};
	
	
	
var tags = riot .mount ('*');
//log (navigator .userAgent);


//var the_app = riot .util .vdom [0];

//(function (self) {
	var reload =	function () {
						screens .add_as ('page') .apply (null,
							[tag_name (page_name (window .location .hash))] .concat (page_arguments (window .location .hash)));
					};
	
	if (! window .location .hash)
		window .location .hash = '#login';
	
	window .addEventListener ('hashchange', reload);
	reload ();
	
	/*self .stuff .on ('on-page', function (page) {
		window .location .hash = '#' + page;
	});*/
	//self .stuff .trigger ('on-page', /*truthy_nicely_logged_with ('preexisting hash')*/ (isolate_hash (window .location .hash)) || 'matches-see');
//})(the_app);</script>
	</body>
</html>